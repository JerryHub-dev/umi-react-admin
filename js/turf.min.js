!(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], e)
    : e(((t = 'undefined' != typeof globalThis ? globalThis : t || self).turf = {}));
})(this, function (t) {
  'use strict';
  function e(t) {
    return (
      (e =
        'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
          ? function (t) {
              return typeof t;
            }
          : function (t) {
              return t && 'function' == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype
                ? 'symbol'
                : typeof t;
            }),
      e(t)
    );
  }
  function n(t, e) {
    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function');
  }
  function r(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      (r.enumerable = r.enumerable || !1),
        (r.configurable = !0),
        'value' in r && (r.writable = !0),
        Object.defineProperty(t, h(r.key), r);
    }
  }
  function i(t, e, n) {
    return e && r(t.prototype, e), n && r(t, n), Object.defineProperty(t, 'prototype', { writable: !1 }), t;
  }
  function o(t, e, n) {
    return (
      (e = h(e)) in t
        ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 })
        : (t[e] = n),
      t
    );
  }
  function a(t, e) {
    return (
      (function (t) {
        if (Array.isArray(t)) return t;
      })(t) ||
      (function (t, e) {
        var n = null == t ? null : ('undefined' != typeof Symbol && t[Symbol.iterator]) || t['@@iterator'];
        if (null != n) {
          var r,
            i,
            o,
            a,
            s = [],
            u = !0,
            l = !1;
          try {
            if (((o = (n = n.call(t)).next), 0 === e)) {
              if (Object(n) !== n) return;
              u = !1;
            } else for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== e); u = !0);
          } catch (t) {
            (l = !0), (i = t);
          } finally {
            try {
              if (!u && null != n.return && ((a = n.return()), Object(a) !== a)) return;
            } finally {
              if (l) throw i;
            }
          }
          return s;
        }
      })(t, e) ||
      u(t, e) ||
      (function () {
        throw new TypeError(
          'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
        );
      })()
    );
  }
  function s(t) {
    return (
      (function (t) {
        if (Array.isArray(t)) return l(t);
      })(t) ||
      (function (t) {
        if (('undefined' != typeof Symbol && null != t[Symbol.iterator]) || null != t['@@iterator'])
          return Array.from(t);
      })(t) ||
      u(t) ||
      (function () {
        throw new TypeError(
          'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
        );
      })()
    );
  }
  function u(t, e) {
    if (t) {
      if ('string' == typeof t) return l(t, e);
      var n = Object.prototype.toString.call(t).slice(8, -1);
      return (
        'Object' === n && t.constructor && (n = t.constructor.name),
        'Map' === n || 'Set' === n
          ? Array.from(t)
          : 'Arguments' === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
          ? l(t, e)
          : void 0
      );
    }
  }
  function l(t, e) {
    (null == e || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r;
  }
  function c(t, e) {
    var n = ('undefined' != typeof Symbol && t[Symbol.iterator]) || t['@@iterator'];
    if (!n) {
      if (Array.isArray(t) || (n = u(t)) || (e && t && 'number' == typeof t.length)) {
        n && (t = n);
        var r = 0,
          i = function () {};
        return {
          s: i,
          n: function () {
            return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] };
          },
          e: function (t) {
            throw t;
          },
          f: i,
        };
      }
      throw new TypeError(
        'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
      );
    }
    var o,
      a = !0,
      s = !1;
    return {
      s: function () {
        n = n.call(t);
      },
      n: function () {
        var t = n.next();
        return (a = t.done), t;
      },
      e: function (t) {
        (s = !0), (o = t);
      },
      f: function () {
        try {
          a || null == n.return || n.return();
        } finally {
          if (s) throw o;
        }
      },
    };
  }
  function h(t) {
    var e = (function (t, e) {
      if ('object' != typeof t || null === t) return t;
      var n = t[Symbol.toPrimitive];
      if (void 0 !== n) {
        var r = n.call(t, e || 'default');
        if ('object' != typeof r) return r;
        throw new TypeError('@@toPrimitive must return a primitive value.');
      }
      return ('string' === e ? String : Number)(t);
    })(t, 'string');
    return 'symbol' == typeof e ? e : String(e);
  }
  var f =
    'undefined' != typeof globalThis
      ? globalThis
      : 'undefined' != typeof window
      ? window
      : 'undefined' != typeof global
      ? global
      : 'undefined' != typeof self
      ? self
      : {};
  function p(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, 'default') ? t.default : t;
  }
  function g(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if ('function' == typeof e) {
      var n = function t() {
        return this instanceof t ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
      };
      n.prototype = e.prototype;
    } else n = {};
    return (
      Object.defineProperty(n, '__esModule', { value: !0 }),
      Object.keys(t).forEach(function (e) {
        var r = Object.getOwnPropertyDescriptor(t, e);
        Object.defineProperty(
          n,
          e,
          r.get
            ? r
            : {
                enumerable: !0,
                get: function () {
                  return t[e];
                },
              },
        );
      }),
      n
    );
  }
  var y,
    v,
    d = Object.prototype.toString,
    m = function (t) {
      var n = d.call(t),
        r = '[object Arguments]' === n;
      return (
        r ||
          (r =
            '[object Array]' !== n &&
            null !== t &&
            'object' === e(t) &&
            'number' == typeof t.length &&
            t.length >= 0 &&
            '[object Function]' === d.call(t.callee)),
        r
      );
    };
  var _ = Array.prototype.slice,
    b = m,
    x = Object.keys,
    E = x
      ? function (t) {
          return x(t);
        }
      : (function () {
          if (v) return y;
          var t;
          if (((v = 1), !Object.keys)) {
            var n = Object.prototype.hasOwnProperty,
              r = Object.prototype.toString,
              i = m,
              o = Object.prototype.propertyIsEnumerable,
              a = !o.call({ toString: null }, 'toString'),
              s = o.call(function () {}, 'prototype'),
              u = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor',
              ],
              l = function (t) {
                var e = t.constructor;
                return e && e.prototype === t;
              },
              c = {
                $applicationCache: !0,
                $console: !0,
                $external: !0,
                $frame: !0,
                $frameElement: !0,
                $frames: !0,
                $innerHeight: !0,
                $innerWidth: !0,
                $onmozfullscreenchange: !0,
                $onmozfullscreenerror: !0,
                $outerHeight: !0,
                $outerWidth: !0,
                $pageXOffset: !0,
                $pageYOffset: !0,
                $parent: !0,
                $scrollLeft: !0,
                $scrollTop: !0,
                $scrollX: !0,
                $scrollY: !0,
                $self: !0,
                $webkitIndexedDB: !0,
                $webkitStorageInfo: !0,
                $window: !0,
              },
              h = (function () {
                if ('undefined' == typeof window) return !1;
                for (var t in window)
                  try {
                    if (!c['$' + t] && n.call(window, t) && null !== window[t] && 'object' === e(window[t]))
                      try {
                        l(window[t]);
                      } catch (t) {
                        return !0;
                      }
                  } catch (t) {
                    return !0;
                  }
                return !1;
              })();
            t = function (t) {
              var o = null !== t && 'object' === e(t),
                c = '[object Function]' === r.call(t),
                f = i(t),
                p = o && '[object String]' === r.call(t),
                g = [];
              if (!o && !c && !f) throw new TypeError('Object.keys called on a non-object');
              var y = s && c;
              if (p && t.length > 0 && !n.call(t, 0)) for (var v = 0; v < t.length; ++v) g.push(String(v));
              if (f && t.length > 0) for (var d = 0; d < t.length; ++d) g.push(String(d));
              else for (var m in t) (y && 'prototype' === m) || !n.call(t, m) || g.push(String(m));
              if (a)
                for (
                  var _ = (function (t) {
                      if ('undefined' == typeof window || !h) return l(t);
                      try {
                        return l(t);
                      } catch (t) {
                        return !1;
                      }
                    })(t),
                    b = 0;
                  b < u.length;
                  ++b
                )
                  (_ && 'constructor' === u[b]) || !n.call(t, u[b]) || g.push(u[b]);
              return g;
            };
          }
          return (y = t);
        })(),
    w = Object.keys;
  E.shim = function () {
    if (Object.keys) {
      var t = (function () {
        var t = Object.keys(arguments);
        return t && t.length === arguments.length;
      })(1, 2);
      t ||
        (Object.keys = function (t) {
          return b(t) ? w(_.call(t)) : w(t);
        });
    } else Object.keys = E;
    return Object.keys || E;
  };
  var k,
    S = E,
    I = function () {
      if ('function' != typeof Symbol || 'function' != typeof Object.getOwnPropertySymbols) return !1;
      if ('symbol' === e(Symbol.iterator)) return !0;
      var t = {},
        n = Symbol('test'),
        r = Object(n);
      if ('string' == typeof n) return !1;
      if ('[object Symbol]' !== Object.prototype.toString.call(n)) return !1;
      if ('[object Symbol]' !== Object.prototype.toString.call(r)) return !1;
      for (n in ((t[n] = 42), t)) return !1;
      if ('function' == typeof Object.keys && 0 !== Object.keys(t).length) return !1;
      if ('function' == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t).length) return !1;
      var i = Object.getOwnPropertySymbols(t);
      if (1 !== i.length || i[0] !== n) return !1;
      if (!Object.prototype.propertyIsEnumerable.call(t, n)) return !1;
      if ('function' == typeof Object.getOwnPropertyDescriptor) {
        var o = Object.getOwnPropertyDescriptor(t, n);
        if (42 !== o.value || !0 !== o.enumerable) return !1;
      }
      return !0;
    },
    P = 'undefined' != typeof Symbol && Symbol,
    N = I,
    M = function () {
      return (
        'function' == typeof P &&
        'function' == typeof Symbol &&
        'symbol' === e(P('foo')) &&
        'symbol' === e(Symbol('bar')) &&
        N()
      );
    },
    O = { foo: {} },
    L = Object,
    R = Object.prototype.toString,
    C = Math.max,
    T = function (t, e) {
      for (var n = [], r = 0; r < t.length; r += 1) n[r] = t[r];
      for (var i = 0; i < e.length; i += 1) n[i + t.length] = e[i];
      return n;
    },
    A = function (t) {
      var e = this;
      if ('function' != typeof e || '[object Function]' !== R.apply(e))
        throw new TypeError('Function.prototype.bind called on incompatible ' + e);
      for (
        var n,
          r = (function (t, e) {
            for (var n = [], r = e || 0, i = 0; r < t.length; r += 1, i += 1) n[i] = t[r];
            return n;
          })(arguments, 1),
          i = C(0, e.length - r.length),
          o = [],
          a = 0;
        a < i;
        a++
      )
        o[a] = '$' + a;
      if (
        ((n = Function(
          'binder',
          'return function (' +
            (function (t, e) {
              for (var n = '', r = 0; r < t.length; r += 1) (n += t[r]), r + 1 < t.length && (n += e);
              return n;
            })(o, ',') +
            '){ return binder.apply(this,arguments); }',
        )(function () {
          if (this instanceof n) {
            var i = e.apply(this, T(r, arguments));
            return Object(i) === i ? i : this;
          }
          return e.apply(t, T(r, arguments));
        })),
        e.prototype)
      ) {
        var s = function () {};
        (s.prototype = e.prototype), (n.prototype = new s()), (s.prototype = null);
      }
      return n;
    },
    D = Function.prototype.bind || A,
    j = Function.prototype.call,
    F = Object.prototype.hasOwnProperty,
    B = D.call(j, F),
    q = SyntaxError,
    V = Function,
    G = TypeError,
    Y = function (t) {
      try {
        return V('"use strict"; return (' + t + ').constructor;')();
      } catch (t) {}
    },
    z = Object.getOwnPropertyDescriptor;
  if (z)
    try {
      z({}, '');
    } catch (t) {
      z = null;
    }
  var U = function () {
      throw new G();
    },
    X = z
      ? (function () {
          try {
            return U;
          } catch (t) {
            try {
              return z(arguments, 'callee').get;
            } catch (t) {
              return U;
            }
          }
        })()
      : U,
    W = M(),
    H = { __proto__: O }.foo === O.foo && !({ __proto__: null } instanceof L),
    Z =
      Object.getPrototypeOf ||
      (H
        ? function (t) {
            return t.__proto__;
          }
        : null),
    J = {},
    $ = 'undefined' != typeof Uint8Array && Z ? Z(Uint8Array) : k,
    Q = {
      '%AggregateError%': 'undefined' == typeof AggregateError ? k : AggregateError,
      '%Array%': Array,
      '%ArrayBuffer%': 'undefined' == typeof ArrayBuffer ? k : ArrayBuffer,
      '%ArrayIteratorPrototype%': W && Z ? Z([][Symbol.iterator]()) : k,
      '%AsyncFromSyncIteratorPrototype%': k,
      '%AsyncFunction%': J,
      '%AsyncGenerator%': J,
      '%AsyncGeneratorFunction%': J,
      '%AsyncIteratorPrototype%': J,
      '%Atomics%': 'undefined' == typeof Atomics ? k : Atomics,
      '%BigInt%': 'undefined' == typeof BigInt ? k : BigInt,
      '%BigInt64Array%': 'undefined' == typeof BigInt64Array ? k : BigInt64Array,
      '%BigUint64Array%': 'undefined' == typeof BigUint64Array ? k : BigUint64Array,
      '%Boolean%': Boolean,
      '%DataView%': 'undefined' == typeof DataView ? k : DataView,
      '%Date%': Date,
      '%decodeURI%': decodeURI,
      '%decodeURIComponent%': decodeURIComponent,
      '%encodeURI%': encodeURI,
      '%encodeURIComponent%': encodeURIComponent,
      '%Error%': Error,
      '%eval%': eval,
      '%EvalError%': EvalError,
      '%Float32Array%': 'undefined' == typeof Float32Array ? k : Float32Array,
      '%Float64Array%': 'undefined' == typeof Float64Array ? k : Float64Array,
      '%FinalizationRegistry%': 'undefined' == typeof FinalizationRegistry ? k : FinalizationRegistry,
      '%Function%': V,
      '%GeneratorFunction%': J,
      '%Int8Array%': 'undefined' == typeof Int8Array ? k : Int8Array,
      '%Int16Array%': 'undefined' == typeof Int16Array ? k : Int16Array,
      '%Int32Array%': 'undefined' == typeof Int32Array ? k : Int32Array,
      '%isFinite%': isFinite,
      '%isNaN%': isNaN,
      '%IteratorPrototype%': W && Z ? Z(Z([][Symbol.iterator]())) : k,
      '%JSON%': 'object' === ('undefined' == typeof JSON ? 'undefined' : e(JSON)) ? JSON : k,
      '%Map%': 'undefined' == typeof Map ? k : Map,
      '%MapIteratorPrototype%': 'undefined' != typeof Map && W && Z ? Z(new Map()[Symbol.iterator]()) : k,
      '%Math%': Math,
      '%Number%': Number,
      '%Object%': Object,
      '%parseFloat%': parseFloat,
      '%parseInt%': parseInt,
      '%Promise%': 'undefined' == typeof Promise ? k : Promise,
      '%Proxy%': 'undefined' == typeof Proxy ? k : Proxy,
      '%RangeError%': RangeError,
      '%ReferenceError%': ReferenceError,
      '%Reflect%': 'undefined' == typeof Reflect ? k : Reflect,
      '%RegExp%': RegExp,
      '%Set%': 'undefined' == typeof Set ? k : Set,
      '%SetIteratorPrototype%': 'undefined' != typeof Set && W && Z ? Z(new Set()[Symbol.iterator]()) : k,
      '%SharedArrayBuffer%': 'undefined' == typeof SharedArrayBuffer ? k : SharedArrayBuffer,
      '%String%': String,
      '%StringIteratorPrototype%': W && Z ? Z(''[Symbol.iterator]()) : k,
      '%Symbol%': W ? Symbol : k,
      '%SyntaxError%': q,
      '%ThrowTypeError%': X,
      '%TypedArray%': $,
      '%TypeError%': G,
      '%Uint8Array%': 'undefined' == typeof Uint8Array ? k : Uint8Array,
      '%Uint8ClampedArray%': 'undefined' == typeof Uint8ClampedArray ? k : Uint8ClampedArray,
      '%Uint16Array%': 'undefined' == typeof Uint16Array ? k : Uint16Array,
      '%Uint32Array%': 'undefined' == typeof Uint32Array ? k : Uint32Array,
      '%URIError%': URIError,
      '%WeakMap%': 'undefined' == typeof WeakMap ? k : WeakMap,
      '%WeakRef%': 'undefined' == typeof WeakRef ? k : WeakRef,
      '%WeakSet%': 'undefined' == typeof WeakSet ? k : WeakSet,
    };
  if (Z)
    try {
      null.error;
    } catch (t) {
      var K = Z(Z(t));
      Q['%Error.prototype%'] = K;
    }
  var tt = function t(e) {
      var n;
      if ('%AsyncFunction%' === e) n = Y('async function () {}');
      else if ('%GeneratorFunction%' === e) n = Y('function* () {}');
      else if ('%AsyncGeneratorFunction%' === e) n = Y('async function* () {}');
      else if ('%AsyncGenerator%' === e) {
        var r = t('%AsyncGeneratorFunction%');
        r && (n = r.prototype);
      } else if ('%AsyncIteratorPrototype%' === e) {
        var i = t('%AsyncGenerator%');
        i && Z && (n = Z(i.prototype));
      }
      return (Q[e] = n), n;
    },
    et = {
      '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
      '%ArrayPrototype%': ['Array', 'prototype'],
      '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
      '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
      '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
      '%ArrayProto_values%': ['Array', 'prototype', 'values'],
      '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
      '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
      '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
      '%BooleanPrototype%': ['Boolean', 'prototype'],
      '%DataViewPrototype%': ['DataView', 'prototype'],
      '%DatePrototype%': ['Date', 'prototype'],
      '%ErrorPrototype%': ['Error', 'prototype'],
      '%EvalErrorPrototype%': ['EvalError', 'prototype'],
      '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
      '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
      '%FunctionPrototype%': ['Function', 'prototype'],
      '%Generator%': ['GeneratorFunction', 'prototype'],
      '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
      '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
      '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
      '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
      '%JSONParse%': ['JSON', 'parse'],
      '%JSONStringify%': ['JSON', 'stringify'],
      '%MapPrototype%': ['Map', 'prototype'],
      '%NumberPrototype%': ['Number', 'prototype'],
      '%ObjectPrototype%': ['Object', 'prototype'],
      '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
      '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
      '%PromisePrototype%': ['Promise', 'prototype'],
      '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
      '%Promise_all%': ['Promise', 'all'],
      '%Promise_reject%': ['Promise', 'reject'],
      '%Promise_resolve%': ['Promise', 'resolve'],
      '%RangeErrorPrototype%': ['RangeError', 'prototype'],
      '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
      '%RegExpPrototype%': ['RegExp', 'prototype'],
      '%SetPrototype%': ['Set', 'prototype'],
      '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
      '%StringPrototype%': ['String', 'prototype'],
      '%SymbolPrototype%': ['Symbol', 'prototype'],
      '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
      '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
      '%TypeErrorPrototype%': ['TypeError', 'prototype'],
      '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
      '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
      '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
      '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
      '%URIErrorPrototype%': ['URIError', 'prototype'],
      '%WeakMapPrototype%': ['WeakMap', 'prototype'],
      '%WeakSetPrototype%': ['WeakSet', 'prototype'],
    },
    nt = D,
    rt = B,
    it = nt.call(Function.call, Array.prototype.concat),
    ot = nt.call(Function.apply, Array.prototype.splice),
    at = nt.call(Function.call, String.prototype.replace),
    st = nt.call(Function.call, String.prototype.slice),
    ut = nt.call(Function.call, RegExp.prototype.exec),
    lt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    ct = /\\(\\)?/g,
    ht = function (t, e) {
      var n,
        r = t;
      if ((rt(et, r) && (r = '%' + (n = et[r])[0] + '%'), rt(Q, r))) {
        var i = Q[r];
        if ((i === J && (i = tt(r)), void 0 === i && !e))
          throw new G('intrinsic ' + t + ' exists, but is not available. Please file an issue!');
        return { alias: n, name: r, value: i };
      }
      throw new q('intrinsic ' + t + ' does not exist!');
    },
    ft = function (t, e) {
      if ('string' != typeof t || 0 === t.length) throw new G('intrinsic name must be a non-empty string');
      if (arguments.length > 1 && 'boolean' != typeof e) throw new G('"allowMissing" argument must be a boolean');
      if (null === ut(/^%?[^%]*%?$/, t))
        throw new q('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
      var n = (function (t) {
          var e = st(t, 0, 1),
            n = st(t, -1);
          if ('%' === e && '%' !== n) throw new q('invalid intrinsic syntax, expected closing `%`');
          if ('%' === n && '%' !== e) throw new q('invalid intrinsic syntax, expected opening `%`');
          var r = [];
          return (
            at(t, lt, function (t, e, n, i) {
              r[r.length] = n ? at(i, ct, '$1') : e || t;
            }),
            r
          );
        })(t),
        r = n.length > 0 ? n[0] : '',
        i = ht('%' + r + '%', e),
        o = i.name,
        a = i.value,
        s = !1,
        u = i.alias;
      u && ((r = u[0]), ot(n, it([0, 1], u)));
      for (var l = 1, c = !0; l < n.length; l += 1) {
        var h = n[l],
          f = st(h, 0, 1),
          p = st(h, -1);
        if (('"' === f || "'" === f || '`' === f || '"' === p || "'" === p || '`' === p) && f !== p)
          throw new q('property names with quotes must have matching quotes');
        if ((('constructor' !== h && c) || (s = !0), rt(Q, (o = '%' + (r += '.' + h) + '%')))) a = Q[o];
        else if (null != a) {
          if (!(h in a)) {
            if (!e) throw new G('base intrinsic for ' + t + ' exists, but the property is not available.');
            return;
          }
          if (z && l + 1 >= n.length) {
            var g = z(a, h);
            a = (c = !!g) && 'get' in g && !('originalValue' in g.get) ? g.get : a[h];
          } else (c = rt(a, h)), (a = a[h]);
          c && !s && (Q[o] = a);
        }
      }
      return a;
    },
    pt = ft('%Object.defineProperty%', !0),
    gt = function () {
      if (pt)
        try {
          return pt({}, 'a', { value: 1 }), !0;
        } catch (t) {
          return !1;
        }
      return !1;
    };
  gt.hasArrayLengthDefineBug = function () {
    if (!gt()) return null;
    try {
      return 1 !== pt([], 'length', { value: 1 }).length;
    } catch (t) {
      return !0;
    }
  };
  var yt = gt,
    vt = ft('%Object.getOwnPropertyDescriptor%', !0);
  if (vt)
    try {
      vt([], 'length');
    } catch (t) {
      vt = null;
    }
  var dt = vt,
    mt = yt(),
    _t = ft,
    bt = mt && _t('%Object.defineProperty%', !0);
  if (bt)
    try {
      bt({}, 'a', { value: 1 });
    } catch (t) {
      bt = !1;
    }
  var xt = _t('%SyntaxError%'),
    Et = _t('%TypeError%'),
    wt = dt,
    kt = function (t, n, r) {
      if (!t || ('object' !== e(t) && 'function' != typeof t)) throw new Et('`obj` must be an object or a function`');
      if ('string' != typeof n && 'symbol' !== e(n)) throw new Et('`property` must be a string or a symbol`');
      if (arguments.length > 3 && 'boolean' != typeof arguments[3] && null !== arguments[3])
        throw new Et('`nonEnumerable`, if provided, must be a boolean or null');
      if (arguments.length > 4 && 'boolean' != typeof arguments[4] && null !== arguments[4])
        throw new Et('`nonWritable`, if provided, must be a boolean or null');
      if (arguments.length > 5 && 'boolean' != typeof arguments[5] && null !== arguments[5])
        throw new Et('`nonConfigurable`, if provided, must be a boolean or null');
      if (arguments.length > 6 && 'boolean' != typeof arguments[6])
        throw new Et('`loose`, if provided, must be a boolean');
      var i = arguments.length > 3 ? arguments[3] : null,
        o = arguments.length > 4 ? arguments[4] : null,
        a = arguments.length > 5 ? arguments[5] : null,
        s = arguments.length > 6 && arguments[6],
        u = !!wt && wt(t, n);
      if (bt)
        bt(t, n, {
          configurable: null === a && u ? u.configurable : !a,
          enumerable: null === i && u ? u.enumerable : !i,
          value: r,
          writable: null === o && u ? u.writable : !o,
        });
      else {
        if (!s && (i || o || a))
          throw new xt(
            'This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.',
          );
        t[n] = r;
      }
    },
    St = S,
    It = 'function' == typeof Symbol && 'symbol' === e(Symbol('foo')),
    Pt = Object.prototype.toString,
    Nt = Array.prototype.concat,
    Mt = kt,
    Ot = yt(),
    Lt = function (t, e, n, r) {
      if (e in t)
        if (!0 === r) {
          if (t[e] === n) return;
        } else if ('function' != typeof (i = r) || '[object Function]' !== Pt.call(i) || !r()) return;
      var i;
      Ot ? Mt(t, e, n, !0) : Mt(t, e, n);
    },
    Rt = function (t, e) {
      var n = arguments.length > 2 ? arguments[2] : {},
        r = St(e);
      It && (r = Nt.call(r, Object.getOwnPropertySymbols(e)));
      for (var i = 0; i < r.length; i += 1) Lt(t, r[i], e[r[i]], n[r[i]]);
    };
  Rt.supportsDescriptors = !!Ot;
  var Ct = Rt,
    Tt = { exports: {} },
    At = ft,
    Dt = kt,
    jt = yt(),
    Ft = dt,
    Bt = At('%TypeError%'),
    qt = At('%Math.floor%'),
    Vt = function (t, e) {
      if ('function' != typeof t) throw new Bt('`fn` is not a function');
      if ('number' != typeof e || e < 0 || e > 4294967295 || qt(e) !== e)
        throw new Bt('`length` must be a positive 32-bit integer');
      var n = arguments.length > 2 && !!arguments[2],
        r = !0,
        i = !0;
      if ('length' in t && Ft) {
        var o = Ft(t, 'length');
        o && !o.configurable && (r = !1), o && !o.writable && (i = !1);
      }
      return (r || i || !n) && (jt ? Dt(t, 'length', e, !0, !0) : Dt(t, 'length', e)), t;
    };
  !(function (t) {
    var e = D,
      n = ft,
      r = Vt,
      i = n('%TypeError%'),
      o = n('%Function.prototype.apply%'),
      a = n('%Function.prototype.call%'),
      s = n('%Reflect.apply%', !0) || e.call(a, o),
      u = n('%Object.defineProperty%', !0),
      l = n('%Math.max%');
    if (u)
      try {
        u({}, 'a', { value: 1 });
      } catch (t) {
        u = null;
      }
    t.exports = function (t) {
      if ('function' != typeof t) throw new i('a function is required');
      var n = s(e, a, arguments);
      return r(n, 1 + l(0, t.length - (arguments.length - 1)), !0);
    };
    var c = function () {
      return s(e, o, arguments);
    };
    u ? u(t.exports, 'apply', { value: c }) : (t.exports.apply = c);
  })(Tt);
  var Gt = Tt.exports,
    Yt = ft,
    zt = Gt,
    Ut = zt(Yt('String.prototype.indexOf')),
    Xt = function (t, e) {
      var n = Yt(t, !!e);
      return 'function' == typeof n && Ut(t, '.prototype.') > -1 ? zt(n) : n;
    },
    Wt = S,
    Ht = I(),
    Zt = Xt,
    Jt = Object,
    $t = Zt('Array.prototype.push'),
    Qt = Zt('Object.prototype.propertyIsEnumerable'),
    Kt = Ht ? Object.getOwnPropertySymbols : null,
    te = function (t, e) {
      if (null == t) throw new TypeError('target must be an object');
      var n = Jt(t);
      if (1 === arguments.length) return n;
      for (var r = 1; r < arguments.length; ++r) {
        var i = Jt(arguments[r]),
          o = Wt(i),
          a = Ht && (Object.getOwnPropertySymbols || Kt);
        if (a)
          for (var s = a(i), u = 0; u < s.length; ++u) {
            var l = s[u];
            Qt(i, l) && $t(o, l);
          }
        for (var c = 0; c < o.length; ++c) {
          var h = o[c];
          if (Qt(i, h)) {
            var f = i[h];
            n[h] = f;
          }
        }
      }
      return n;
    },
    ee = te,
    ne = function () {
      return Object.assign
        ? (function () {
            if (!Object.assign) return !1;
            for (var t = 'abcdefghijklmnopqrst', e = t.split(''), n = {}, r = 0; r < e.length; ++r) n[e[r]] = e[r];
            var i = Object.assign({}, n),
              o = '';
            for (var a in i) o += a;
            return t !== o;
          })() ||
          (function () {
            if (!Object.assign || !Object.preventExtensions) return !1;
            var t = Object.preventExtensions({ 1: 2 });
            try {
              Object.assign(t, 'xy');
            } catch (e) {
              return 'y' === t[1];
            }
            return !1;
          })()
          ? ee
          : Object.assign
        : ee;
    },
    re = Ct,
    ie = ne,
    oe = Ct,
    ae = te,
    se = ne,
    ue = function () {
      var t = ie();
      return (
        re(
          Object,
          { assign: t },
          {
            assign: function () {
              return Object.assign !== t;
            },
          },
        ),
        t
      );
    },
    le = Gt.apply(se()),
    ce = function (t, e) {
      return le(Object, arguments);
    };
  oe(ce, { getPolyfill: se, implementation: ae, shim: ue });
  var he = ce,
    fe = function () {
      return 'string' == typeof function () {}.name;
    },
    pe = Object.getOwnPropertyDescriptor;
  if (pe)
    try {
      pe([], 'length');
    } catch (t) {
      pe = null;
    }
  fe.functionsHaveConfigurableNames = function () {
    if (!fe() || !pe) return !1;
    var t = pe(function () {}, 'name');
    return !!t && !!t.configurable;
  };
  var ge = Function.prototype.bind;
  fe.boundFunctionsHaveNames = function () {
    return fe() && 'function' == typeof ge && '' !== function () {}.bind().name;
  };
  var ye = fe,
    ve = kt,
    de = yt(),
    me = ye.functionsHaveConfigurableNames(),
    _e = TypeError,
    be = function (t, e) {
      if ('function' != typeof t) throw new _e('`fn` is not a function');
      return (arguments.length > 2 && !!arguments[2] && !me) || (de ? ve(t, 'name', e, !0, !0) : ve(t, 'name', e)), t;
    },
    xe = Object,
    Ee = TypeError,
    we = be(
      function () {
        if (null != this && this !== xe(this)) throw new Ee('RegExp.prototype.flags getter called on non-object');
        var t = '';
        return (
          this.hasIndices && (t += 'd'),
          this.global && (t += 'g'),
          this.ignoreCase && (t += 'i'),
          this.multiline && (t += 'm'),
          this.dotAll && (t += 's'),
          this.unicode && (t += 'u'),
          this.unicodeSets && (t += 'v'),
          this.sticky && (t += 'y'),
          t
        );
      },
      'get flags',
      !0,
    ),
    ke = we,
    Se = Ct.supportsDescriptors,
    Ie = Object.getOwnPropertyDescriptor,
    Pe = function () {
      if (Se && 'gim' === /a/gim.flags) {
        var t = Ie(RegExp.prototype, 'flags');
        if (
          t &&
          'function' == typeof t.get &&
          'boolean' == typeof RegExp.prototype.dotAll &&
          'boolean' == typeof RegExp.prototype.hasIndices
        ) {
          var e = '',
            n = {};
          if (
            (Object.defineProperty(n, 'hasIndices', {
              get: function () {
                e += 'd';
              },
            }),
            Object.defineProperty(n, 'sticky', {
              get: function () {
                e += 'y';
              },
            }),
            'dy' === e)
          )
            return t.get;
        }
      }
      return ke;
    },
    Ne = Ct.supportsDescriptors,
    Me = Pe,
    Oe = Object.getOwnPropertyDescriptor,
    Le = Object.defineProperty,
    Re = TypeError,
    Ce = Object.getPrototypeOf,
    Te = /a/,
    Ae = Ct,
    De = we,
    je = Pe,
    Fe = function () {
      if (!Ne || !Ce)
        throw new Re('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
      var t = Me(),
        e = Ce(Te),
        n = Oe(e, 'flags');
      return (n && n.get === t) || Le(e, 'flags', { configurable: !0, enumerable: !1, get: t }), t;
    },
    Be = Gt(je());
  Ae(Be, { getPolyfill: je, implementation: De, shim: Fe });
  var qe = Be,
    Ve = Symbol.iterator,
    Ge =
      'undefined' != typeof global
        ? global
        : 'undefined' != typeof self
        ? self
        : 'undefined' != typeof window
        ? window
        : {},
    Ye = [],
    ze = [],
    Ue = 'undefined' != typeof Uint8Array ? Uint8Array : Array,
    Xe = !1;
  function We() {
    Xe = !0;
    for (var t = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', e = 0; e < 64; ++e)
      (Ye[e] = t[e]), (ze[t.charCodeAt(e)] = e);
    (ze['-'.charCodeAt(0)] = 62), (ze['_'.charCodeAt(0)] = 63);
  }
  function He(t, e, n) {
    for (var r, i, o = [], a = e; a < n; a += 3)
      (r = (t[a] << 16) + (t[a + 1] << 8) + t[a + 2]),
        o.push(Ye[((i = r) >> 18) & 63] + Ye[(i >> 12) & 63] + Ye[(i >> 6) & 63] + Ye[63 & i]);
    return o.join('');
  }
  function Ze(t) {
    var e;
    Xe || We();
    for (var n = t.length, r = n % 3, i = '', o = [], a = 16383, s = 0, u = n - r; s < u; s += a)
      o.push(He(t, s, s + a > u ? u : s + a));
    return (
      1 === r
        ? ((e = t[n - 1]), (i += Ye[e >> 2]), (i += Ye[(e << 4) & 63]), (i += '=='))
        : 2 === r &&
          ((e = (t[n - 2] << 8) + t[n - 1]),
          (i += Ye[e >> 10]),
          (i += Ye[(e >> 4) & 63]),
          (i += Ye[(e << 2) & 63]),
          (i += '=')),
      o.push(i),
      o.join('')
    );
  }
  function Je(t, e, n, r, i) {
    var o,
      a,
      s = 8 * i - r - 1,
      u = (1 << s) - 1,
      l = u >> 1,
      c = -7,
      h = n ? i - 1 : 0,
      f = n ? -1 : 1,
      p = t[e + h];
    for (h += f, o = p & ((1 << -c) - 1), p >>= -c, c += s; c > 0; o = 256 * o + t[e + h], h += f, c -= 8);
    for (a = o & ((1 << -c) - 1), o >>= -c, c += r; c > 0; a = 256 * a + t[e + h], h += f, c -= 8);
    if (0 === o) o = 1 - l;
    else {
      if (o === u) return a ? NaN : (1 / 0) * (p ? -1 : 1);
      (a += Math.pow(2, r)), (o -= l);
    }
    return (p ? -1 : 1) * a * Math.pow(2, o - r);
  }
  function $e(t, e, n, r, i, o) {
    var a,
      s,
      u,
      l = 8 * o - i - 1,
      c = (1 << l) - 1,
      h = c >> 1,
      f = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
      p = r ? 0 : o - 1,
      g = r ? 1 : -1,
      y = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
    for (
      e = Math.abs(e),
        isNaN(e) || e === 1 / 0
          ? ((s = isNaN(e) ? 1 : 0), (a = c))
          : ((a = Math.floor(Math.log(e) / Math.LN2)),
            e * (u = Math.pow(2, -a)) < 1 && (a--, (u *= 2)),
            (e += a + h >= 1 ? f / u : f * Math.pow(2, 1 - h)) * u >= 2 && (a++, (u /= 2)),
            a + h >= c
              ? ((s = 0), (a = c))
              : a + h >= 1
              ? ((s = (e * u - 1) * Math.pow(2, i)), (a += h))
              : ((s = e * Math.pow(2, h - 1) * Math.pow(2, i)), (a = 0)));
      i >= 8;
      t[n + p] = 255 & s, p += g, s /= 256, i -= 8
    );
    for (a = (a << i) | s, l += i; l > 0; t[n + p] = 255 & a, p += g, a /= 256, l -= 8);
    t[n + p - g] |= 128 * y;
  }
  var Qe = {}.toString,
    Ke =
      Array.isArray ||
      function (t) {
        return '[object Array]' == Qe.call(t);
      };
  function tn() {
    return nn.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function en(t, e) {
    if (tn() < e) throw new RangeError('Invalid typed array length');
    return (
      nn.TYPED_ARRAY_SUPPORT
        ? ((t = new Uint8Array(e)).__proto__ = nn.prototype)
        : (null === t && (t = new nn(e)), (t.length = e)),
      t
    );
  }
  function nn(t, e, n) {
    if (!(nn.TYPED_ARRAY_SUPPORT || this instanceof nn)) return new nn(t, e, n);
    if ('number' == typeof t) {
      if ('string' == typeof e) throw new Error('If encoding is specified then the first argument must be a string');
      return an(this, t);
    }
    return rn(this, t, e, n);
  }
  function rn(t, e, n, r) {
    if ('number' == typeof e) throw new TypeError('"value" argument must not be a number');
    return 'undefined' != typeof ArrayBuffer && e instanceof ArrayBuffer
      ? (function (t, e, n, r) {
          if ((e.byteLength, n < 0 || e.byteLength < n)) throw new RangeError("'offset' is out of bounds");
          if (e.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds");
          e =
            void 0 === n && void 0 === r
              ? new Uint8Array(e)
              : void 0 === r
              ? new Uint8Array(e, n)
              : new Uint8Array(e, n, r);
          nn.TYPED_ARRAY_SUPPORT ? ((t = e).__proto__ = nn.prototype) : (t = sn(t, e));
          return t;
        })(t, e, n, r)
      : 'string' == typeof e
      ? (function (t, e, n) {
          ('string' == typeof n && '' !== n) || (n = 'utf8');
          if (!nn.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding');
          var r = 0 | cn(e, n);
          t = en(t, r);
          var i = t.write(e, n);
          i !== r && (t = t.slice(0, i));
          return t;
        })(t, e, n)
      : (function (t, e) {
          if (ln(e)) {
            var n = 0 | un(e.length);
            return 0 === (t = en(t, n)).length || e.copy(t, 0, 0, n), t;
          }
          if (e) {
            if (('undefined' != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer) || 'length' in e)
              return 'number' != typeof e.length || (r = e.length) != r ? en(t, 0) : sn(t, e);
            if ('Buffer' === e.type && Ke(e.data)) return sn(t, e.data);
          }
          var r;
          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
        })(t, e);
  }
  function on(t) {
    if ('number' != typeof t) throw new TypeError('"size" argument must be a number');
    if (t < 0) throw new RangeError('"size" argument must not be negative');
  }
  function an(t, e) {
    if ((on(e), (t = en(t, e < 0 ? 0 : 0 | un(e))), !nn.TYPED_ARRAY_SUPPORT)) for (var n = 0; n < e; ++n) t[n] = 0;
    return t;
  }
  function sn(t, e) {
    var n = e.length < 0 ? 0 : 0 | un(e.length);
    t = en(t, n);
    for (var r = 0; r < n; r += 1) t[r] = 255 & e[r];
    return t;
  }
  function un(t) {
    if (t >= tn())
      throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' + tn().toString(16) + ' bytes');
    return 0 | t;
  }
  function ln(t) {
    return !(null == t || !t._isBuffer);
  }
  function cn(t, e) {
    if (ln(t)) return t.length;
    if (
      'undefined' != typeof ArrayBuffer &&
      'function' == typeof ArrayBuffer.isView &&
      (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
    )
      return t.byteLength;
    'string' != typeof t && (t = '' + t);
    var n = t.length;
    if (0 === n) return 0;
    for (var r = !1; ; )
      switch (e) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return n;
        case 'utf8':
        case 'utf-8':
        case void 0:
          return jn(t).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 2 * n;
        case 'hex':
          return n >>> 1;
        case 'base64':
          return Fn(t).length;
        default:
          if (r) return jn(t).length;
          (e = ('' + e).toLowerCase()), (r = !0);
      }
  }
  function hn(t, e, n) {
    var r = !1;
    if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return '';
    if (((void 0 === n || n > this.length) && (n = this.length), n <= 0)) return '';
    if ((n >>>= 0) <= (e >>>= 0)) return '';
    for (t || (t = 'utf8'); ; )
      switch (t) {
        case 'hex':
          return In(this, e, n);
        case 'utf8':
        case 'utf-8':
          return En(this, e, n);
        case 'ascii':
          return kn(this, e, n);
        case 'latin1':
        case 'binary':
          return Sn(this, e, n);
        case 'base64':
          return xn(this, e, n);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return Pn(this, e, n);
        default:
          if (r) throw new TypeError('Unknown encoding: ' + t);
          (t = (t + '').toLowerCase()), (r = !0);
      }
  }
  function fn(t, e, n) {
    var r = t[e];
    (t[e] = t[n]), (t[n] = r);
  }
  function pn(t, e, n, r, i) {
    if (0 === t.length) return -1;
    if (
      ('string' == typeof n
        ? ((r = n), (n = 0))
        : n > 2147483647
        ? (n = 2147483647)
        : n < -2147483648 && (n = -2147483648),
      (n = +n),
      isNaN(n) && (n = i ? 0 : t.length - 1),
      n < 0 && (n = t.length + n),
      n >= t.length)
    ) {
      if (i) return -1;
      n = t.length - 1;
    } else if (n < 0) {
      if (!i) return -1;
      n = 0;
    }
    if (('string' == typeof e && (e = nn.from(e, r)), ln(e))) return 0 === e.length ? -1 : gn(t, e, n, r, i);
    if ('number' == typeof e)
      return (
        (e &= 255),
        nn.TYPED_ARRAY_SUPPORT && 'function' == typeof Uint8Array.prototype.indexOf
          ? i
            ? Uint8Array.prototype.indexOf.call(t, e, n)
            : Uint8Array.prototype.lastIndexOf.call(t, e, n)
          : gn(t, [e], n, r, i)
      );
    throw new TypeError('val must be string, number or Buffer');
  }
  function gn(t, e, n, r, i) {
    var o,
      a = 1,
      s = t.length,
      u = e.length;
    if (
      void 0 !== r &&
      ('ucs2' === (r = String(r).toLowerCase()) || 'ucs-2' === r || 'utf16le' === r || 'utf-16le' === r)
    ) {
      if (t.length < 2 || e.length < 2) return -1;
      (a = 2), (s /= 2), (u /= 2), (n /= 2);
    }
    function l(t, e) {
      return 1 === a ? t[e] : t.readUInt16BE(e * a);
    }
    if (i) {
      var c = -1;
      for (o = n; o < s; o++)
        if (l(t, o) === l(e, -1 === c ? 0 : o - c)) {
          if ((-1 === c && (c = o), o - c + 1 === u)) return c * a;
        } else -1 !== c && (o -= o - c), (c = -1);
    } else
      for (n + u > s && (n = s - u), o = n; o >= 0; o--) {
        for (var h = !0, f = 0; f < u; f++)
          if (l(t, o + f) !== l(e, f)) {
            h = !1;
            break;
          }
        if (h) return o;
      }
    return -1;
  }
  function yn(t, e, n, r) {
    n = Number(n) || 0;
    var i = t.length - n;
    r ? (r = Number(r)) > i && (r = i) : (r = i);
    var o = e.length;
    if (o % 2 != 0) throw new TypeError('Invalid hex string');
    r > o / 2 && (r = o / 2);
    for (var a = 0; a < r; ++a) {
      var s = parseInt(e.substr(2 * a, 2), 16);
      if (isNaN(s)) return a;
      t[n + a] = s;
    }
    return a;
  }
  function vn(t, e, n, r) {
    return Bn(jn(e, t.length - n), t, n, r);
  }
  function dn(t, e, n, r) {
    return Bn(
      (function (t) {
        for (var e = [], n = 0; n < t.length; ++n) e.push(255 & t.charCodeAt(n));
        return e;
      })(e),
      t,
      n,
      r,
    );
  }
  function mn(t, e, n, r) {
    return dn(t, e, n, r);
  }
  function _n(t, e, n, r) {
    return Bn(Fn(e), t, n, r);
  }
  function bn(t, e, n, r) {
    return Bn(
      (function (t, e) {
        for (var n, r, i, o = [], a = 0; a < t.length && !((e -= 2) < 0); ++a)
          (r = (n = t.charCodeAt(a)) >> 8), (i = n % 256), o.push(i), o.push(r);
        return o;
      })(e, t.length - n),
      t,
      n,
      r,
    );
  }
  function xn(t, e, n) {
    return 0 === e && n === t.length ? Ze(t) : Ze(t.slice(e, n));
  }
  function En(t, e, n) {
    n = Math.min(t.length, n);
    for (var r = [], i = e; i < n; ) {
      var o,
        a,
        s,
        u,
        l = t[i],
        c = null,
        h = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
      if (i + h <= n)
        switch (h) {
          case 1:
            l < 128 && (c = l);
            break;
          case 2:
            128 == (192 & (o = t[i + 1])) && (u = ((31 & l) << 6) | (63 & o)) > 127 && (c = u);
            break;
          case 3:
            (o = t[i + 1]),
              (a = t[i + 2]),
              128 == (192 & o) &&
                128 == (192 & a) &&
                (u = ((15 & l) << 12) | ((63 & o) << 6) | (63 & a)) > 2047 &&
                (u < 55296 || u > 57343) &&
                (c = u);
            break;
          case 4:
            (o = t[i + 1]),
              (a = t[i + 2]),
              (s = t[i + 3]),
              128 == (192 & o) &&
                128 == (192 & a) &&
                128 == (192 & s) &&
                (u = ((15 & l) << 18) | ((63 & o) << 12) | ((63 & a) << 6) | (63 & s)) > 65535 &&
                u < 1114112 &&
                (c = u);
        }
      null === c
        ? ((c = 65533), (h = 1))
        : c > 65535 && ((c -= 65536), r.push(((c >>> 10) & 1023) | 55296), (c = 56320 | (1023 & c))),
        r.push(c),
        (i += h);
    }
    return (function (t) {
      var e = t.length;
      if (e <= wn) return String.fromCharCode.apply(String, t);
      var n = '',
        r = 0;
      for (; r < e; ) n += String.fromCharCode.apply(String, t.slice(r, (r += wn)));
      return n;
    })(r);
  }
  (nn.TYPED_ARRAY_SUPPORT = void 0 === Ge.TYPED_ARRAY_SUPPORT || Ge.TYPED_ARRAY_SUPPORT),
    tn(),
    (nn.poolSize = 8192),
    (nn._augment = function (t) {
      return (t.__proto__ = nn.prototype), t;
    }),
    (nn.from = function (t, e, n) {
      return rn(null, t, e, n);
    }),
    nn.TYPED_ARRAY_SUPPORT &&
      ((nn.prototype.__proto__ = Uint8Array.prototype),
      (nn.__proto__ = Uint8Array),
      'undefined' != typeof Symbol && Symbol.species && nn[Symbol.species]),
    (nn.alloc = function (t, e, n) {
      return (function (t, e, n, r) {
        return (
          on(e),
          e <= 0 ? en(t, e) : void 0 !== n ? ('string' == typeof r ? en(t, e).fill(n, r) : en(t, e).fill(n)) : en(t, e)
        );
      })(null, t, e, n);
    }),
    (nn.allocUnsafe = function (t) {
      return an(null, t);
    }),
    (nn.allocUnsafeSlow = function (t) {
      return an(null, t);
    }),
    (nn.isBuffer = function (t) {
      return (
        null != t &&
        (!!t._isBuffer ||
          qn(t) ||
          (function (t) {
            return 'function' == typeof t.readFloatLE && 'function' == typeof t.slice && qn(t.slice(0, 0));
          })(t))
      );
    }),
    (nn.compare = function (t, e) {
      if (!ln(t) || !ln(e)) throw new TypeError('Arguments must be Buffers');
      if (t === e) return 0;
      for (var n = t.length, r = e.length, i = 0, o = Math.min(n, r); i < o; ++i)
        if (t[i] !== e[i]) {
          (n = t[i]), (r = e[i]);
          break;
        }
      return n < r ? -1 : r < n ? 1 : 0;
    }),
    (nn.isEncoding = function (t) {
      switch (String(t).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return !0;
        default:
          return !1;
      }
    }),
    (nn.concat = function (t, e) {
      if (!Ke(t)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t.length) return nn.alloc(0);
      var n;
      if (void 0 === e) for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
      var r = nn.allocUnsafe(e),
        i = 0;
      for (n = 0; n < t.length; ++n) {
        var o = t[n];
        if (!ln(o)) throw new TypeError('"list" argument must be an Array of Buffers');
        o.copy(r, i), (i += o.length);
      }
      return r;
    }),
    (nn.byteLength = cn),
    (nn.prototype._isBuffer = !0),
    (nn.prototype.swap16 = function () {
      var t = this.length;
      if (t % 2 != 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
      for (var e = 0; e < t; e += 2) fn(this, e, e + 1);
      return this;
    }),
    (nn.prototype.swap32 = function () {
      var t = this.length;
      if (t % 4 != 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
      for (var e = 0; e < t; e += 4) fn(this, e, e + 3), fn(this, e + 1, e + 2);
      return this;
    }),
    (nn.prototype.swap64 = function () {
      var t = this.length;
      if (t % 8 != 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
      for (var e = 0; e < t; e += 8)
        fn(this, e, e + 7), fn(this, e + 1, e + 6), fn(this, e + 2, e + 5), fn(this, e + 3, e + 4);
      return this;
    }),
    (nn.prototype.toString = function () {
      var t = 0 | this.length;
      return 0 === t ? '' : 0 === arguments.length ? En(this, 0, t) : hn.apply(this, arguments);
    }),
    (nn.prototype.equals = function (t) {
      if (!ln(t)) throw new TypeError('Argument must be a Buffer');
      return this === t || 0 === nn.compare(this, t);
    }),
    (nn.prototype.inspect = function () {
      var t = '';
      return (
        this.length > 0 &&
          ((t = this.toString('hex', 0, 50).match(/.{2}/g).join(' ')), this.length > 50 && (t += ' ... ')),
        '<Buffer ' + t + '>'
      );
    }),
    (nn.prototype.compare = function (t, e, n, r, i) {
      if (!ln(t)) throw new TypeError('Argument must be a Buffer');
      if (
        (void 0 === e && (e = 0),
        void 0 === n && (n = t ? t.length : 0),
        void 0 === r && (r = 0),
        void 0 === i && (i = this.length),
        e < 0 || n > t.length || r < 0 || i > this.length)
      )
        throw new RangeError('out of range index');
      if (r >= i && e >= n) return 0;
      if (r >= i) return -1;
      if (e >= n) return 1;
      if (this === t) return 0;
      for (
        var o = (i >>>= 0) - (r >>>= 0),
          a = (n >>>= 0) - (e >>>= 0),
          s = Math.min(o, a),
          u = this.slice(r, i),
          l = t.slice(e, n),
          c = 0;
        c < s;
        ++c
      )
        if (u[c] !== l[c]) {
          (o = u[c]), (a = l[c]);
          break;
        }
      return o < a ? -1 : a < o ? 1 : 0;
    }),
    (nn.prototype.includes = function (t, e, n) {
      return -1 !== this.indexOf(t, e, n);
    }),
    (nn.prototype.indexOf = function (t, e, n) {
      return pn(this, t, e, n, !0);
    }),
    (nn.prototype.lastIndexOf = function (t, e, n) {
      return pn(this, t, e, n, !1);
    }),
    (nn.prototype.write = function (t, e, n, r) {
      if (void 0 === e) (r = 'utf8'), (n = this.length), (e = 0);
      else if (void 0 === n && 'string' == typeof e) (r = e), (n = this.length), (e = 0);
      else {
        if (!isFinite(e)) throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
        (e |= 0), isFinite(n) ? ((n |= 0), void 0 === r && (r = 'utf8')) : ((r = n), (n = void 0));
      }
      var i = this.length - e;
      if (((void 0 === n || n > i) && (n = i), (t.length > 0 && (n < 0 || e < 0)) || e > this.length))
        throw new RangeError('Attempt to write outside buffer bounds');
      r || (r = 'utf8');
      for (var o = !1; ; )
        switch (r) {
          case 'hex':
            return yn(this, t, e, n);
          case 'utf8':
          case 'utf-8':
            return vn(this, t, e, n);
          case 'ascii':
            return dn(this, t, e, n);
          case 'latin1':
          case 'binary':
            return mn(this, t, e, n);
          case 'base64':
            return _n(this, t, e, n);
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return bn(this, t, e, n);
          default:
            if (o) throw new TypeError('Unknown encoding: ' + r);
            (r = ('' + r).toLowerCase()), (o = !0);
        }
    }),
    (nn.prototype.toJSON = function () {
      return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) };
    });
  var wn = 4096;
  function kn(t, e, n) {
    var r = '';
    n = Math.min(t.length, n);
    for (var i = e; i < n; ++i) r += String.fromCharCode(127 & t[i]);
    return r;
  }
  function Sn(t, e, n) {
    var r = '';
    n = Math.min(t.length, n);
    for (var i = e; i < n; ++i) r += String.fromCharCode(t[i]);
    return r;
  }
  function In(t, e, n) {
    var r = t.length;
    (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
    for (var i = '', o = e; o < n; ++o) i += Dn(t[o]);
    return i;
  }
  function Pn(t, e, n) {
    for (var r = t.slice(e, n), i = '', o = 0; o < r.length; o += 2) i += String.fromCharCode(r[o] + 256 * r[o + 1]);
    return i;
  }
  function Nn(t, e, n) {
    if (t % 1 != 0 || t < 0) throw new RangeError('offset is not uint');
    if (t + e > n) throw new RangeError('Trying to access beyond buffer length');
  }
  function Mn(t, e, n, r, i, o) {
    if (!ln(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < o) throw new RangeError('"value" argument is out of bounds');
    if (n + r > t.length) throw new RangeError('Index out of range');
  }
  function On(t, e, n, r) {
    e < 0 && (e = 65535 + e + 1);
    for (var i = 0, o = Math.min(t.length - n, 2); i < o; ++i)
      t[n + i] = (e & (255 << (8 * (r ? i : 1 - i)))) >>> (8 * (r ? i : 1 - i));
  }
  function Ln(t, e, n, r) {
    e < 0 && (e = 4294967295 + e + 1);
    for (var i = 0, o = Math.min(t.length - n, 4); i < o; ++i) t[n + i] = (e >>> (8 * (r ? i : 3 - i))) & 255;
  }
  function Rn(t, e, n, r, i, o) {
    if (n + r > t.length) throw new RangeError('Index out of range');
    if (n < 0) throw new RangeError('Index out of range');
  }
  function Cn(t, e, n, r, i) {
    return i || Rn(t, 0, n, 4), $e(t, e, n, r, 23, 4), n + 4;
  }
  function Tn(t, e, n, r, i) {
    return i || Rn(t, 0, n, 8), $e(t, e, n, r, 52, 8), n + 8;
  }
  (nn.prototype.slice = function (t, e) {
    var n,
      r = this.length;
    if (
      ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
      (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
      e < t && (e = t),
      nn.TYPED_ARRAY_SUPPORT)
    )
      (n = this.subarray(t, e)).__proto__ = nn.prototype;
    else {
      var i = e - t;
      n = new nn(i, void 0);
      for (var o = 0; o < i; ++o) n[o] = this[o + t];
    }
    return n;
  }),
    (nn.prototype.readUIntLE = function (t, e, n) {
      (t |= 0), (e |= 0), n || Nn(t, e, this.length);
      for (var r = this[t], i = 1, o = 0; ++o < e && (i *= 256); ) r += this[t + o] * i;
      return r;
    }),
    (nn.prototype.readUIntBE = function (t, e, n) {
      (t |= 0), (e |= 0), n || Nn(t, e, this.length);
      for (var r = this[t + --e], i = 1; e > 0 && (i *= 256); ) r += this[t + --e] * i;
      return r;
    }),
    (nn.prototype.readUInt8 = function (t, e) {
      return e || Nn(t, 1, this.length), this[t];
    }),
    (nn.prototype.readUInt16LE = function (t, e) {
      return e || Nn(t, 2, this.length), this[t] | (this[t + 1] << 8);
    }),
    (nn.prototype.readUInt16BE = function (t, e) {
      return e || Nn(t, 2, this.length), (this[t] << 8) | this[t + 1];
    }),
    (nn.prototype.readUInt32LE = function (t, e) {
      return e || Nn(t, 4, this.length), (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) + 16777216 * this[t + 3];
    }),
    (nn.prototype.readUInt32BE = function (t, e) {
      return e || Nn(t, 4, this.length), 16777216 * this[t] + ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3]);
    }),
    (nn.prototype.readIntLE = function (t, e, n) {
      (t |= 0), (e |= 0), n || Nn(t, e, this.length);
      for (var r = this[t], i = 1, o = 0; ++o < e && (i *= 256); ) r += this[t + o] * i;
      return r >= (i *= 128) && (r -= Math.pow(2, 8 * e)), r;
    }),
    (nn.prototype.readIntBE = function (t, e, n) {
      (t |= 0), (e |= 0), n || Nn(t, e, this.length);
      for (var r = e, i = 1, o = this[t + --r]; r > 0 && (i *= 256); ) o += this[t + --r] * i;
      return o >= (i *= 128) && (o -= Math.pow(2, 8 * e)), o;
    }),
    (nn.prototype.readInt8 = function (t, e) {
      return e || Nn(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
    }),
    (nn.prototype.readInt16LE = function (t, e) {
      e || Nn(t, 2, this.length);
      var n = this[t] | (this[t + 1] << 8);
      return 32768 & n ? 4294901760 | n : n;
    }),
    (nn.prototype.readInt16BE = function (t, e) {
      e || Nn(t, 2, this.length);
      var n = this[t + 1] | (this[t] << 8);
      return 32768 & n ? 4294901760 | n : n;
    }),
    (nn.prototype.readInt32LE = function (t, e) {
      return e || Nn(t, 4, this.length), this[t] | (this[t + 1] << 8) | (this[t + 2] << 16) | (this[t + 3] << 24);
    }),
    (nn.prototype.readInt32BE = function (t, e) {
      return e || Nn(t, 4, this.length), (this[t] << 24) | (this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3];
    }),
    (nn.prototype.readFloatLE = function (t, e) {
      return e || Nn(t, 4, this.length), Je(this, t, !0, 23, 4);
    }),
    (nn.prototype.readFloatBE = function (t, e) {
      return e || Nn(t, 4, this.length), Je(this, t, !1, 23, 4);
    }),
    (nn.prototype.readDoubleLE = function (t, e) {
      return e || Nn(t, 8, this.length), Je(this, t, !0, 52, 8);
    }),
    (nn.prototype.readDoubleBE = function (t, e) {
      return e || Nn(t, 8, this.length), Je(this, t, !1, 52, 8);
    }),
    (nn.prototype.writeUIntLE = function (t, e, n, r) {
      ((t = +t), (e |= 0), (n |= 0), r) || Mn(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
      var i = 1,
        o = 0;
      for (this[e] = 255 & t; ++o < n && (i *= 256); ) this[e + o] = (t / i) & 255;
      return e + n;
    }),
    (nn.prototype.writeUIntBE = function (t, e, n, r) {
      ((t = +t), (e |= 0), (n |= 0), r) || Mn(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
      var i = n - 1,
        o = 1;
      for (this[e + i] = 255 & t; --i >= 0 && (o *= 256); ) this[e + i] = (t / o) & 255;
      return e + n;
    }),
    (nn.prototype.writeUInt8 = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 1, 255, 0),
        nn.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
        (this[e] = 255 & t),
        e + 1
      );
    }),
    (nn.prototype.writeUInt16LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 2, 65535, 0),
        nn.TYPED_ARRAY_SUPPORT ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8)) : On(this, t, e, !0),
        e + 2
      );
    }),
    (nn.prototype.writeUInt16BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 2, 65535, 0),
        nn.TYPED_ARRAY_SUPPORT ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t)) : On(this, t, e, !1),
        e + 2
      );
    }),
    (nn.prototype.writeUInt32LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 4, 4294967295, 0),
        nn.TYPED_ARRAY_SUPPORT
          ? ((this[e + 3] = t >>> 24), (this[e + 2] = t >>> 16), (this[e + 1] = t >>> 8), (this[e] = 255 & t))
          : Ln(this, t, e, !0),
        e + 4
      );
    }),
    (nn.prototype.writeUInt32BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 4, 4294967295, 0),
        nn.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 24), (this[e + 1] = t >>> 16), (this[e + 2] = t >>> 8), (this[e + 3] = 255 & t))
          : Ln(this, t, e, !1),
        e + 4
      );
    }),
    (nn.prototype.writeIntLE = function (t, e, n, r) {
      if (((t = +t), (e |= 0), !r)) {
        var i = Math.pow(2, 8 * n - 1);
        Mn(this, t, e, n, i - 1, -i);
      }
      var o = 0,
        a = 1,
        s = 0;
      for (this[e] = 255 & t; ++o < n && (a *= 256); )
        t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1), (this[e + o] = (((t / a) >> 0) - s) & 255);
      return e + n;
    }),
    (nn.prototype.writeIntBE = function (t, e, n, r) {
      if (((t = +t), (e |= 0), !r)) {
        var i = Math.pow(2, 8 * n - 1);
        Mn(this, t, e, n, i - 1, -i);
      }
      var o = n - 1,
        a = 1,
        s = 0;
      for (this[e + o] = 255 & t; --o >= 0 && (a *= 256); )
        t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1), (this[e + o] = (((t / a) >> 0) - s) & 255);
      return e + n;
    }),
    (nn.prototype.writeInt8 = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 1, 127, -128),
        nn.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
        t < 0 && (t = 255 + t + 1),
        (this[e] = 255 & t),
        e + 1
      );
    }),
    (nn.prototype.writeInt16LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 2, 32767, -32768),
        nn.TYPED_ARRAY_SUPPORT ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8)) : On(this, t, e, !0),
        e + 2
      );
    }),
    (nn.prototype.writeInt16BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 2, 32767, -32768),
        nn.TYPED_ARRAY_SUPPORT ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t)) : On(this, t, e, !1),
        e + 2
      );
    }),
    (nn.prototype.writeInt32LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 4, 2147483647, -2147483648),
        nn.TYPED_ARRAY_SUPPORT
          ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8), (this[e + 2] = t >>> 16), (this[e + 3] = t >>> 24))
          : Ln(this, t, e, !0),
        e + 4
      );
    }),
    (nn.prototype.writeInt32BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || Mn(this, t, e, 4, 2147483647, -2147483648),
        t < 0 && (t = 4294967295 + t + 1),
        nn.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 24), (this[e + 1] = t >>> 16), (this[e + 2] = t >>> 8), (this[e + 3] = 255 & t))
          : Ln(this, t, e, !1),
        e + 4
      );
    }),
    (nn.prototype.writeFloatLE = function (t, e, n) {
      return Cn(this, t, e, !0, n);
    }),
    (nn.prototype.writeFloatBE = function (t, e, n) {
      return Cn(this, t, e, !1, n);
    }),
    (nn.prototype.writeDoubleLE = function (t, e, n) {
      return Tn(this, t, e, !0, n);
    }),
    (nn.prototype.writeDoubleBE = function (t, e, n) {
      return Tn(this, t, e, !1, n);
    }),
    (nn.prototype.copy = function (t, e, n, r) {
      if (
        (n || (n = 0),
        r || 0 === r || (r = this.length),
        e >= t.length && (e = t.length),
        e || (e = 0),
        r > 0 && r < n && (r = n),
        r === n)
      )
        return 0;
      if (0 === t.length || 0 === this.length) return 0;
      if (e < 0) throw new RangeError('targetStart out of bounds');
      if (n < 0 || n >= this.length) throw new RangeError('sourceStart out of bounds');
      if (r < 0) throw new RangeError('sourceEnd out of bounds');
      r > this.length && (r = this.length), t.length - e < r - n && (r = t.length - e + n);
      var i,
        o = r - n;
      if (this === t && n < e && e < r) for (i = o - 1; i >= 0; --i) t[i + e] = this[i + n];
      else if (o < 1e3 || !nn.TYPED_ARRAY_SUPPORT) for (i = 0; i < o; ++i) t[i + e] = this[i + n];
      else Uint8Array.prototype.set.call(t, this.subarray(n, n + o), e);
      return o;
    }),
    (nn.prototype.fill = function (t, e, n, r) {
      if ('string' == typeof t) {
        if (
          ('string' == typeof e
            ? ((r = e), (e = 0), (n = this.length))
            : 'string' == typeof n && ((r = n), (n = this.length)),
          1 === t.length)
        ) {
          var i = t.charCodeAt(0);
          i < 256 && (t = i);
        }
        if (void 0 !== r && 'string' != typeof r) throw new TypeError('encoding must be a string');
        if ('string' == typeof r && !nn.isEncoding(r)) throw new TypeError('Unknown encoding: ' + r);
      } else 'number' == typeof t && (t &= 255);
      if (e < 0 || this.length < e || this.length < n) throw new RangeError('Out of range index');
      if (n <= e) return this;
      var o;
      if (((e >>>= 0), (n = void 0 === n ? this.length : n >>> 0), t || (t = 0), 'number' == typeof t))
        for (o = e; o < n; ++o) this[o] = t;
      else {
        var a = ln(t) ? t : jn(new nn(t, r).toString()),
          s = a.length;
        for (o = 0; o < n - e; ++o) this[o + e] = a[o % s];
      }
      return this;
    });
  var An = /[^+\/0-9A-Za-z-_]/g;
  function Dn(t) {
    return t < 16 ? '0' + t.toString(16) : t.toString(16);
  }
  function jn(t, e) {
    var n;
    e = e || 1 / 0;
    for (var r = t.length, i = null, o = [], a = 0; a < r; ++a) {
      if ((n = t.charCodeAt(a)) > 55295 && n < 57344) {
        if (!i) {
          if (n > 56319) {
            (e -= 3) > -1 && o.push(239, 191, 189);
            continue;
          }
          if (a + 1 === r) {
            (e -= 3) > -1 && o.push(239, 191, 189);
            continue;
          }
          i = n;
          continue;
        }
        if (n < 56320) {
          (e -= 3) > -1 && o.push(239, 191, 189), (i = n);
          continue;
        }
        n = 65536 + (((i - 55296) << 10) | (n - 56320));
      } else i && (e -= 3) > -1 && o.push(239, 191, 189);
      if (((i = null), n < 128)) {
        if ((e -= 1) < 0) break;
        o.push(n);
      } else if (n < 2048) {
        if ((e -= 2) < 0) break;
        o.push((n >> 6) | 192, (63 & n) | 128);
      } else if (n < 65536) {
        if ((e -= 3) < 0) break;
        o.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
      } else {
        if (!(n < 1114112)) throw new Error('Invalid code point');
        if ((e -= 4) < 0) break;
        o.push((n >> 18) | 240, ((n >> 12) & 63) | 128, ((n >> 6) & 63) | 128, (63 & n) | 128);
      }
    }
    return o;
  }
  function Fn(t) {
    return (function (t) {
      var e, n, r, i, o, a;
      Xe || We();
      var s = t.length;
      if (s % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
      (o = '=' === t[s - 2] ? 2 : '=' === t[s - 1] ? 1 : 0), (a = new Ue((3 * s) / 4 - o)), (r = o > 0 ? s - 4 : s);
      var u = 0;
      for (e = 0, n = 0; e < r; e += 4, n += 3)
        (i =
          (ze[t.charCodeAt(e)] << 18) |
          (ze[t.charCodeAt(e + 1)] << 12) |
          (ze[t.charCodeAt(e + 2)] << 6) |
          ze[t.charCodeAt(e + 3)]),
          (a[u++] = (i >> 16) & 255),
          (a[u++] = (i >> 8) & 255),
          (a[u++] = 255 & i);
      return (
        2 === o
          ? ((i = (ze[t.charCodeAt(e)] << 2) | (ze[t.charCodeAt(e + 1)] >> 4)), (a[u++] = 255 & i))
          : 1 === o &&
            ((i = (ze[t.charCodeAt(e)] << 10) | (ze[t.charCodeAt(e + 1)] << 4) | (ze[t.charCodeAt(e + 2)] >> 2)),
            (a[u++] = (i >> 8) & 255),
            (a[u++] = 255 & i)),
        a
      );
    })(
      (function (t) {
        if (
          (t = (function (t) {
            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, '');
          })(t).replace(An, '')).length < 2
        )
          return '';
        for (; t.length % 4 != 0; ) t += '=';
        return t;
      })(t),
    );
  }
  function Bn(t, e, n, r) {
    for (var i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i) e[i + n] = t[i];
    return i;
  }
  function qn(t) {
    return !!t.constructor && 'function' == typeof t.constructor.isBuffer && t.constructor.isBuffer(t);
  }
  function Vn() {
    throw new Error('setTimeout has not been defined');
  }
  function Gn() {
    throw new Error('clearTimeout has not been defined');
  }
  var Yn = Vn,
    zn = Gn;
  function Un(t) {
    if (Yn === setTimeout) return setTimeout(t, 0);
    if ((Yn === Vn || !Yn) && setTimeout) return (Yn = setTimeout), setTimeout(t, 0);
    try {
      return Yn(t, 0);
    } catch (e) {
      try {
        return Yn.call(null, t, 0);
      } catch (e) {
        return Yn.call(this, t, 0);
      }
    }
  }
  'function' == typeof Ge.setTimeout && (Yn = setTimeout), 'function' == typeof Ge.clearTimeout && (zn = clearTimeout);
  var Xn,
    Wn = [],
    Hn = !1,
    Zn = -1;
  function Jn() {
    Hn && Xn && ((Hn = !1), Xn.length ? (Wn = Xn.concat(Wn)) : (Zn = -1), Wn.length && $n());
  }
  function $n() {
    if (!Hn) {
      var t = Un(Jn);
      Hn = !0;
      for (var e = Wn.length; e; ) {
        for (Xn = Wn, Wn = []; ++Zn < e; ) Xn && Xn[Zn].run();
        (Zn = -1), (e = Wn.length);
      }
      (Xn = null),
        (Hn = !1),
        (function (t) {
          if (zn === clearTimeout) return clearTimeout(t);
          if ((zn === Gn || !zn) && clearTimeout) return (zn = clearTimeout), clearTimeout(t);
          try {
            return zn(t);
          } catch (e) {
            try {
              return zn.call(null, t);
            } catch (e) {
              return zn.call(this, t);
            }
          }
        })(t);
    }
  }
  function Qn(t, e) {
    (this.fun = t), (this.array = e);
  }
  Qn.prototype.run = function () {
    this.fun.apply(null, this.array);
  };
  function Kn() {}
  var tr = Kn,
    er = Kn,
    nr = Kn,
    rr = Kn,
    ir = Kn,
    or = Kn,
    ar = Kn;
  var sr = Ge.performance || {},
    ur =
      sr.now ||
      sr.mozNow ||
      sr.msNow ||
      sr.oNow ||
      sr.webkitNow ||
      function () {
        return new Date().getTime();
      };
  var lr = new Date();
  var cr = {
      nextTick: function (t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        Wn.push(new Qn(t, e)), 1 !== Wn.length || Hn || Un($n);
      },
      title: 'browser',
      browser: !0,
      env: {},
      argv: [],
      version: '',
      versions: {},
      on: tr,
      addListener: er,
      once: nr,
      off: rr,
      removeListener: ir,
      removeAllListeners: or,
      emit: ar,
      binding: function (t) {
        throw new Error('process.binding is not supported');
      },
      cwd: function () {
        return '/';
      },
      chdir: function (t) {
        throw new Error('process.chdir is not supported');
      },
      umask: function () {
        return 0;
      },
      hrtime: function (t) {
        var e = 0.001 * ur.call(sr),
          n = Math.floor(e),
          r = Math.floor((e % 1) * 1e9);
        return t && ((n -= t[0]), (r -= t[1]) < 0 && (n--, (r += 1e9))), [n, r];
      },
      platform: 'browser',
      release: {},
      config: {},
      uptime: function () {
        return (new Date() - lr) / 1e3;
      },
    },
    hr =
      'function' == typeof Object.create
        ? function (t, e) {
            (t.super_ = e),
              (t.prototype = Object.create(e.prototype, {
                constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 },
              }));
          }
        : function (t, e) {
            t.super_ = e;
            var n = function () {};
            (n.prototype = e.prototype), (t.prototype = new n()), (t.prototype.constructor = t);
          },
    fr =
      Object.getOwnPropertyDescriptors ||
      function (t) {
        for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++)
          n[e[r]] = Object.getOwnPropertyDescriptor(t, e[r]);
        return n;
      },
    pr = /%[sdj%]/g;
  function gr(t) {
    if (!Or(t)) {
      for (var e = [], n = 0; n < arguments.length; n++) e.push(_r(arguments[n]));
      return e.join(' ');
    }
    n = 1;
    for (
      var r = arguments,
        i = r.length,
        o = String(t).replace(pr, function (t) {
          if ('%%' === t) return '%';
          if (n >= i) return t;
          switch (t) {
            case '%s':
              return String(r[n++]);
            case '%d':
              return Number(r[n++]);
            case '%j':
              try {
                return JSON.stringify(r[n++]);
              } catch (t) {
                return '[Circular]';
              }
            default:
              return t;
          }
        }),
        a = r[n];
      n < i;
      a = r[++n]
    )
      Pr(a) || !Tr(a) ? (o += ' ' + a) : (o += ' ' + _r(a));
    return o;
  }
  function yr(t, e) {
    if (Rr(Ge.process))
      return function () {
        return yr(t, e).apply(this, arguments);
      };
    if (!0 === cr.noDeprecation) return t;
    var n = !1;
    return function () {
      if (!n) {
        if (cr.throwDeprecation) throw new Error(e);
        cr.traceDeprecation ? console.trace(e) : console.error(e), (n = !0);
      }
      return t.apply(this, arguments);
    };
  }
  var vr,
    dr = {};
  function mr(t) {
    if ((Rr(vr) && (vr = cr.env.NODE_DEBUG || ''), (t = t.toUpperCase()), !dr[t]))
      if (new RegExp('\\b' + t + '\\b', 'i').test(vr)) {
        dr[t] = function () {
          var e = gr.apply(null, arguments);
          console.error('%s %d: %s', t, 0, e);
        };
      } else dr[t] = function () {};
    return dr[t];
  }
  function _r(t, e) {
    var n = { seen: [], stylize: xr };
    return (
      arguments.length >= 3 && (n.depth = arguments[2]),
      arguments.length >= 4 && (n.colors = arguments[3]),
      Ir(e) ? (n.showHidden = e) : e && zr(n, e),
      Rr(n.showHidden) && (n.showHidden = !1),
      Rr(n.depth) && (n.depth = 2),
      Rr(n.colors) && (n.colors = !1),
      Rr(n.customInspect) && (n.customInspect = !0),
      n.colors && (n.stylize = br),
      Er(n, t, n.depth)
    );
  }
  function br(t, e) {
    var n = _r.styles[e];
    return n ? '[' + _r.colors[n][0] + 'm' + t + '[' + _r.colors[n][1] + 'm' : t;
  }
  function xr(t, e) {
    return t;
  }
  function Er(t, e, n) {
    if (
      t.customInspect &&
      e &&
      jr(e.inspect) &&
      e.inspect !== _r &&
      (!e.constructor || e.constructor.prototype !== e)
    ) {
      var r = e.inspect(n, t);
      return Or(r) || (r = Er(t, r, n)), r;
    }
    var i = (function (t, e) {
      if (Rr(e)) return t.stylize('undefined', 'undefined');
      if (Or(e)) {
        var n = "'" + JSON.stringify(e).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return t.stylize(n, 'string');
      }
      if (Mr(e)) return t.stylize('' + e, 'number');
      if (Ir(e)) return t.stylize('' + e, 'boolean');
      if (Pr(e)) return t.stylize('null', 'null');
    })(t, e);
    if (i) return i;
    var o = Object.keys(e),
      a = (function (t) {
        var e = {};
        return (
          t.forEach(function (t, n) {
            e[t] = !0;
          }),
          e
        );
      })(o);
    if (
      (t.showHidden && (o = Object.getOwnPropertyNames(e)),
      Dr(e) && (o.indexOf('message') >= 0 || o.indexOf('description') >= 0))
    )
      return wr(e);
    if (0 === o.length) {
      if (jr(e)) {
        var s = e.name ? ': ' + e.name : '';
        return t.stylize('[Function' + s + ']', 'special');
      }
      if (Cr(e)) return t.stylize(RegExp.prototype.toString.call(e), 'regexp');
      if (Ar(e)) return t.stylize(Date.prototype.toString.call(e), 'date');
      if (Dr(e)) return wr(e);
    }
    var u,
      l = '',
      c = !1,
      h = ['{', '}'];
    (Sr(e) && ((c = !0), (h = ['[', ']'])), jr(e)) && (l = ' [Function' + (e.name ? ': ' + e.name : '') + ']');
    return (
      Cr(e) && (l = ' ' + RegExp.prototype.toString.call(e)),
      Ar(e) && (l = ' ' + Date.prototype.toUTCString.call(e)),
      Dr(e) && (l = ' ' + wr(e)),
      0 !== o.length || (c && 0 != e.length)
        ? n < 0
          ? Cr(e)
            ? t.stylize(RegExp.prototype.toString.call(e), 'regexp')
            : t.stylize('[Object]', 'special')
          : (t.seen.push(e),
            (u = c
              ? (function (t, e, n, r, i) {
                  for (var o = [], a = 0, s = e.length; a < s; ++a)
                    Ur(e, String(a)) ? o.push(kr(t, e, n, r, String(a), !0)) : o.push('');
                  return (
                    i.forEach(function (i) {
                      i.match(/^\d+$/) || o.push(kr(t, e, n, r, i, !0));
                    }),
                    o
                  );
                })(t, e, n, a, o)
              : o.map(function (r) {
                  return kr(t, e, n, a, r, c);
                })),
            t.seen.pop(),
            (function (t, e, n) {
              var r = t.reduce(function (t, e) {
                return e.indexOf('\n'), t + e.replace(/\u001b\[\d\d?m/g, '').length + 1;
              }, 0);
              if (r > 60) return n[0] + ('' === e ? '' : e + '\n ') + ' ' + t.join(',\n  ') + ' ' + n[1];
              return n[0] + e + ' ' + t.join(', ') + ' ' + n[1];
            })(u, l, h))
        : h[0] + l + h[1]
    );
  }
  function wr(t) {
    return '[' + Error.prototype.toString.call(t) + ']';
  }
  function kr(t, e, n, r, i, o) {
    var a, s, u;
    if (
      ((u = Object.getOwnPropertyDescriptor(e, i) || { value: e[i] }).get
        ? (s = u.set ? t.stylize('[Getter/Setter]', 'special') : t.stylize('[Getter]', 'special'))
        : u.set && (s = t.stylize('[Setter]', 'special')),
      Ur(r, i) || (a = '[' + i + ']'),
      s ||
        (t.seen.indexOf(u.value) < 0
          ? (s = Pr(n) ? Er(t, u.value, null) : Er(t, u.value, n - 1)).indexOf('\n') > -1 &&
            (s = o
              ? s
                  .split('\n')
                  .map(function (t) {
                    return '  ' + t;
                  })
                  .join('\n')
                  .substr(2)
              : '\n' +
                s
                  .split('\n')
                  .map(function (t) {
                    return '   ' + t;
                  })
                  .join('\n'))
          : (s = t.stylize('[Circular]', 'special'))),
      Rr(a))
    ) {
      if (o && i.match(/^\d+$/)) return s;
      (a = JSON.stringify('' + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
        ? ((a = a.substr(1, a.length - 2)), (a = t.stylize(a, 'name')))
        : ((a = a
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
            .replace(/(^"|"$)/g, "'")),
          (a = t.stylize(a, 'string')));
    }
    return a + ': ' + s;
  }
  function Sr(t) {
    return Array.isArray(t);
  }
  function Ir(t) {
    return 'boolean' == typeof t;
  }
  function Pr(t) {
    return null === t;
  }
  function Nr(t) {
    return null == t;
  }
  function Mr(t) {
    return 'number' == typeof t;
  }
  function Or(t) {
    return 'string' == typeof t;
  }
  function Lr(t) {
    return 'symbol' == typeof t;
  }
  function Rr(t) {
    return void 0 === t;
  }
  function Cr(t) {
    return Tr(t) && '[object RegExp]' === qr(t);
  }
  function Tr(t) {
    return 'object' == typeof t && null !== t;
  }
  function Ar(t) {
    return Tr(t) && '[object Date]' === qr(t);
  }
  function Dr(t) {
    return Tr(t) && ('[object Error]' === qr(t) || t instanceof Error);
  }
  function jr(t) {
    return 'function' == typeof t;
  }
  function Fr(t) {
    return (
      null === t ||
      'boolean' == typeof t ||
      'number' == typeof t ||
      'string' == typeof t ||
      'symbol' == typeof t ||
      void 0 === t
    );
  }
  function Br(t) {
    return nn.isBuffer(t);
  }
  function qr(t) {
    return Object.prototype.toString.call(t);
  }
  function Vr(t) {
    return t < 10 ? '0' + t.toString(10) : t.toString(10);
  }
  (_r.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39],
  }),
    (_r.styles = {
      special: 'cyan',
      number: 'yellow',
      boolean: 'yellow',
      undefined: 'grey',
      null: 'bold',
      string: 'green',
      date: 'magenta',
      regexp: 'red',
    });
  var Gr = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  function Yr() {
    var t, e;
    console.log(
      '%s - %s',
      ((t = new Date()),
      (e = [Vr(t.getHours()), Vr(t.getMinutes()), Vr(t.getSeconds())].join(':')),
      [t.getDate(), Gr[t.getMonth()], e].join(' ')),
      gr.apply(null, arguments),
    );
  }
  function zr(t, e) {
    if (!e || !Tr(e)) return t;
    for (var n = Object.keys(e), r = n.length; r--; ) t[n[r]] = e[n[r]];
    return t;
  }
  function Ur(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  var Xr = 'undefined' != typeof Symbol ? Symbol('util.promisify.custom') : void 0;
  function Wr(t) {
    if ('function' != typeof t) throw new TypeError('The "original" argument must be of type Function');
    if (Xr && t[Xr]) {
      var e;
      if ('function' != typeof (e = t[Xr]))
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(e, Xr, { value: e, enumerable: !1, writable: !1, configurable: !0 }), e;
    }
    function e() {
      for (
        var e,
          n,
          r = new Promise(function (t, r) {
            (e = t), (n = r);
          }),
          i = [],
          o = 0;
        o < arguments.length;
        o++
      )
        i.push(arguments[o]);
      i.push(function (t, r) {
        t ? n(t) : e(r);
      });
      try {
        t.apply(this, i);
      } catch (t) {
        n(t);
      }
      return r;
    }
    return (
      Object.setPrototypeOf(e, Object.getPrototypeOf(t)),
      Xr && Object.defineProperty(e, Xr, { value: e, enumerable: !1, writable: !1, configurable: !0 }),
      Object.defineProperties(e, fr(t))
    );
  }
  function Hr(t, e) {
    if (!t) {
      var n = new Error('Promise was rejected with a falsy value');
      (n.reason = t), (t = n);
    }
    return e(t);
  }
  function Zr(t) {
    if ('function' != typeof t) throw new TypeError('The "original" argument must be of type Function');
    function e() {
      for (var e = [], n = 0; n < arguments.length; n++) e.push(arguments[n]);
      var r = e.pop();
      if ('function' != typeof r) throw new TypeError('The last argument must be of type Function');
      var i = this,
        o = function () {
          return r.apply(i, arguments);
        };
      t.apply(this, e).then(
        function (t) {
          cr.nextTick(o.bind(null, null, t));
        },
        function (t) {
          cr.nextTick(Hr.bind(null, t, o));
        },
      );
    }
    return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), Object.defineProperties(e, fr(t)), e;
  }
  Wr.custom = Xr;
  var Jr = {
      inherits: hr,
      _extend: zr,
      log: Yr,
      isBuffer: Br,
      isPrimitive: Fr,
      isFunction: jr,
      isError: Dr,
      isDate: Ar,
      isObject: Tr,
      isRegExp: Cr,
      isUndefined: Rr,
      isSymbol: Lr,
      isString: Or,
      isNumber: Mr,
      isNullOrUndefined: Nr,
      isNull: Pr,
      isBoolean: Ir,
      isArray: Sr,
      inspect: _r,
      deprecate: yr,
      format: gr,
      debuglog: mr,
      promisify: Wr,
      callbackify: Zr,
    },
    $r = g(
      Object.freeze({
        __proto__: null,
        format: gr,
        deprecate: yr,
        debuglog: mr,
        inspect: _r,
        isArray: Sr,
        isBoolean: Ir,
        isNull: Pr,
        isNullOrUndefined: Nr,
        isNumber: Mr,
        isString: Or,
        isSymbol: Lr,
        isUndefined: Rr,
        isRegExp: Cr,
        isObject: Tr,
        isDate: Ar,
        isError: Dr,
        isFunction: jr,
        isPrimitive: Fr,
        isBuffer: Br,
        log: Yr,
        inherits: hr,
        _extend: zr,
        promisify: Wr,
        callbackify: Zr,
        default: Jr,
      }),
    ).inspect,
    Qr = 'function' == typeof Map && Map.prototype,
    Kr = Object.getOwnPropertyDescriptor && Qr ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null,
    ti = Qr && Kr && 'function' == typeof Kr.get ? Kr.get : null,
    ei = Qr && Map.prototype.forEach,
    ni = 'function' == typeof Set && Set.prototype,
    ri = Object.getOwnPropertyDescriptor && ni ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null,
    ii = ni && ri && 'function' == typeof ri.get ? ri.get : null,
    oi = ni && Set.prototype.forEach,
    ai = 'function' == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,
    si = 'function' == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,
    ui = 'function' == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,
    li = Boolean.prototype.valueOf,
    ci = Object.prototype.toString,
    hi = Function.prototype.toString,
    fi = String.prototype.match,
    pi = String.prototype.slice,
    gi = String.prototype.replace,
    yi = String.prototype.toUpperCase,
    vi = String.prototype.toLowerCase,
    di = RegExp.prototype.test,
    mi = Array.prototype.concat,
    _i = Array.prototype.join,
    bi = Array.prototype.slice,
    xi = Math.floor,
    Ei = 'function' == typeof BigInt ? BigInt.prototype.valueOf : null,
    wi = Object.getOwnPropertySymbols,
    ki = 'function' == typeof Symbol && 'symbol' === e(Symbol.iterator) ? Symbol.prototype.toString : null,
    Si = 'function' == typeof Symbol && 'object' === e(Symbol.iterator),
    Ii =
      'function' == typeof Symbol && Symbol.toStringTag && (e(Symbol.toStringTag) === Si || 'symbol')
        ? Symbol.toStringTag
        : null,
    Pi = Object.prototype.propertyIsEnumerable,
    Ni =
      ('function' == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) ||
      ([].__proto__ === Array.prototype
        ? function (t) {
            return t.__proto__;
          }
        : null);
  function Mi(t, e) {
    if (t === 1 / 0 || t === -1 / 0 || t != t || (t && t > -1e3 && t < 1e3) || di.call(/e/, e)) return e;
    var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if ('number' == typeof t) {
      var r = t < 0 ? -xi(-t) : xi(t);
      if (r !== t) {
        var i = String(r),
          o = pi.call(e, i.length + 1);
        return gi.call(i, n, '$&_') + '.' + gi.call(gi.call(o, /([0-9]{3})/g, '$&_'), /_$/, '');
      }
    }
    return gi.call(e, n, '$&_');
  }
  var Oi = $r,
    Li = Oi.custom,
    Ri = ji(Li) ? Li : null;
  function Ci(t, e, n) {
    var r = 'double' === (n.quoteStyle || e) ? '"' : "'";
    return r + t + r;
  }
  function Ti(t) {
    return gi.call(String(t), /"/g, '&quot;');
  }
  function Ai(t) {
    return !('[object Array]' !== qi(t) || (Ii && 'object' === e(t) && Ii in t));
  }
  function Di(t) {
    return !('[object RegExp]' !== qi(t) || (Ii && 'object' === e(t) && Ii in t));
  }
  function ji(t) {
    if (Si) return t && 'object' === e(t) && t instanceof Symbol;
    if ('symbol' === e(t)) return !0;
    if (!t || 'object' !== e(t) || !ki) return !1;
    try {
      return ki.call(t), !0;
    } catch (t) {}
    return !1;
  }
  var Fi =
    Object.prototype.hasOwnProperty ||
    function (t) {
      return t in this;
    };
  function Bi(t, e) {
    return Fi.call(t, e);
  }
  function qi(t) {
    return ci.call(t);
  }
  function Vi(t, e) {
    if (t.indexOf) return t.indexOf(e);
    for (var n = 0, r = t.length; n < r; n++) if (t[n] === e) return n;
    return -1;
  }
  function Gi(t, e) {
    if (t.length > e.maxStringLength) {
      var n = t.length - e.maxStringLength,
        r = '... ' + n + ' more character' + (n > 1 ? 's' : '');
      return Gi(pi.call(t, 0, e.maxStringLength), e) + r;
    }
    return Ci(gi.call(gi.call(t, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, Yi), 'single', e);
  }
  function Yi(t) {
    var e = t.charCodeAt(0),
      n = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[e];
    return n ? '\\' + n : '\\x' + (e < 16 ? '0' : '') + yi.call(e.toString(16));
  }
  function zi(t) {
    return 'Object(' + t + ')';
  }
  function Ui(t) {
    return t + ' { ? }';
  }
  function Xi(t, e, n, r) {
    return t + ' (' + e + ') {' + (r ? Wi(n, r) : _i.call(n, ', ')) + '}';
  }
  function Wi(t, e) {
    if (0 === t.length) return '';
    var n = '\n' + e.prev + e.base;
    return n + _i.call(t, ',' + n) + '\n' + e.prev;
  }
  function Hi(t, e) {
    var n = Ai(t),
      r = [];
    if (n) {
      r.length = t.length;
      for (var i = 0; i < t.length; i++) r[i] = Bi(t, i) ? e(t[i], t) : '';
    }
    var o,
      a = 'function' == typeof wi ? wi(t) : [];
    if (Si) {
      o = {};
      for (var s = 0; s < a.length; s++) o['$' + a[s]] = a[s];
    }
    for (var u in t)
      Bi(t, u) &&
        ((n && String(Number(u)) === u && u < t.length) ||
          (Si && o['$' + u] instanceof Symbol) ||
          (di.call(/[^\w$]/, u) ? r.push(e(u, t) + ': ' + e(t[u], t)) : r.push(u + ': ' + e(t[u], t))));
    if ('function' == typeof wi)
      for (var l = 0; l < a.length; l++) Pi.call(t, a[l]) && r.push('[' + e(a[l]) + ']: ' + e(t[a[l]], t));
    return r;
  }
  var Zi = ft,
    Ji = Xt,
    $i = function t(n, r, i, o) {
      var a = r || {};
      if (Bi(a, 'quoteStyle') && 'single' !== a.quoteStyle && 'double' !== a.quoteStyle)
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      if (
        Bi(a, 'maxStringLength') &&
        ('number' == typeof a.maxStringLength
          ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0
          : null !== a.maxStringLength)
      )
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      var s = !Bi(a, 'customInspect') || a.customInspect;
      if ('boolean' != typeof s && 'symbol' !== s)
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
      if (
        Bi(a, 'indent') &&
        null !== a.indent &&
        '\t' !== a.indent &&
        !(parseInt(a.indent, 10) === a.indent && a.indent > 0)
      )
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      if (Bi(a, 'numericSeparator') && 'boolean' != typeof a.numericSeparator)
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      var u = a.numericSeparator;
      if (void 0 === n) return 'undefined';
      if (null === n) return 'null';
      if ('boolean' == typeof n) return n ? 'true' : 'false';
      if ('string' == typeof n) return Gi(n, a);
      if ('number' == typeof n) {
        if (0 === n) return 1 / 0 / n > 0 ? '0' : '-0';
        var l = String(n);
        return u ? Mi(n, l) : l;
      }
      if ('bigint' == typeof n) {
        var c = String(n) + 'n';
        return u ? Mi(n, c) : c;
      }
      var h = void 0 === a.depth ? 5 : a.depth;
      if ((void 0 === i && (i = 0), i >= h && h > 0 && 'object' === e(n))) return Ai(n) ? '[Array]' : '[Object]';
      var p = (function (t, e) {
        var n;
        if ('\t' === t.indent) n = '\t';
        else {
          if (!('number' == typeof t.indent && t.indent > 0)) return null;
          n = _i.call(Array(t.indent + 1), ' ');
        }
        return { base: n, prev: _i.call(Array(e + 1), n) };
      })(a, i);
      if (void 0 === o) o = [];
      else if (Vi(o, n) >= 0) return '[Circular]';
      function g(e, n, r) {
        if ((n && (o = bi.call(o)).push(n), r)) {
          var s = { depth: a.depth };
          return Bi(a, 'quoteStyle') && (s.quoteStyle = a.quoteStyle), t(e, s, i + 1, o);
        }
        return t(e, a, i + 1, o);
      }
      if ('function' == typeof n && !Di(n)) {
        var y = (function (t) {
            if (t.name) return t.name;
            var e = fi.call(hi.call(t), /^function\s*([\w$]+)/);
            if (e) return e[1];
            return null;
          })(n),
          v = Hi(n, g);
        return (
          '[Function' + (y ? ': ' + y : ' (anonymous)') + ']' + (v.length > 0 ? ' { ' + _i.call(v, ', ') + ' }' : '')
        );
      }
      if (ji(n)) {
        var d = Si ? gi.call(String(n), /^(Symbol\(.*\))_[^)]*$/, '$1') : ki.call(n);
        return 'object' !== e(n) || Si ? d : zi(d);
      }
      if (
        (function (t) {
          if (!t || 'object' !== e(t)) return !1;
          if ('undefined' != typeof HTMLElement && t instanceof HTMLElement) return !0;
          return 'string' == typeof t.nodeName && 'function' == typeof t.getAttribute;
        })(n)
      ) {
        for (var m = '<' + vi.call(String(n.nodeName)), _ = n.attributes || [], b = 0; b < _.length; b++)
          m += ' ' + _[b].name + '=' + Ci(Ti(_[b].value), 'double', a);
        return (
          (m += '>'),
          n.childNodes && n.childNodes.length && (m += '...'),
          (m += '</' + vi.call(String(n.nodeName)) + '>')
        );
      }
      if (Ai(n)) {
        if (0 === n.length) return '[]';
        var x = Hi(n, g);
        return p &&
          !(function (t) {
            for (var e = 0; e < t.length; e++) if (Vi(t[e], '\n') >= 0) return !1;
            return !0;
          })(x)
          ? '[' + Wi(x, p) + ']'
          : '[ ' + _i.call(x, ', ') + ' ]';
      }
      if (
        (function (t) {
          return !('[object Error]' !== qi(t) || (Ii && 'object' === e(t) && Ii in t));
        })(n)
      ) {
        var E = Hi(n, g);
        return 'cause' in Error.prototype || !('cause' in n) || Pi.call(n, 'cause')
          ? 0 === E.length
            ? '[' + String(n) + ']'
            : '{ [' + String(n) + '] ' + _i.call(E, ', ') + ' }'
          : '{ [' + String(n) + '] ' + _i.call(mi.call('[cause]: ' + g(n.cause), E), ', ') + ' }';
      }
      if ('object' === e(n) && s) {
        if (Ri && 'function' == typeof n[Ri] && Oi) return Oi(n, { depth: h - i });
        if ('symbol' !== s && 'function' == typeof n.inspect) return n.inspect();
      }
      if (
        (function (t) {
          if (!ti || !t || 'object' !== e(t)) return !1;
          try {
            ti.call(t);
            try {
              ii.call(t);
            } catch (t) {
              return !0;
            }
            return t instanceof Map;
          } catch (t) {}
          return !1;
        })(n)
      ) {
        var w = [];
        return (
          ei &&
            ei.call(n, function (t, e) {
              w.push(g(e, n, !0) + ' => ' + g(t, n));
            }),
          Xi('Map', ti.call(n), w, p)
        );
      }
      if (
        (function (t) {
          if (!ii || !t || 'object' !== e(t)) return !1;
          try {
            ii.call(t);
            try {
              ti.call(t);
            } catch (t) {
              return !0;
            }
            return t instanceof Set;
          } catch (t) {}
          return !1;
        })(n)
      ) {
        var k = [];
        return (
          oi &&
            oi.call(n, function (t) {
              k.push(g(t, n));
            }),
          Xi('Set', ii.call(n), k, p)
        );
      }
      if (
        (function (t) {
          if (!ai || !t || 'object' !== e(t)) return !1;
          try {
            ai.call(t, ai);
            try {
              si.call(t, si);
            } catch (t) {
              return !0;
            }
            return t instanceof WeakMap;
          } catch (t) {}
          return !1;
        })(n)
      )
        return Ui('WeakMap');
      if (
        (function (t) {
          if (!si || !t || 'object' !== e(t)) return !1;
          try {
            si.call(t, si);
            try {
              ai.call(t, ai);
            } catch (t) {
              return !0;
            }
            return t instanceof WeakSet;
          } catch (t) {}
          return !1;
        })(n)
      )
        return Ui('WeakSet');
      if (
        (function (t) {
          if (!ui || !t || 'object' !== e(t)) return !1;
          try {
            return ui.call(t), !0;
          } catch (t) {}
          return !1;
        })(n)
      )
        return Ui('WeakRef');
      if (
        (function (t) {
          return !('[object Number]' !== qi(t) || (Ii && 'object' === e(t) && Ii in t));
        })(n)
      )
        return zi(g(Number(n)));
      if (
        (function (t) {
          if (!t || 'object' !== e(t) || !Ei) return !1;
          try {
            return Ei.call(t), !0;
          } catch (t) {}
          return !1;
        })(n)
      )
        return zi(g(Ei.call(n)));
      if (
        (function (t) {
          return !('[object Boolean]' !== qi(t) || (Ii && 'object' === e(t) && Ii in t));
        })(n)
      )
        return zi(li.call(n));
      if (
        (function (t) {
          return !('[object String]' !== qi(t) || (Ii && 'object' === e(t) && Ii in t));
        })(n)
      )
        return zi(g(String(n)));
      if ('undefined' != typeof window && n === window) return '{ [object Window] }';
      if (n === f) return '{ [object globalThis] }';
      if (
        !(function (t) {
          return !('[object Date]' !== qi(t) || (Ii && 'object' === e(t) && Ii in t));
        })(n) &&
        !Di(n)
      ) {
        var S = Hi(n, g),
          I = Ni ? Ni(n) === Object.prototype : n instanceof Object || n.constructor === Object,
          P = n instanceof Object ? '' : 'null prototype',
          N = !I && Ii && Object(n) === n && Ii in n ? pi.call(qi(n), 8, -1) : P ? 'Object' : '',
          M =
            (I || 'function' != typeof n.constructor ? '' : n.constructor.name ? n.constructor.name + ' ' : '') +
            (N || P ? '[' + _i.call(mi.call([], N || [], P || []), ': ') + '] ' : '');
        return 0 === S.length ? M + '{}' : p ? M + '{' + Wi(S, p) + '}' : M + '{ ' + _i.call(S, ', ') + ' }';
      }
      return String(n);
    },
    Qi = Zi('%TypeError%'),
    Ki = Zi('%WeakMap%', !0),
    to = Zi('%Map%', !0),
    eo = Ji('WeakMap.prototype.get', !0),
    no = Ji('WeakMap.prototype.set', !0),
    ro = Ji('WeakMap.prototype.has', !0),
    io = Ji('Map.prototype.get', !0),
    oo = Ji('Map.prototype.set', !0),
    ao = Ji('Map.prototype.has', !0),
    so = function (t, e) {
      for (var n, r = t; null !== (n = r.next); r = n)
        if (n.key === e) return (r.next = n.next), (n.next = t.next), (t.next = n), n;
    },
    uo = function (t) {
      return t != t;
    },
    lo = function (t, e) {
      return 0 === t && 0 === e ? 1 / t == 1 / e : t === e || !(!uo(t) || !uo(e));
    },
    co = lo,
    ho = function () {
      return 'function' == typeof Object.is ? Object.is : co;
    },
    fo = ho,
    po = Ct,
    go = Ct,
    yo = lo,
    vo = ho,
    mo = function () {
      var t = fo();
      return (
        po(
          Object,
          { is: t },
          {
            is: function () {
              return Object.is !== t;
            },
          },
        ),
        t
      );
    },
    _o = Gt(vo(), Object);
  go(_o, { getPolyfill: vo, implementation: yo, shim: mo });
  var bo = _o,
    xo = I,
    Eo = function () {
      return xo() && !!Symbol.toStringTag;
    },
    wo = Eo(),
    ko = Xt('Object.prototype.toString'),
    So = function (t) {
      return !(wo && t && 'object' === e(t) && Symbol.toStringTag in t) && '[object Arguments]' === ko(t);
    },
    Io = function (t) {
      return (
        !!So(t) ||
        (null !== t &&
          'object' === e(t) &&
          'number' == typeof t.length &&
          t.length >= 0 &&
          '[object Array]' !== ko(t) &&
          '[object Function]' === ko(t.callee))
      );
    },
    Po = (function () {
      return So(arguments);
    })();
  So.isLegacyArguments = Io;
  var No,
    Mo,
    Oo = Po ? So : Io,
    Lo = {}.toString,
    Ro =
      Array.isArray ||
      function (t) {
        return '[object Array]' == Lo.call(t);
      },
    Co = Function.prototype.toString,
    To = 'object' === ('undefined' == typeof Reflect ? 'undefined' : e(Reflect)) && null !== Reflect && Reflect.apply;
  if ('function' == typeof To && 'function' == typeof Object.defineProperty)
    try {
      (No = Object.defineProperty({}, 'length', {
        get: function () {
          throw Mo;
        },
      })),
        (Mo = {}),
        To(
          function () {
            throw 42;
          },
          null,
          No,
        );
    } catch (t) {
      t !== Mo && (To = null);
    }
  else To = null;
  var Ao = /^\s*class\b/,
    Do = function (t) {
      try {
        var e = Co.call(t);
        return Ao.test(e);
      } catch (t) {
        return !1;
      }
    },
    jo = function (t) {
      try {
        return !Do(t) && (Co.call(t), !0);
      } catch (t) {
        return !1;
      }
    },
    Fo = Object.prototype.toString,
    Bo = 'function' == typeof Symbol && !!Symbol.toStringTag,
    qo = !(0 in [,]),
    Vo = function () {
      return !1;
    };
  if ('object' === ('undefined' == typeof document ? 'undefined' : e(document))) {
    var Go = document.all;
    Fo.call(Go) === Fo.call(document.all) &&
      (Vo = function (t) {
        if ((qo || !t) && (void 0 === t || 'object' === e(t)))
          try {
            var n = Fo.call(t);
            return (
              ('[object HTMLAllCollection]' === n ||
                '[object HTML document.all class]' === n ||
                '[object HTMLCollection]' === n ||
                '[object Object]' === n) &&
              null == t('')
            );
          } catch (t) {}
        return !1;
      });
  }
  var Yo = To
      ? function (t) {
          if (Vo(t)) return !0;
          if (!t) return !1;
          if ('function' != typeof t && 'object' !== e(t)) return !1;
          try {
            To(t, null, No);
          } catch (t) {
            if (t !== Mo) return !1;
          }
          return !Do(t) && jo(t);
        }
      : function (t) {
          if (Vo(t)) return !0;
          if (!t) return !1;
          if ('function' != typeof t && 'object' !== e(t)) return !1;
          if (Bo) return jo(t);
          if (Do(t)) return !1;
          var n = Fo.call(t);
          return (
            !('[object Function]' !== n && '[object GeneratorFunction]' !== n && !/^\[object HTML/.test(n)) && jo(t)
          );
        },
    zo = Yo,
    Uo = Object.prototype.toString,
    Xo = Object.prototype.hasOwnProperty,
    Wo = function (t, e, n) {
      if (!zo(e)) throw new TypeError('iterator must be a function');
      var r;
      arguments.length >= 3 && (r = n),
        '[object Array]' === Uo.call(t)
          ? (function (t, e, n) {
              for (var r = 0, i = t.length; r < i; r++)
                Xo.call(t, r) && (null == n ? e(t[r], r, t) : e.call(n, t[r], r, t));
            })(t, e, r)
          : 'string' == typeof t
          ? (function (t, e, n) {
              for (var r = 0, i = t.length; r < i; r++) null == n ? e(t.charAt(r), r, t) : e.call(n, t.charAt(r), r, t);
            })(t, e, r)
          : (function (t, e, n) {
              for (var r in t) Xo.call(t, r) && (null == n ? e(t[r], r, t) : e.call(n, t[r], r, t));
            })(t, e, r);
    },
    Ho = [
      'BigInt64Array',
      'BigUint64Array',
      'Float32Array',
      'Float64Array',
      'Int16Array',
      'Int32Array',
      'Int8Array',
      'Uint16Array',
      'Uint32Array',
      'Uint8Array',
      'Uint8ClampedArray',
    ],
    Zo = 'undefined' == typeof globalThis ? f : globalThis,
    Jo = Wo,
    $o = function () {
      for (var t = [], e = 0; e < Ho.length; e++) 'function' == typeof Zo[Ho[e]] && (t[t.length] = Ho[e]);
      return t;
    },
    Qo = Gt,
    Ko = Xt,
    ta = dt,
    ea = Ko('Object.prototype.toString'),
    na = Eo(),
    ra = 'undefined' == typeof globalThis ? f : globalThis,
    ia = $o(),
    oa = Ko('String.prototype.slice'),
    aa = Object.getPrototypeOf,
    sa =
      Ko('Array.prototype.indexOf', !0) ||
      function (t, e) {
        for (var n = 0; n < t.length; n += 1) if (t[n] === e) return n;
        return -1;
      },
    ua = { __proto__: null };
  Jo(
    ia,
    na && ta && aa
      ? function (t) {
          var e = new ra[t]();
          if (Symbol.toStringTag in e) {
            var n = aa(e),
              r = ta(n, Symbol.toStringTag);
            if (!r) {
              var i = aa(n);
              r = ta(i, Symbol.toStringTag);
            }
            ua['$' + t] = Qo(r.get);
          }
        }
      : function (t) {
          var e = new ra[t](),
            n = e.slice || e.set;
          n && (ua['$' + t] = Qo(n));
        },
  );
  var la,
    ca,
    ha,
    fa,
    pa = function (t) {
      if (!t || 'object' !== e(t)) return !1;
      if (!na) {
        var n = oa(ea(t), 8, -1);
        return sa(ia, n) > -1
          ? n
          : 'Object' === n &&
              (function (t) {
                var e = !1;
                return (
                  Jo(ua, function (n, r) {
                    if (!e)
                      try {
                        n(t), (e = oa(r, 1));
                      } catch (t) {}
                  }),
                  e
                );
              })(t);
      }
      return ta
        ? (function (t) {
            var e = !1;
            return (
              Jo(ua, function (n, r) {
                if (!e)
                  try {
                    '$' + n(t) === r && (e = oa(r, 1));
                  } catch (t) {}
              }),
              e
            );
          })(t)
        : null;
    },
    ga = pa,
    ya = Gt,
    va = Xt,
    da = ft,
    ma = function (t) {
      return !!ga(t);
    },
    _a = da('ArrayBuffer', !0),
    ba = da('Float32Array', !0),
    xa = va('ArrayBuffer.prototype.byteLength', !0),
    Ea = _a && !xa && new _a().slice,
    wa = Ea && ya(Ea),
    ka =
      xa || wa
        ? function (t) {
            if (!t || 'object' !== e(t)) return !1;
            try {
              return xa ? xa(t) : wa(t, 0), !0;
            } catch (t) {
              return !1;
            }
          }
        : ba
        ? function (t) {
            try {
              return new ba(t).buffer === t && !ma(t);
            } catch (n) {
              return 'object' === e(t) && 'RangeError' === n.name;
            }
          }
        : function (t) {
            return !1;
          },
    Sa = Date.prototype.getDay,
    Ia = Object.prototype.toString,
    Pa = Eo(),
    Na = Xt,
    Ma = Eo();
  if (Ma) {
    (la = Na('Object.prototype.hasOwnProperty')), (ca = Na('RegExp.prototype.exec')), (ha = {});
    var Oa = function () {
      throw ha;
    };
    (fa = { toString: Oa, valueOf: Oa }), 'symbol' === e(Symbol.toPrimitive) && (fa[Symbol.toPrimitive] = Oa);
  }
  var La = Na('Object.prototype.toString'),
    Ra = Object.getOwnPropertyDescriptor,
    Ca = Ma
      ? function (t) {
          if (!t || 'object' !== e(t)) return !1;
          var n = Ra(t, 'lastIndex');
          if (!(n && la(n, 'value'))) return !1;
          try {
            ca(t, fa);
          } catch (t) {
            return t === ha;
          }
        }
      : function (t) {
          return !(!t || ('object' !== e(t) && 'function' != typeof t)) && '[object RegExp]' === La(t);
        },
    Ta = Xt('SharedArrayBuffer.prototype.byteLength', !0),
    Aa = Ta
      ? function (t) {
          if (!t || 'object' !== e(t)) return !1;
          try {
            return Ta(t), !0;
          } catch (t) {
            return !1;
          }
        }
      : function (t) {
          return !1;
        },
    Da = String.prototype.valueOf,
    ja = Object.prototype.toString,
    Fa = Eo(),
    Ba = Number.prototype.toString,
    qa = Object.prototype.toString,
    Va = Eo(),
    Ga = Xt,
    Ya = Ga('Boolean.prototype.toString'),
    za = Ga('Object.prototype.toString'),
    Ua = Eo(),
    Xa = { exports: {} },
    Wa = Object.prototype.toString;
  if (M()) {
    var Ha = Symbol.prototype.toString,
      Za = /^Symbol\(.*\)$/;
    Xa.exports = function (t) {
      if ('symbol' === e(t)) return !0;
      if ('[object Symbol]' !== Wa.call(t)) return !1;
      try {
        return (function (t) {
          return 'symbol' === e(t.valueOf()) && Za.test(Ha.call(t));
        })(t);
      } catch (t) {
        return !1;
      }
    };
  } else
    Xa.exports = function (t) {
      return !1;
    };
  var Ja = Xa.exports,
    $a = { exports: {} },
    Qa = 'undefined' != typeof BigInt && BigInt;
  if (
    'function' == typeof Qa &&
    'function' == typeof BigInt &&
    'bigint' == typeof Qa(42) &&
    'bigint' == typeof BigInt(42)
  ) {
    var Ka = BigInt.prototype.valueOf;
    $a.exports = function (t) {
      return (
        null != t &&
        'boolean' != typeof t &&
        'string' != typeof t &&
        'number' != typeof t &&
        'symbol' !== e(t) &&
        'function' != typeof t &&
        ('bigint' == typeof t ||
          (function (t) {
            try {
              return Ka.call(t), !0;
            } catch (t) {}
            return !1;
          })(t))
      );
    };
  } else
    $a.exports = function (t) {
      return !1;
    };
  var ts,
    es = $a.exports,
    ns = function (t) {
      return (
        'string' == typeof t ||
        ('object' === e(t) &&
          (Fa
            ? (function (t) {
                try {
                  return Da.call(t), !0;
                } catch (t) {
                  return !1;
                }
              })(t)
            : '[object String]' === ja.call(t)))
      );
    },
    rs = function (t) {
      return (
        'number' == typeof t ||
        ('object' === e(t) &&
          (Va
            ? (function (t) {
                try {
                  return Ba.call(t), !0;
                } catch (t) {
                  return !1;
                }
              })(t)
            : '[object Number]' === qa.call(t)))
      );
    },
    is = function (t) {
      return (
        'boolean' == typeof t ||
        (null !== t &&
          'object' === e(t) &&
          (Ua && Symbol.toStringTag in t
            ? (function (t) {
                try {
                  return Ya(t), !0;
                } catch (t) {
                  return !1;
                }
              })(t)
            : '[object Boolean]' === za(t)))
      );
    },
    os = Ja,
    as = es,
    ss = 'function' == typeof Map && Map.prototype ? Map : null,
    us = 'function' == typeof Set && Set.prototype ? Set : null;
  ss ||
    (ts = function (t) {
      return !1;
    });
  var ls = ss ? Map.prototype.has : null,
    cs = us ? Set.prototype.has : null;
  ts ||
    ls ||
    (ts = function (t) {
      return !1;
    });
  var hs,
    fs =
      ts ||
      function (t) {
        if (!t || 'object' !== e(t)) return !1;
        try {
          if ((ls.call(t), cs))
            try {
              cs.call(t);
            } catch (t) {
              return !0;
            }
          return t instanceof ss;
        } catch (t) {}
        return !1;
      },
    ps = 'function' == typeof Map && Map.prototype ? Map : null,
    gs = 'function' == typeof Set && Set.prototype ? Set : null;
  gs ||
    (hs = function (t) {
      return !1;
    });
  var ys = ps ? Map.prototype.has : null,
    vs = gs ? Set.prototype.has : null;
  hs ||
    vs ||
    (hs = function (t) {
      return !1;
    });
  var ds,
    ms =
      hs ||
      function (t) {
        if (!t || 'object' !== e(t)) return !1;
        try {
          if ((vs.call(t), ys))
            try {
              ys.call(t);
            } catch (t) {
              return !0;
            }
          return t instanceof gs;
        } catch (t) {}
        return !1;
      },
    _s = 'function' == typeof WeakMap && WeakMap.prototype ? WeakMap : null,
    bs = 'function' == typeof WeakSet && WeakSet.prototype ? WeakSet : null;
  _s ||
    (ds = function (t) {
      return !1;
    });
  var xs = _s ? _s.prototype.has : null,
    Es = bs ? bs.prototype.has : null;
  ds ||
    xs ||
    (ds = function (t) {
      return !1;
    });
  var ws =
      ds ||
      function (t) {
        if (!t || 'object' !== e(t)) return !1;
        try {
          if ((xs.call(t, xs), Es))
            try {
              Es.call(t, Es);
            } catch (t) {
              return !0;
            }
          return t instanceof _s;
        } catch (t) {}
        return !1;
      },
    ks = { exports: {} },
    Ss = Xt,
    Is = ft('%WeakSet%', !0),
    Ps = Ss('WeakSet.prototype.has', !0);
  if (Ps) {
    var Ns = Ss('WeakMap.prototype.has', !0);
    ks.exports = function (t) {
      if (!t || 'object' !== e(t)) return !1;
      try {
        if ((Ps(t, Ps), Ns))
          try {
            Ns(t, Ns);
          } catch (t) {
            return !0;
          }
        return t instanceof Is;
      } catch (t) {}
      return !1;
    };
  } else
    ks.exports = function (t) {
      return !1;
    };
  var Ms = ks.exports,
    Os = fs,
    Ls = ms,
    Rs = ws,
    Cs = Ms,
    Ts = Xt('ArrayBuffer.prototype.byteLength', !0),
    As = ka,
    Ds = he,
    js = Xt,
    Fs = qe,
    Bs = ft,
    qs = function (t) {
      if (null != t && void 0 !== t[Ve]) return t[Ve]();
    },
    Vs = function () {
      var t,
        n,
        r,
        i = {
          assert: function (t) {
            if (!i.has(t)) throw new Qi('Side channel does not contain ' + $i(t));
          },
          get: function (i) {
            if (Ki && i && ('object' === e(i) || 'function' == typeof i)) {
              if (t) return eo(t, i);
            } else if (to) {
              if (n) return io(n, i);
            } else if (r)
              return (function (t, e) {
                var n = so(t, e);
                return n && n.value;
              })(r, i);
          },
          has: function (i) {
            if (Ki && i && ('object' === e(i) || 'function' == typeof i)) {
              if (t) return ro(t, i);
            } else if (to) {
              if (n) return ao(n, i);
            } else if (r)
              return (function (t, e) {
                return !!so(t, e);
              })(r, i);
            return !1;
          },
          set: function (i, o) {
            Ki && i && ('object' === e(i) || 'function' == typeof i)
              ? (t || (t = new Ki()), no(t, i, o))
              : to
              ? (n || (n = new to()), oo(n, i, o))
              : (r || (r = { key: {}, next: null }),
                (function (t, e, n) {
                  var r = so(t, e);
                  r ? (r.value = n) : (t.next = { key: e, next: t.next, value: n });
                })(r, i, o));
          },
        };
      return i;
    },
    Gs = bo,
    Ys = Oo,
    zs = Ro,
    Us = ka,
    Xs = function (t) {
      return (
        'object' === e(t) &&
        null !== t &&
        (Pa
          ? (function (t) {
              try {
                return Sa.call(t), !0;
              } catch (t) {
                return !1;
              }
            })(t)
          : '[object Date]' === Ia.call(t))
      );
    },
    Ws = Ca,
    Hs = Aa,
    Zs = S,
    Js = function (t) {
      return null == t || ('object' !== e(t) && 'function' != typeof t)
        ? null
        : ns(t)
        ? 'String'
        : rs(t)
        ? 'Number'
        : is(t)
        ? 'Boolean'
        : os(t)
        ? 'Symbol'
        : as(t)
        ? 'BigInt'
        : void 0;
    },
    $s = function (t) {
      if (t && 'object' === e(t)) {
        if (Os(t)) return 'Map';
        if (Ls(t)) return 'Set';
        if (Rs(t)) return 'WeakMap';
        if (Cs(t)) return 'WeakSet';
      }
      return !1;
    },
    Qs = pa,
    Ks = function (t) {
      return As(t) ? (Ts ? Ts(t) : t.byteLength) : NaN;
    },
    tu = js('SharedArrayBuffer.prototype.byteLength', !0),
    eu = js('Date.prototype.getTime'),
    nu = Object.getPrototypeOf,
    ru = js('Object.prototype.toString'),
    iu = Bs('%Set%', !0),
    ou = js('Map.prototype.has', !0),
    au = js('Map.prototype.get', !0),
    su = js('Map.prototype.size', !0),
    uu = js('Set.prototype.add', !0),
    lu = js('Set.prototype.delete', !0),
    cu = js('Set.prototype.has', !0),
    hu = js('Set.prototype.size', !0);
  function fu(t, e, n, r) {
    for (var i, o = qs(t); (i = o.next()) && !i.done; ) if (du(e, i.value, n, r)) return lu(t, i.value), !0;
    return !1;
  }
  function pu(t) {
    return void 0 === t
      ? null
      : 'object' !== e(t)
      ? 'symbol' !== e(t) && (('string' != typeof t && 'number' != typeof t) || +t == +t)
      : void 0;
  }
  function gu(t, e, n, r, i, o) {
    var a = pu(n);
    if (null != a) return a;
    var s = au(e, a),
      u = Ds({}, i, { strict: !1 });
    return !((void 0 === s && !ou(e, a)) || !du(r, s, u, o)) && !ou(t, a) && du(r, s, u, o);
  }
  function yu(t, e, n) {
    var r = pu(n);
    return null != r ? r : cu(e, r) && !cu(t, r);
  }
  function vu(t, e, n, r, i, o) {
    for (var a, s, u = qs(t); (a = u.next()) && !a.done; )
      if (du(n, (s = a.value), i, o) && du(r, au(e, s), i, o)) return lu(t, s), !0;
    return !1;
  }
  function du(t, n, r, i) {
    var o = r || {};
    if (o.strict ? Gs(t, n) : t === n) return !0;
    if (Js(t) !== Js(n)) return !1;
    if (!t || !n || ('object' !== e(t) && 'object' !== e(n))) return o.strict ? Gs(t, n) : t == n;
    var a,
      s = i.has(t),
      u = i.has(n);
    if (s && u) {
      if (i.get(t) === i.get(n)) return !0;
    } else a = {};
    return (
      s || i.set(t, a),
      u || i.set(n, a),
      (function (t, n, r, i) {
        var o, a;
        if (e(t) !== e(n)) return !1;
        if (null == t || null == n) return !1;
        if (ru(t) !== ru(n)) return !1;
        if (Ys(t) !== Ys(n)) return !1;
        var s = zs(t),
          u = zs(n);
        if (s !== u) return !1;
        var l = t instanceof Error,
          c = n instanceof Error;
        if (l !== c) return !1;
        if ((l || c) && (t.name !== n.name || t.message !== n.message)) return !1;
        var h = Ws(t),
          f = Ws(n);
        if (h !== f) return !1;
        if ((h || f) && (t.source !== n.source || Fs(t) !== Fs(n))) return !1;
        var p = Xs(t),
          g = Xs(n);
        if (p !== g) return !1;
        if ((p || g) && eu(t) !== eu(n)) return !1;
        if (r.strict && nu && nu(t) !== nu(n)) return !1;
        var y = Qs(t),
          v = Qs(n);
        if (y !== v) return !1;
        if (y || v) {
          if (t.length !== n.length) return !1;
          for (o = 0; o < t.length; o++) if (t[o] !== n[o]) return !1;
          return !0;
        }
        var d = mu(t),
          m = mu(n);
        if (d !== m) return !1;
        if (d || m) {
          if (t.length !== n.length) return !1;
          for (o = 0; o < t.length; o++) if (t[o] !== n[o]) return !1;
          return !0;
        }
        var _ = Us(t),
          b = Us(n);
        if (_ !== b) return !1;
        if (_ || b)
          return Ks(t) === Ks(n) && 'function' == typeof Uint8Array && du(new Uint8Array(t), new Uint8Array(n), r, i);
        var x = Hs(t),
          E = Hs(n);
        if (x !== E) return !1;
        if (x || E)
          return tu(t) === tu(n) && 'function' == typeof Uint8Array && du(new Uint8Array(t), new Uint8Array(n), r, i);
        if (e(t) !== e(n)) return !1;
        var w = Zs(t),
          k = Zs(n);
        if (w.length !== k.length) return !1;
        for (w.sort(), k.sort(), o = w.length - 1; o >= 0; o--) if (w[o] != k[o]) return !1;
        for (o = w.length - 1; o >= 0; o--) if (!du(t[(a = w[o])], n[a], r, i)) return !1;
        var S = $s(t),
          I = $s(n);
        if (S !== I) return !1;
        if ('Set' === S || 'Set' === I)
          return (function (t, n, r, i) {
            if (hu(t) !== hu(n)) return !1;
            var o,
              a,
              s,
              u = qs(t),
              l = qs(n);
            for (; (o = u.next()) && !o.done; )
              if (o.value && 'object' === e(o.value)) s || (s = new iu()), uu(s, o.value);
              else if (!cu(n, o.value)) {
                if (r.strict) return !1;
                if (!yu(t, n, o.value)) return !1;
                s || (s = new iu()), uu(s, o.value);
              }
            if (s) {
              for (; (a = l.next()) && !a.done; )
                if (a.value && 'object' === e(a.value)) {
                  if (!fu(s, a.value, r.strict, i)) return !1;
                } else if (!r.strict && !cu(t, a.value) && !fu(s, a.value, r.strict, i)) return !1;
              return 0 === hu(s);
            }
            return !0;
          })(t, n, r, i);
        if ('Map' === S)
          return (function (t, n, r, i) {
            if (su(t) !== su(n)) return !1;
            var o,
              a,
              s,
              u,
              l,
              c,
              h = qs(t),
              f = qs(n);
            for (; (o = h.next()) && !o.done; )
              if (((u = o.value[0]), (l = o.value[1]), u && 'object' === e(u))) s || (s = new iu()), uu(s, u);
              else if ((void 0 === (c = au(n, u)) && !ou(n, u)) || !du(l, c, r, i)) {
                if (r.strict) return !1;
                if (!gu(t, n, u, l, r, i)) return !1;
                s || (s = new iu()), uu(s, u);
              }
            if (s) {
              for (; (a = f.next()) && !a.done; )
                if (((u = a.value[0]), (c = a.value[1]), u && 'object' === e(u))) {
                  if (!vu(s, t, u, c, r, i)) return !1;
                } else if (
                  !(r.strict || (t.has(u) && du(au(t, u), c, r, i)) || vu(s, t, u, c, Ds({}, r, { strict: !1 }), i))
                )
                  return !1;
              return 0 === hu(s);
            }
            return !0;
          })(t, n, r, i);
        return !0;
      })(t, n, o, i)
    );
  }
  function mu(t) {
    return (
      !(!t || 'object' !== e(t) || 'number' != typeof t.length) &&
      'function' == typeof t.copy &&
      'function' == typeof t.slice &&
      !(t.length > 0 && 'number' != typeof t[0]) &&
      !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
    );
  }
  var _u = p(function (t, e, n) {
      return du(t, e, n, Vs());
    }),
    bu = Object.defineProperty,
    xu = function (t, e) {
      return bu(t, 'name', { value: e, configurable: !0 });
    },
    Eu = (function () {
      function t(e) {
        var r, i, o;
        n(this, t),
          (this.direction = !1),
          (this.compareProperties = !0),
          (this.precision = Math.pow(10, -(null != (r = null == e ? void 0 : e.precision) ? r : 17))),
          (this.direction = null != (i = null == e ? void 0 : e.direction) && i),
          (this.compareProperties = null == (o = null == e ? void 0 : e.compareProperties) || o);
      }
      return (
        i(t, [
          {
            key: 'compare',
            value: function (t, e) {
              var n = this;
              if (t.type !== e.type) return !1;
              if (!ku(t, e)) return !1;
              switch (t.type) {
                case 'Point':
                  return this.compareCoord(t.coordinates, e.coordinates);
                case 'LineString':
                  return this.compareLine(t.coordinates, e.coordinates);
                case 'Polygon':
                  return this.comparePolygon(t, e);
                case 'GeometryCollection':
                  return this.compareGeometryCollection(t, e);
                case 'Feature':
                  return this.compareFeature(t, e);
                case 'FeatureCollection':
                  return this.compareFeatureCollection(t, e);
                default:
                  if (t.type.startsWith('Multi')) {
                    var r = Su(t),
                      i = Su(e);
                    return r.every(function (t) {
                      return i.some(function (e) {
                        return n.compare(t, e);
                      });
                    });
                  }
              }
              return !1;
            },
          },
          {
            key: 'compareCoord',
            value: function (t, e) {
              var n = this;
              return (
                t.length === e.length &&
                t.every(function (t, r) {
                  return Math.abs(t - e[r]) < n.precision;
                })
              );
            },
          },
          {
            key: 'compareLine',
            value: function (t, e) {
              var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
              if (!ku(t, e)) return !1;
              var i = t,
                o = e;
              if (r && !this.compareCoord(i[0], o[0])) {
                var a = this.fixStartIndex(o, i);
                if (!a) return !1;
                o = a;
              }
              var s = this.compareCoord(i[n], o[n]);
              return this.direction || s
                ? this.comparePath(i, o)
                : !!this.compareCoord(i[n], o[o.length - (1 + n)]) && this.comparePath(i.slice().reverse(), o);
            },
          },
          {
            key: 'fixStartIndex',
            value: function (t, e) {
              for (var n, r = -1, i = 0; i < t.length; i++)
                if (this.compareCoord(t[i], e[0])) {
                  r = i;
                  break;
                }
              return r >= 0 && (n = [].concat(t.slice(r, t.length), t.slice(1, r + 1))), n;
            },
          },
          {
            key: 'comparePath',
            value: function (t, e) {
              var n = this;
              return t.every(function (t, r) {
                return n.compareCoord(t, e[r]);
              });
            },
          },
          {
            key: 'comparePolygon',
            value: function (t, e) {
              var n = this;
              if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) {
                var r = t.coordinates.slice(1, t.coordinates.length),
                  i = e.coordinates.slice(1, e.coordinates.length);
                return r.every(function (t) {
                  return i.some(function (e) {
                    return n.compareLine(t, e, 1, !0);
                  });
                });
              }
              return !1;
            },
          },
          {
            key: 'compareGeometryCollection',
            value: function (t, e) {
              var n = this;
              return (
                ku(t.geometries, e.geometries) &&
                this.compareBBox(t, e) &&
                t.geometries.every(function (t, r) {
                  return n.compare(t, e.geometries[r]);
                })
              );
            },
          },
          {
            key: 'compareFeature',
            value: function (t, e) {
              return (
                t.id === e.id &&
                (!this.compareProperties || _u(t.properties, e.properties)) &&
                this.compareBBox(t, e) &&
                this.compare(t.geometry, e.geometry)
              );
            },
          },
          {
            key: 'compareFeatureCollection',
            value: function (t, e) {
              var n = this;
              return (
                ku(t.features, e.features) &&
                this.compareBBox(t, e) &&
                t.features.every(function (t, r) {
                  return n.compare(t, e.features[r]);
                })
              );
            },
          },
          {
            key: 'compareBBox',
            value: function (t, e) {
              return Boolean(!t.bbox && !e.bbox) || (!(!t.bbox || !e.bbox) && this.compareCoord(t.bbox, e.bbox));
            },
          },
        ]),
        t
      );
    })();
  xu(Eu, 'GeojsonEquality');
  var wu = Eu;
  function ku(t, e) {
    return t.coordinates ? t.coordinates.length === e.coordinates.length : t.length === e.length;
  }
  function Su(t) {
    return t.coordinates.map(function (e) {
      return { type: t.type.replace('Multi', ''), coordinates: e };
    });
  }
  xu(ku, 'sameLength'), xu(Su, 'explode');
  var Iu = 6371008.8,
    Pu = {
      centimeters: 100 * Iu,
      centimetres: 100 * Iu,
      degrees: 360 / (2 * Math.PI),
      feet: 3.28084 * Iu,
      inches: 39.37 * Iu,
      kilometers: Iu / 1e3,
      kilometres: Iu / 1e3,
      meters: Iu,
      metres: Iu,
      miles: Iu / 1609.344,
      millimeters: 1e3 * Iu,
      millimetres: 1e3 * Iu,
      nauticalmiles: Iu / 1852,
      radians: 1,
      yards: 1.0936 * Iu,
    },
    Nu = {
      acres: 247105e-9,
      centimeters: 1e4,
      centimetres: 1e4,
      feet: 10.763910417,
      hectares: 1e-4,
      inches: 1550.003100006,
      kilometers: 1e-6,
      kilometres: 1e-6,
      meters: 1,
      metres: 1,
      miles: 386e-9,
      nauticalmiles: 2.9155334959812285e-7,
      millimeters: 1e6,
      millimetres: 1e6,
      yards: 1.195990046,
    };
  function Mu(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      r = { type: 'Feature' };
    return (
      (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), (r.properties = e || {}), (r.geometry = t), r
    );
  }
  function Ou(t, e) {
    switch (t) {
      case 'Point':
        return Lu(e).geometry;
      case 'LineString':
        return Au(e).geometry;
      case 'Polygon':
        return Cu(e).geometry;
      case 'MultiPoint':
        return Bu(e).geometry;
      case 'MultiLineString':
        return Fu(e).geometry;
      case 'MultiPolygon':
        return qu(e).geometry;
      default:
        throw new Error(t + ' is invalid');
    }
  }
  function Lu(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (!t) throw new Error('coordinates is required');
    if (!Array.isArray(t)) throw new Error('coordinates must be an Array');
    if (t.length < 2) throw new Error('coordinates must be at least 2 numbers long');
    if (!$u(t[0]) || !$u(t[1])) throw new Error('coordinates must contain numbers');
    return Mu({ type: 'Point', coordinates: t }, e, n);
  }
  function Ru(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return ju(
      t.map(function (t) {
        return Lu(t, e);
      }),
      n,
    );
  }
  function Cu(t, e) {
    var n,
      r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      i = c(t);
    try {
      for (i.s(); !(n = i.n()).done; ) {
        var o = n.value;
        if (o.length < 4) throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        if (o[o.length - 1].length !== o[0].length) throw new Error('First and last Position are not equivalent.');
        for (var a = 0; a < o[o.length - 1].length; a++)
          if (o[o.length - 1][a] !== o[0][a]) throw new Error('First and last Position are not equivalent.');
      }
    } catch (t) {
      i.e(t);
    } finally {
      i.f();
    }
    return Mu({ type: 'Polygon', coordinates: t }, e, r);
  }
  function Tu(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return ju(
      t.map(function (t) {
        return Cu(t, e);
      }),
      n,
    );
  }
  function Au(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (t.length < 2) throw new Error('coordinates must be an array of two or more positions');
    return Mu({ type: 'LineString', coordinates: t }, e, n);
  }
  function Du(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return ju(
      t.map(function (t) {
        return Au(t, e);
      }),
      n,
    );
  }
  function ju(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = { type: 'FeatureCollection' };
    return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), (n.features = t), n;
  }
  function Fu(t, e) {
    return Mu(
      { type: 'MultiLineString', coordinates: t },
      e,
      arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
    );
  }
  function Bu(t, e) {
    return Mu(
      { type: 'MultiPoint', coordinates: t },
      e,
      arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
    );
  }
  function qu(t, e) {
    return Mu(
      { type: 'MultiPolygon', coordinates: t },
      e,
      arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
    );
  }
  function Vu(t, e) {
    return Mu(
      { type: 'GeometryCollection', geometries: t },
      e,
      arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
    );
  }
  function Gu(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (e && !(e >= 0)) throw new Error('precision must be a positive number');
    var n = Math.pow(10, e || 0);
    return Math.round(t * n) / n;
  }
  function Yu(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'kilometers',
      n = Pu[e];
    if (!n) throw new Error(e + ' units is invalid');
    return t * n;
  }
  function zu(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'kilometers',
      n = Pu[e];
    if (!n) throw new Error(e + ' units is invalid');
    return t / n;
  }
  function Uu(t, e) {
    return Wu(zu(t, e));
  }
  function Xu(t) {
    var e = t % 360;
    return e < 0 && (e += 360), e;
  }
  function Wu(t) {
    return (180 * (t % (2 * Math.PI))) / Math.PI;
  }
  function Hu(t) {
    return ((t % 360) * Math.PI) / 180;
  }
  function Zu(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'kilometers',
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'kilometers';
    if (!(t >= 0)) throw new Error('length must be a positive number');
    return Yu(zu(t, e), n);
  }
  function Ju(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'meters',
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 'kilometers';
    if (!(t >= 0)) throw new Error('area must be a positive number');
    var r = Nu[e];
    if (!r) throw new Error('invalid original units');
    var i = Nu[n];
    if (!i) throw new Error('invalid final units');
    return (t / r) * i;
  }
  function $u(t) {
    return !isNaN(t) && null !== t && !Array.isArray(t);
  }
  function Qu(t) {
    return null !== t && 'object' === e(t) && !Array.isArray(t);
  }
  function Ku(t) {
    if (!t) throw new Error('bbox is required');
    if (!Array.isArray(t)) throw new Error('bbox must be an Array');
    if (4 !== t.length && 6 !== t.length) throw new Error('bbox must be an Array of 4 or 6 numbers');
    t.forEach(function (t) {
      if (!$u(t)) throw new Error('bbox must only contain numbers');
    });
  }
  function tl(t) {
    if (!t) throw new Error('id is required');
    if (-1 === ['string', 'number'].indexOf(e(t))) throw new Error('id must be a number or a string');
  }
  xu(Mu, 'feature'),
    xu(Ou, 'geometry'),
    xu(Lu, 'point'),
    xu(Ru, 'points'),
    xu(Cu, 'polygon'),
    xu(Tu, 'polygons'),
    xu(Au, 'lineString'),
    xu(Du, 'lineStrings'),
    xu(ju, 'featureCollection'),
    xu(Fu, 'multiLineString'),
    xu(Bu, 'multiPoint'),
    xu(qu, 'multiPolygon'),
    xu(Vu, 'geometryCollection'),
    xu(Gu, 'round'),
    xu(Yu, 'radiansToLength'),
    xu(zu, 'lengthToRadians'),
    xu(Uu, 'lengthToDegrees'),
    xu(Xu, 'bearingToAzimuth'),
    xu(Wu, 'radiansToDegrees'),
    xu(Hu, 'degreesToRadians'),
    xu(Zu, 'convertLength'),
    xu(Ju, 'convertArea'),
    xu($u, 'isNumber'),
    xu(Qu, 'isObject'),
    xu(Ku, 'validateBBox'),
    xu(tl, 'validateId');
  var el = Object.freeze({
      __proto__: null,
      GeojsonEquality: wu,
      areaFactors: Nu,
      bearingToAzimuth: Xu,
      convertArea: Ju,
      convertLength: Zu,
      degreesToRadians: Hu,
      earthRadius: Iu,
      factors: Pu,
      feature: Mu,
      featureCollection: ju,
      geometry: Ou,
      geometryCollection: Vu,
      isNumber: $u,
      isObject: Qu,
      lengthToDegrees: Uu,
      lengthToRadians: zu,
      lineString: Au,
      lineStrings: Du,
      multiLineString: Fu,
      multiPoint: Bu,
      multiPolygon: qu,
      point: Lu,
      points: Ru,
      polygon: Cu,
      polygons: Tu,
      radiansToDegrees: Wu,
      radiansToLength: Yu,
      round: Gu,
      validateBBox: Ku,
      validateId: tl,
    }),
    nl = Object.defineProperty,
    rl = function (t, e) {
      return nl(t, 'name', { value: e, configurable: !0 });
    };
  function il(t) {
    if (!t) throw new Error('coord is required');
    if (!Array.isArray(t)) {
      if ('Feature' === t.type && null !== t.geometry && 'Point' === t.geometry.type) return s(t.geometry.coordinates);
      if ('Point' === t.type) return s(t.coordinates);
    }
    if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1])) return s(t);
    throw new Error('coord must be GeoJSON Point or an Array of numbers');
  }
  function ol(t) {
    if (Array.isArray(t)) return t;
    if ('Feature' === t.type) {
      if (null !== t.geometry) return t.geometry.coordinates;
    } else if (t.coordinates) return t.coordinates;
    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');
  }
  function al(t) {
    if (t.length > 1 && $u(t[0]) && $u(t[1])) return !0;
    if (Array.isArray(t[0]) && t[0].length) return al(t[0]);
    throw new Error('coordinates must only contain numbers');
  }
  function sl(t, e, n) {
    if (!e || !n) throw new Error('type and name required');
    if (!t || t.type !== e) throw new Error('Invalid input to ' + n + ': must be a ' + e + ', given ' + t.type);
  }
  function ul(t, e, n) {
    if (!t) throw new Error('No feature passed');
    if (!n) throw new Error('.featureOf() requires a name');
    if (!t || 'Feature' !== t.type || !t.geometry)
      throw new Error('Invalid input to ' + n + ', Feature with geometry required');
    if (!t.geometry || t.geometry.type !== e)
      throw new Error('Invalid input to ' + n + ': must be a ' + e + ', given ' + t.geometry.type);
  }
  function ll(t, e, n) {
    if (!t) throw new Error('No featureCollection passed');
    if (!n) throw new Error('.collectionOf() requires a name');
    if (!t || 'FeatureCollection' !== t.type) throw new Error('Invalid input to ' + n + ', FeatureCollection required');
    var r,
      i = c(t.features);
    try {
      for (i.s(); !(r = i.n()).done; ) {
        var o = r.value;
        if (!o || 'Feature' !== o.type || !o.geometry)
          throw new Error('Invalid input to ' + n + ', Feature with geometry required');
        if (!o.geometry || o.geometry.type !== e)
          throw new Error('Invalid input to ' + n + ': must be a ' + e + ', given ' + o.geometry.type);
      }
    } catch (t) {
      i.e(t);
    } finally {
      i.f();
    }
  }
  function cl(t) {
    return 'Feature' === t.type ? t.geometry : t;
  }
  function hl(t, e) {
    return 'FeatureCollection' === t.type
      ? 'FeatureCollection'
      : 'GeometryCollection' === t.type
      ? 'GeometryCollection'
      : 'Feature' === t.type && null !== t.geometry
      ? t.geometry.type
      : t.type;
  }
  rl(il, 'getCoord'),
    rl(ol, 'getCoords'),
    rl(al, 'containsNumber'),
    rl(sl, 'geojsonType'),
    rl(ul, 'featureOf'),
    rl(ll, 'collectionOf'),
    rl(cl, 'getGeom'),
    rl(hl, 'getType');
  var fl = Object.freeze({
      __proto__: null,
      collectionOf: ll,
      containsNumber: al,
      featureOf: ul,
      geojsonType: sl,
      getCoord: il,
      getCoords: ol,
      getGeom: cl,
      getType: hl,
    }),
    pl = Object.defineProperty,
    gl = function (t, e) {
      return pl(t, 'name', { value: e, configurable: !0 });
    };
  function yl(t, e) {
    if (!0 === (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).final) return vl(t, e);
    var n = il(t),
      r = il(e),
      i = Hu(n[0]),
      o = Hu(r[0]),
      a = Hu(n[1]),
      s = Hu(r[1]),
      u = Math.sin(o - i) * Math.cos(s),
      l = Math.cos(a) * Math.sin(s) - Math.sin(a) * Math.cos(s) * Math.cos(o - i);
    return Wu(Math.atan2(u, l));
  }
  function vl(t, e) {
    var n = yl(e, t);
    return (n = (n + 180) % 360);
  }
  gl(yl, 'bearing'), gl(vl, 'calculateFinalBearing');
  function dl(t, e, n) {
    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
      i = il(t),
      o = Hu(i[0]),
      a = Hu(i[1]),
      s = Hu(n),
      u = zu(e, r.units),
      l = Math.asin(Math.sin(a) * Math.cos(u) + Math.cos(a) * Math.sin(u) * Math.cos(s));
    return Lu(
      [Wu(o + Math.atan2(Math.sin(s) * Math.sin(u) * Math.cos(a), Math.cos(u) - Math.sin(a) * Math.sin(l))), Wu(l)],
      r.properties,
    );
  }
  (0, Object.defineProperty)(dl, 'name', { value: 'destination', configurable: !0 });
  var ml = Object.defineProperty;
  function _l(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      r = il(t),
      i = il(e),
      o = Hu(i[1] - r[1]),
      a = Hu(i[0] - r[0]),
      s = Hu(r[1]),
      u = Hu(i[1]),
      l = Math.pow(Math.sin(o / 2), 2) + Math.pow(Math.sin(a / 2), 2) * Math.cos(s) * Math.cos(u);
    return Yu(2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)), n.units);
  }
  !(function (t, e) {
    ml(t, 'name', { value: e, configurable: !0 });
  })(_l, 'distance');
  var bl = Object.defineProperty;
  function xl(t, e) {
    for (
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = cl(t).coordinates, i = 0, o = 0;
      o < r.length && !(e >= i && o === r.length - 1);
      o++
    ) {
      if (i >= e) {
        var a = e - i;
        if (a) {
          var s = yl(r[o], r[o - 1]) - 180;
          return dl(r[o], a, s, n);
        }
        return Lu(r[o]);
      }
      i += _l(r[o], r[o + 1], n);
    }
    return Lu(r[r.length - 1]);
  }
  !(function (t, e) {
    bl(t, 'name', { value: e, configurable: !0 });
  })(xl, 'along');
  var El = Object.defineProperty,
    wl = function (t, e) {
      return El(t, 'name', { value: e, configurable: !0 });
    };
  function kl(t, e) {
    var n;
    return (n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).final
      ? Sl(il(e), il(t))
      : Sl(il(t), il(e))) > 180
      ? -(360 - n)
      : n;
  }
  function Sl(t, e) {
    var n = Hu(t[1]),
      r = Hu(e[1]),
      i = Hu(e[0] - t[0]);
    i > Math.PI && (i -= 2 * Math.PI), i < -Math.PI && (i += 2 * Math.PI);
    var o = Math.log(Math.tan(r / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4));
    return (Wu(Math.atan2(i, o)) + 360) % 360;
  }
  wl(kl, 'rhumbBearing'), wl(Sl, 'calculateRhumbBearing');
  var Il = Object.defineProperty;
  function Pl(t, e, n) {
    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    if (!Qu(r)) throw new Error('options is invalid');
    if (!t) throw new Error('startPoint is required');
    if (!e) throw new Error('midPoint is required');
    if (!n) throw new Error('endPoint is required');
    var i = t,
      o = e,
      a = n,
      s = Xu(!0 !== r.mercator ? yl(i, o) : kl(i, o)),
      u = Xu(!0 !== r.mercator ? yl(a, o) : kl(a, o)),
      l = Math.abs(s - u);
    return !0 === r.explementary ? 360 - l : l;
  }
  !(function (t, e) {
    Il(t, 'name', { value: e, configurable: !0 });
  })(Pl, 'angle');
  var Nl = Object.defineProperty,
    Ml = function (t, e) {
      return Nl(t, 'name', { value: e, configurable: !0 });
    };
  function Ol(t, e, n) {
    if (null !== t)
      for (
        var r,
          i,
          o,
          a,
          s,
          u,
          l,
          c,
          h = 0,
          f = 0,
          p = t.type,
          g = 'FeatureCollection' === p,
          y = 'Feature' === p,
          v = g ? t.features.length : 1,
          d = 0;
        d < v;
        d++
      ) {
        s = (c = !!(l = g ? t.features[d].geometry : y ? t.geometry : t) && 'GeometryCollection' === l.type)
          ? l.geometries.length
          : 1;
        for (var m = 0; m < s; m++) {
          var _ = 0,
            b = 0;
          if (null !== (a = c ? l.geometries[m] : l)) {
            u = a.coordinates;
            var x = a.type;
            switch (((h = !n || ('Polygon' !== x && 'MultiPolygon' !== x) ? 0 : 1), x)) {
              case null:
                break;
              case 'Point':
                if (!1 === e(u, f, d, _, b)) return !1;
                f++, _++;
                break;
              case 'LineString':
              case 'MultiPoint':
                for (r = 0; r < u.length; r++) {
                  if (!1 === e(u[r], f, d, _, b)) return !1;
                  f++, 'MultiPoint' === x && _++;
                }
                'LineString' === x && _++;
                break;
              case 'Polygon':
              case 'MultiLineString':
                for (r = 0; r < u.length; r++) {
                  for (i = 0; i < u[r].length - h; i++) {
                    if (!1 === e(u[r][i], f, d, _, b)) return !1;
                    f++;
                  }
                  'MultiLineString' === x && _++, 'Polygon' === x && b++;
                }
                'Polygon' === x && _++;
                break;
              case 'MultiPolygon':
                for (r = 0; r < u.length; r++) {
                  for (b = 0, i = 0; i < u[r].length; i++) {
                    for (o = 0; o < u[r][i].length - h; o++) {
                      if (!1 === e(u[r][i][o], f, d, _, b)) return !1;
                      f++;
                    }
                    b++;
                  }
                  _++;
                }
                break;
              case 'GeometryCollection':
                for (r = 0; r < a.geometries.length; r++) if (!1 === Ol(a.geometries[r], e, n)) return !1;
                break;
              default:
                throw new Error('Unknown Geometry Type');
            }
          }
        }
      }
  }
  function Ll(t, e, n, r) {
    var i = n;
    return (
      Ol(
        t,
        function (t, r, o, a, s) {
          i = 0 === r && void 0 === n ? t : e(i, t, r, o, a, s);
        },
        r,
      ),
      i
    );
  }
  function Rl(t, e) {
    var n;
    switch (t.type) {
      case 'FeatureCollection':
        for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++);
        break;
      case 'Feature':
        e(t.properties, 0);
    }
  }
  function Cl(t, e, n) {
    var r = n;
    return (
      Rl(t, function (t, i) {
        r = 0 === i && void 0 === n ? t : e(r, t, i);
      }),
      r
    );
  }
  function Tl(t, e) {
    if ('Feature' === t.type) e(t, 0);
    else if ('FeatureCollection' === t.type) for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++);
  }
  function Al(t, e, n) {
    var r = n;
    return (
      Tl(t, function (t, i) {
        r = 0 === i && void 0 === n ? t : e(r, t, i);
      }),
      r
    );
  }
  function Dl(t) {
    var e = [];
    return (
      Ol(t, function (t) {
        e.push(t);
      }),
      e
    );
  }
  function jl(t, e) {
    var n,
      r,
      i,
      o,
      a,
      s,
      u,
      l,
      c,
      h,
      f = 0,
      p = 'FeatureCollection' === t.type,
      g = 'Feature' === t.type,
      y = p ? t.features.length : 1;
    for (n = 0; n < y; n++) {
      for (
        s = p ? t.features[n].geometry : g ? t.geometry : t,
          l = p ? t.features[n].properties : g ? t.properties : {},
          c = p ? t.features[n].bbox : g ? t.bbox : void 0,
          h = p ? t.features[n].id : g ? t.id : void 0,
          a = (u = !!s && 'GeometryCollection' === s.type) ? s.geometries.length : 1,
          i = 0;
        i < a;
        i++
      )
        if (null !== (o = u ? s.geometries[i] : s))
          switch (o.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon':
              if (!1 === e(o, f, l, c, h)) return !1;
              break;
            case 'GeometryCollection':
              for (r = 0; r < o.geometries.length; r++) if (!1 === e(o.geometries[r], f, l, c, h)) return !1;
              break;
            default:
              throw new Error('Unknown Geometry Type');
          }
        else if (!1 === e(null, f, l, c, h)) return !1;
      f++;
    }
  }
  function Fl(t, e, n) {
    var r = n;
    return (
      jl(t, function (t, i, o, a, s) {
        r = 0 === i && void 0 === n ? t : e(r, t, i, o, a, s);
      }),
      r
    );
  }
  function Bl(t, e) {
    jl(t, function (t, n, r, i, o) {
      var a,
        s = null === t ? null : t.type;
      switch (s) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
          return !1 !== e(Mu(t, r, { bbox: i, id: o }), n, 0) && void 0;
      }
      switch (s) {
        case 'MultiPoint':
          a = 'Point';
          break;
        case 'MultiLineString':
          a = 'LineString';
          break;
        case 'MultiPolygon':
          a = 'Polygon';
      }
      for (var u = 0; u < t.coordinates.length; u++) {
        var l = t.coordinates[u];
        if (!1 === e(Mu({ type: a, coordinates: l }, r), n, u)) return !1;
      }
    });
  }
  function ql(t, e, n) {
    var r = n;
    return (
      Bl(t, function (t, i, o) {
        r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o);
      }),
      r
    );
  }
  function Vl(t, e) {
    Bl(t, function (t, n, r) {
      var i = 0;
      if (t.geometry) {
        var o = t.geometry.type;
        if ('Point' !== o && 'MultiPoint' !== o) {
          var a,
            s = 0,
            u = 0,
            l = 0;
          return (
            !1 !==
              Ol(t, function (o, c, h, f, p) {
                if (void 0 === a || n > s || f > u || p > l) return (a = o), (s = n), (u = f), (l = p), void (i = 0);
                var g = Au([a, o], t.properties);
                if (!1 === e(g, n, r, p, i)) return !1;
                i++, (a = o);
              }) && void 0
          );
        }
      }
    });
  }
  function Gl(t, e, n) {
    var r = n,
      i = !1;
    return (
      Vl(t, function (t, o, a, s, u) {
        (r = !1 === i && void 0 === n ? t : e(r, t, o, a, s, u)), (i = !0);
      }),
      r
    );
  }
  function Yl(t, e) {
    if (!t) throw new Error('geojson is required');
    Bl(t, function (t, n, r) {
      if (null !== t.geometry) {
        var i = t.geometry.type,
          o = t.geometry.coordinates;
        switch (i) {
          case 'LineString':
            if (!1 === e(t, n, r, 0, 0)) return !1;
            break;
          case 'Polygon':
            for (var a = 0; a < o.length; a++) if (!1 === e(Au(o[a], t.properties), n, r, a)) return !1;
        }
      }
    });
  }
  function zl(t, e, n) {
    var r = n;
    return (
      Yl(t, function (t, i, o, a) {
        r = 0 === i && void 0 === n ? t : e(r, t, i, o, a);
      }),
      r
    );
  }
  function Ul(t, e) {
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n,
      r = e.featureIndex || 0,
      i = e.multiFeatureIndex || 0,
      o = e.geometryIndex || 0,
      a = e.segmentIndex || 0,
      s = e.properties;
    switch (t.type) {
      case 'FeatureCollection':
        r < 0 && (r = t.features.length + r), (s = s || t.features[r].properties), (n = t.features[r].geometry);
        break;
      case 'Feature':
        (s = s || t.properties), (n = t.geometry);
        break;
      case 'Point':
      case 'MultiPoint':
        return null;
      case 'LineString':
      case 'Polygon':
      case 'MultiLineString':
      case 'MultiPolygon':
        n = t;
        break;
      default:
        throw new Error('geojson is invalid');
    }
    if (null === n) return null;
    var u = n.coordinates;
    switch (n.type) {
      case 'Point':
      case 'MultiPoint':
        return null;
      case 'LineString':
        return a < 0 && (a = u.length + a - 1), Au([u[a], u[a + 1]], s, e);
      case 'Polygon':
        return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), Au([u[o][a], u[o][a + 1]], s, e);
      case 'MultiLineString':
        return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), Au([u[i][a], u[i][a + 1]], s, e);
      case 'MultiPolygon':
        return (
          i < 0 && (i = u.length + i),
          o < 0 && (o = u[i].length + o),
          a < 0 && (a = u[i][o].length - a - 1),
          Au([u[i][o][a], u[i][o][a + 1]], s, e)
        );
    }
    throw new Error('geojson is invalid');
  }
  function Xl(t, e) {
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n,
      r = e.featureIndex || 0,
      i = e.multiFeatureIndex || 0,
      o = e.geometryIndex || 0,
      a = e.coordIndex || 0,
      s = e.properties;
    switch (t.type) {
      case 'FeatureCollection':
        r < 0 && (r = t.features.length + r), (s = s || t.features[r].properties), (n = t.features[r].geometry);
        break;
      case 'Feature':
        (s = s || t.properties), (n = t.geometry);
        break;
      case 'Point':
      case 'MultiPoint':
        return null;
      case 'LineString':
      case 'Polygon':
      case 'MultiLineString':
      case 'MultiPolygon':
        n = t;
        break;
      default:
        throw new Error('geojson is invalid');
    }
    if (null === n) return null;
    var u = n.coordinates;
    switch (n.type) {
      case 'Point':
        return Lu(u, s, e);
      case 'MultiPoint':
        return i < 0 && (i = u.length + i), Lu(u[i], s, e);
      case 'LineString':
        return a < 0 && (a = u.length + a), Lu(u[a], s, e);
      case 'Polygon':
        return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), Lu(u[o][a], s, e);
      case 'MultiLineString':
        return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), Lu(u[i][a], s, e);
      case 'MultiPolygon':
        return (
          i < 0 && (i = u.length + i),
          o < 0 && (o = u[i].length + o),
          a < 0 && (a = u[i][o].length - a),
          Lu(u[i][o][a], s, e)
        );
    }
    throw new Error('geojson is invalid');
  }
  Ml(Ol, 'coordEach'),
    Ml(Ll, 'coordReduce'),
    Ml(Rl, 'propEach'),
    Ml(Cl, 'propReduce'),
    Ml(Tl, 'featureEach'),
    Ml(Al, 'featureReduce'),
    Ml(Dl, 'coordAll'),
    Ml(jl, 'geomEach'),
    Ml(Fl, 'geomReduce'),
    Ml(Bl, 'flattenEach'),
    Ml(ql, 'flattenReduce'),
    Ml(Vl, 'segmentEach'),
    Ml(Gl, 'segmentReduce'),
    Ml(Yl, 'lineEach'),
    Ml(zl, 'lineReduce'),
    Ml(Ul, 'findSegment'),
    Ml(Xl, 'findPoint');
  var Wl = Object.freeze({
      __proto__: null,
      coordAll: Dl,
      coordEach: Ol,
      coordReduce: Ll,
      featureEach: Tl,
      featureReduce: Al,
      findPoint: Xl,
      findSegment: Ul,
      flattenEach: Bl,
      flattenReduce: ql,
      geomEach: jl,
      geomReduce: Fl,
      lineEach: Yl,
      lineReduce: zl,
      propEach: Rl,
      propReduce: Cl,
      segmentEach: Vl,
      segmentReduce: Gl,
    }),
    Hl = Object.defineProperty,
    Zl = function (t, e) {
      return Hl(t, 'name', { value: e, configurable: !0 });
    };
  function Jl(t) {
    return Fl(
      t,
      function (t, e) {
        return t + $l(e);
      },
      0,
    );
  }
  function $l(t) {
    var e,
      n = 0;
    switch (t.type) {
      case 'Polygon':
        return Ql(t.coordinates);
      case 'MultiPolygon':
        for (e = 0; e < t.coordinates.length; e++) n += Ql(t.coordinates[e]);
        return n;
      case 'Point':
      case 'MultiPoint':
      case 'LineString':
      case 'MultiLineString':
        return 0;
    }
    return 0;
  }
  function Ql(t) {
    var e = 0;
    if (t && t.length > 0) {
      e += Math.abs(ec(t[0]));
      for (var n = 1; n < t.length; n++) e -= Math.abs(ec(t[n]));
    }
    return e;
  }
  Zl(Jl, 'area'), Zl($l, 'calculateArea'), Zl(Ql, 'polygonArea');
  var Kl = (Iu * Iu) / 2,
    tc = Math.PI / 180;
  function ec(t) {
    var e = t.length;
    if (e <= 2) return 0;
    for (var n = 0, r = 0; r < e; ) {
      var i = t[r],
        o = t[r + 1 === e ? 0 : r + 1],
        a = t[r + 2 >= e ? (r + 2) % e : r + 2],
        s = i[0] * tc,
        u = o[1] * tc;
      (n += (a[0] * tc - s) * Math.sin(u)), r++;
    }
    return n * Kl;
  }
  Zl(ec, 'ringArea');
  var nc = Object.defineProperty;
  function rc(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (null != t.bbox && !0 !== e.recompute) return t.bbox;
    var n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    return (
      Ol(t, function (t) {
        n[0] > t[0] && (n[0] = t[0]),
          n[1] > t[1] && (n[1] = t[1]),
          n[2] < t[0] && (n[2] = t[0]),
          n[3] < t[1] && (n[3] = t[1]);
      }),
      n
    );
  }
  !(function (t, e) {
    nc(t, 'name', { value: e, configurable: !0 });
  })(rc, 'bbox');
  var ic = Object.defineProperty,
    oc = function (t, e) {
      return ic(t, 'name', { value: e, configurable: !0 });
    };
  function ac(t, e, n) {
    var r,
      i,
      o,
      a,
      s,
      u = t.length,
      l = lc(t[0], e),
      c = [];
    for (n || (n = []), r = 1; r < u; r++) {
      for (a = t[r - 1], i = o = lc((s = t[r]), e); ; ) {
        if (!(l | i)) {
          c.push(a), i !== o ? (c.push(s), r < u - 1 && (n.push(c), (c = []))) : r === u - 1 && c.push(s);
          break;
        }
        if (l & i) break;
        l ? (l = lc((a = uc(a, s, l, e)), e)) : (i = lc((s = uc(a, s, i, e)), e));
      }
      l = o;
    }
    return c.length && n.push(c), n;
  }
  function sc(t, e) {
    var n, r, i, o, a, s, u;
    for (r = 1; r <= 8; r *= 2) {
      for (n = [], o = !(lc((i = t[t.length - 1]), e) & r), a = 0; a < t.length; a++)
        (u = !(lc((s = t[a]), e) & r)) !== o && n.push(uc(i, s, r, e)), u && n.push(s), (i = s), (o = u);
      if (!(t = n).length) break;
    }
    return n;
  }
  function uc(t, e, n, r) {
    return 8 & n
      ? [t[0] + ((e[0] - t[0]) * (r[3] - t[1])) / (e[1] - t[1]), r[3]]
      : 4 & n
      ? [t[0] + ((e[0] - t[0]) * (r[1] - t[1])) / (e[1] - t[1]), r[1]]
      : 2 & n
      ? [r[2], t[1] + ((e[1] - t[1]) * (r[2] - t[0])) / (e[0] - t[0])]
      : 1 & n
      ? [r[0], t[1] + ((e[1] - t[1]) * (r[0] - t[0])) / (e[0] - t[0])]
      : null;
  }
  function lc(t, e) {
    var n = 0;
    return t[0] < e[0] ? (n |= 1) : t[0] > e[2] && (n |= 2), t[1] < e[1] ? (n |= 4) : t[1] > e[3] && (n |= 8), n;
  }
  function cc(t, e) {
    var n = cl(t),
      r = n.type,
      i = 'Feature' === t.type ? t.properties : {},
      o = n.coordinates;
    switch (r) {
      case 'LineString':
      case 'MultiLineString':
        var a = [];
        return (
          'LineString' === r && (o = [o]),
          o.forEach(function (t) {
            ac(t, e, a);
          }),
          1 === a.length ? Au(a[0], i) : Fu(a, i)
        );
      case 'Polygon':
        return Cu(hc(o, e), i);
      case 'MultiPolygon':
        return qu(
          o.map(function (t) {
            return hc(t, e);
          }),
          i,
        );
      default:
        throw new Error('geometry ' + r + ' not supported');
    }
  }
  function hc(t, e) {
    var n,
      r = [],
      i = c(t);
    try {
      for (i.s(); !(n = i.n()).done; ) {
        var o = sc(n.value, e);
        o.length > 0 &&
          ((o[0][0] === o[o.length - 1][0] && o[0][1] === o[o.length - 1][1]) || o.push(o[0]),
          o.length >= 4 && r.push(o));
      }
    } catch (t) {
      i.e(t);
    } finally {
      i.f();
    }
    return r;
  }
  oc(ac, 'lineclip'),
    oc(sc, 'polygonclip'),
    oc(uc, 'intersect'),
    oc(lc, 'bitCode'),
    oc(cc, 'bboxClip'),
    oc(hc, 'clipPolygon');
  var fc = Object.defineProperty;
  function pc(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = Number(t[0]),
      r = Number(t[1]),
      i = Number(t[2]),
      o = Number(t[3]);
    if (6 === t.length) throw new Error('@turf/bbox-polygon does not support BBox with 6 positions');
    var a = [n, r];
    return Cu([[a, [i, r], [i, o], [n, o], a]], e.properties, { bbox: t, id: e.id });
  }
  !(function (t, e) {
    fc(t, 'name', { value: e, configurable: !0 });
  })(pc, 'bboxPolygon');
  var gc = Object.defineProperty,
    yc = function (t, e) {
      return gc(t, 'name', { value: e, configurable: !0 });
    },
    vc = (function () {
      function t(e) {
        n(this, t),
          (this.points = e.points || []),
          (this.duration = e.duration || 1e4),
          (this.sharpness = e.sharpness || 0.85),
          (this.centers = []),
          (this.controls = []),
          (this.stepLength = e.stepLength || 60),
          (this.length = this.points.length),
          (this.delay = 0);
        for (var r = 0; r < this.length; r++) this.points[r].z = this.points[r].z || 0;
        for (var i = 0; i < this.length - 1; i++) {
          var o = this.points[i],
            a = this.points[i + 1];
          this.centers.push({ x: (o.x + a.x) / 2, y: (o.y + a.y) / 2, z: (o.z + a.z) / 2 });
        }
        this.controls.push([this.points[0], this.points[0]]);
        for (var s = 0; s < this.centers.length - 1; s++) {
          var u = this.points[s + 1].x - (this.centers[s].x + this.centers[s + 1].x) / 2,
            l = this.points[s + 1].y - (this.centers[s].y + this.centers[s + 1].y) / 2,
            c = this.points[s + 1].z - (this.centers[s].y + this.centers[s + 1].z) / 2;
          this.controls.push([
            {
              x: (1 - this.sharpness) * this.points[s + 1].x + this.sharpness * (this.centers[s].x + u),
              y: (1 - this.sharpness) * this.points[s + 1].y + this.sharpness * (this.centers[s].y + l),
              z: (1 - this.sharpness) * this.points[s + 1].z + this.sharpness * (this.centers[s].z + c),
            },
            {
              x: (1 - this.sharpness) * this.points[s + 1].x + this.sharpness * (this.centers[s + 1].x + u),
              y: (1 - this.sharpness) * this.points[s + 1].y + this.sharpness * (this.centers[s + 1].y + l),
              z: (1 - this.sharpness) * this.points[s + 1].z + this.sharpness * (this.centers[s + 1].z + c),
            },
          ]);
        }
        return (
          this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]),
          (this.steps = this.cacheSteps(this.stepLength)),
          this
        );
      }
      return (
        i(t, [
          {
            key: 'cacheSteps',
            value: function (t) {
              var e = [],
                n = this.pos(0);
              e.push(0);
              for (var r = 0; r < this.duration; r += 10) {
                var i = this.pos(r);
                Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y) + (i.z - n.z) * (i.z - n.z)) > t &&
                  (e.push(r), (n = i));
              }
              return e;
            },
          },
          {
            key: 'vector',
            value: function (t) {
              var e = this.pos(t + 10),
                n = this.pos(t - 10);
              return {
                angle: (180 * Math.atan2(e.y - n.y, e.x - n.x)) / 3.14,
                speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z)),
              };
            },
          },
          {
            key: 'pos',
            value: function (t) {
              var e = t - this.delay;
              e < 0 && (e = 0), e > this.duration && (e = this.duration - 1);
              var n = e / this.duration;
              if (n >= 1) return this.points[this.length - 1];
              var r = Math.floor((this.points.length - 1) * n);
              return mc(
                (this.length - 1) * n - r,
                this.points[r],
                this.controls[r][1],
                this.controls[r + 1][0],
                this.points[r + 1],
              );
            },
          },
        ]),
        t
      );
    })();
  yc(vc, 'Spline');
  var dc = vc;
  function mc(t, e, n, r, i) {
    var o = _c(t);
    return {
      x: i.x * o[0] + r.x * o[1] + n.x * o[2] + e.x * o[3],
      y: i.y * o[0] + r.y * o[1] + n.y * o[2] + e.y * o[3],
      z: i.z * o[0] + r.z * o[1] + n.z * o[2] + e.z * o[3],
    };
  }
  function _c(t) {
    var e = t * t;
    return [e * t, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)];
  }
  function bc(t) {
    for (
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        n = e.resolution || 1e4,
        r = e.sharpness || 0.85,
        i = [],
        o = cl(t).coordinates.map(function (t) {
          return { x: t[0], y: t[1] };
        }),
        a = new dc({ duration: n, points: o, sharpness: r }),
        s = yc(function (t) {
          var e = a.pos(t);
          Math.floor(t / 100) % 2 == 0 && i.push([e.x, e.y]);
        }, 'pushCoord'),
        u = 0;
      u < a.duration;
      u += 10
    )
      s(u);
    return s(a.duration), Au(i, e.properties);
  }
  yc(mc, 'bezier'), yc(_c, 'B'), yc(bc, 'bezierSpline');
  var xc = Object.defineProperty;
  function Ec(t) {
    for (var e, n, r = ol(t), i = 0, o = 1; o < r.length; )
      (e = n || r[0]), (i += ((n = r[o])[0] - e[0]) * (n[1] + e[1])), o++;
    return i > 0;
  }
  !(function (t, e) {
    xc(t, 'name', { value: e, configurable: !0 });
  })(Ec, 'booleanClockwise');
  var wc = Object.defineProperty;
  function kc(t) {
    var e = cl(t).coordinates;
    if (e[0].length <= 4) return !1;
    for (var n = !1, r = e[0].length - 1, i = 0; i < r; i++) {
      var o = e[0][(i + 2) % r][0] - e[0][(i + 1) % r][0],
        a = e[0][(i + 2) % r][1] - e[0][(i + 1) % r][1],
        s = e[0][i][0] - e[0][(i + 1) % r][0],
        u = o * (e[0][i][1] - e[0][(i + 1) % r][1]) - a * s;
      if (0 === i) n = u > 0;
      else if (n !== u > 0) return !0;
    }
    return !1;
  }
  function Sc(t, e) {
    for (
      var n = 0, r = 0, i = 0, o = 0, a = 0, s = 0, u = 0, l = 0, c = null, h = null, f = t[0], p = t[1], g = e.length;
      n < g;
      n++
    ) {
      r = 0;
      var y = e[n].length - 1,
        v = e[n];
      if ((c = v[0])[0] !== v[y][0] && c[1] !== v[y][1])
        throw new Error('First and last coordinates in a ring must be the same');
      for (a = c[0] - f, s = c[1] - p; r < y; r++)
        if (((l = (h = v[r + 1])[1] - p), (s < 0 && l < 0) || (s > 0 && l > 0))) (s = l), (a = (c = h)[0] - f);
        else {
          if (((u = h[0] - t[0]), l > 0 && s <= 0)) {
            if ((o = a * l - u * s) > 0) i += 1;
            else if (0 === o) return 0;
          } else if (s > 0 && l <= 0) {
            if ((o = a * l - u * s) < 0) i += 1;
            else if (0 === o) return 0;
          } else if (0 === l && s < 0) {
            if (0 === (o = a * l - u * s)) return 0;
          } else if (0 === s && l < 0) {
            if (0 === (o = a * l - u * s)) return 0;
          } else if (0 === s && 0 === l) {
            if (u <= 0 && a >= 0) return 0;
            if (a <= 0 && u >= 0) return 0;
          }
          (c = h), (s = l), (a = u);
        }
    }
    return i % 2 != 0;
  }
  !(function (t, e) {
    wc(t, 'name', { value: e, configurable: !0 });
  })(kc, 'booleanConcave');
  var Ic = Object.defineProperty,
    Pc = function (t, e) {
      return Ic(t, 'name', { value: e, configurable: !0 });
    };
  function Nc(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (!t) throw new Error('point is required');
    if (!e) throw new Error('polygon is required');
    var r = il(t),
      i = cl(e),
      o = i.type,
      a = e.bbox,
      s = i.coordinates;
    if (a && !1 === Mc(r, a)) return !1;
    'Polygon' === o && (s = [s]);
    for (var u = !1, l = 0; l < s.length; ++l) {
      var c = Sc(r, s[l]);
      if (0 === c) return !n.ignoreBoundary;
      c && (u = !0);
    }
    return u;
  }
  function Mc(t, e) {
    return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1];
  }
  Pc(Nc, 'booleanPointInPolygon'), Pc(Mc, 'inBBox');
  var Oc = Object.defineProperty,
    Lc = function (t, e) {
      return Oc(t, 'name', { value: e, configurable: !0 });
    };
  function Rc(t, e) {
    for (
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = il(t), i = ol(e), o = 0;
      o < i.length - 1;
      o++
    ) {
      var a = !1;
      if (
        (n.ignoreEndVertices &&
          (0 === o && (a = 'start'),
          o === i.length - 2 && (a = 'end'),
          0 === o && o + 1 === i.length - 1 && (a = 'both')),
        Cc(i[o], i[o + 1], r, a, void 0 === n.epsilon ? null : n.epsilon))
      )
        return !0;
    }
    return !1;
  }
  function Cc(t, e, n, r, i) {
    var o = n[0],
      a = n[1],
      s = t[0],
      u = t[1],
      l = e[0],
      c = e[1],
      h = l - s,
      f = c - u,
      p = (n[0] - s) * f - (n[1] - u) * h;
    if (null !== i) {
      if (Math.abs(p) > i) return !1;
    } else if (0 !== p) return !1;
    return r
      ? 'start' === r
        ? Math.abs(h) >= Math.abs(f)
          ? h > 0
            ? s < o && o <= l
            : l <= o && o < s
          : f > 0
          ? u < a && a <= c
          : c <= a && a < u
        : 'end' === r
        ? Math.abs(h) >= Math.abs(f)
          ? h > 0
            ? s <= o && o < l
            : l < o && o <= s
          : f > 0
          ? u <= a && a < c
          : c < a && a <= u
        : 'both' === r &&
          (Math.abs(h) >= Math.abs(f)
            ? h > 0
              ? s < o && o < l
              : l < o && o < s
            : f > 0
            ? u < a && a < c
            : c < a && a < u)
      : Math.abs(h) >= Math.abs(f)
      ? h > 0
        ? s <= o && o <= l
        : l <= o && o <= s
      : f > 0
      ? u <= a && a <= c
      : c <= a && a <= u;
  }
  Lc(Rc, 'booleanPointOnLine'), Lc(Cc, 'isPointOnLineSegment');
  var Tc = Object.defineProperty,
    Ac = function (t, e) {
      return Tc(t, 'name', { value: e, configurable: !0 });
    };
  function Dc(t, e) {
    var n = cl(t),
      r = cl(e),
      i = n.type,
      o = r.type,
      a = n.coordinates,
      s = r.coordinates;
    switch (i) {
      case 'Point':
        if ('Point' === o) return Xc(a, s);
        throw new Error('feature2 ' + o + ' geometry not supported');
      case 'MultiPoint':
        switch (o) {
          case 'Point':
            return Fc(n, r);
          case 'MultiPoint':
            return Bc(n, r);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'LineString':
        switch (o) {
          case 'Point':
            return Rc(r, n, { ignoreEndVertices: !0 });
          case 'LineString':
            return Gc(n, r);
          case 'MultiPoint':
            return qc(n, r);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'Polygon':
        switch (o) {
          case 'Point':
            return Nc(r, n, { ignoreBoundary: !0 });
          case 'LineString':
            return Yc(n, r);
          case 'Polygon':
            return zc(n, r);
          case 'MultiPoint':
            return Vc(n, r);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'MultiPolygon':
        if ('Polygon' === o) return jc(n, r);
        throw new Error('feature2 ' + o + ' geometry not supported');
      default:
        throw new Error('feature1 ' + i + ' geometry not supported');
    }
  }
  function jc(t, e) {
    return t.coordinates.some(function (t) {
      return zc({ type: 'Polygon', coordinates: t }, e);
    });
  }
  function Fc(t, e) {
    var n,
      r = !1;
    for (n = 0; n < t.coordinates.length; n++)
      if (Xc(t.coordinates[n], e.coordinates)) {
        r = !0;
        break;
      }
    return r;
  }
  function Bc(t, e) {
    var n,
      r = c(e.coordinates);
    try {
      for (r.s(); !(n = r.n()).done; ) {
        var i,
          o = n.value,
          a = !1,
          s = c(t.coordinates);
        try {
          for (s.s(); !(i = s.n()).done; ) {
            if (Xc(o, i.value)) {
              a = !0;
              break;
            }
          }
        } catch (t) {
          s.e(t);
        } finally {
          s.f();
        }
        if (!a) return !1;
      }
    } catch (t) {
      r.e(t);
    } finally {
      r.f();
    }
    return !0;
  }
  function qc(t, e) {
    var n,
      r = !1,
      i = c(e.coordinates);
    try {
      for (i.s(); !(n = i.n()).done; ) {
        var o = n.value;
        if ((Rc(o, t, { ignoreEndVertices: !0 }) && (r = !0), !Rc(o, t))) return !1;
      }
    } catch (t) {
      i.e(t);
    } finally {
      i.f();
    }
    return !!r;
  }
  function Vc(t, e) {
    var n,
      r = c(e.coordinates);
    try {
      for (r.s(); !(n = r.n()).done; ) {
        if (!Nc(n.value, t, { ignoreBoundary: !0 })) return !1;
      }
    } catch (t) {
      r.e(t);
    } finally {
      r.f();
    }
    return !0;
  }
  function Gc(t, e) {
    var n,
      r = !1,
      i = c(e.coordinates);
    try {
      for (i.s(); !(n = i.n()).done; ) {
        var o = n.value;
        if (
          (Rc({ type: 'Point', coordinates: o }, t, { ignoreEndVertices: !0 }) && (r = !0),
          !Rc({ type: 'Point', coordinates: o }, t, { ignoreEndVertices: !1 }))
        )
          return !1;
      }
    } catch (t) {
      i.e(t);
    } finally {
      i.f();
    }
    return r;
  }
  function Yc(t, e) {
    var n = !1,
      r = 0;
    if (!Uc(rc(t), rc(e))) return !1;
    for (; r < e.coordinates.length - 1; r++) {
      if (Nc({ type: 'Point', coordinates: Wc(e.coordinates[r], e.coordinates[r + 1]) }, t, { ignoreBoundary: !0 })) {
        n = !0;
        break;
      }
    }
    return n;
  }
  function zc(t, e) {
    if ('Feature' === t.type && null === t.geometry) return !1;
    if ('Feature' === e.type && null === e.geometry) return !1;
    if (!Uc(rc(t), rc(e))) return !1;
    var n,
      r = c(cl(e).coordinates);
    try {
      for (r.s(); !(n = r.n()).done; ) {
        var i,
          o = c(n.value);
        try {
          for (o.s(); !(i = o.n()).done; ) {
            if (!Nc(i.value, t)) return !1;
          }
        } catch (t) {
          o.e(t);
        } finally {
          o.f();
        }
      }
    } catch (t) {
      r.e(t);
    } finally {
      r.f();
    }
    return !0;
  }
  function Uc(t, e) {
    return !(t[0] > e[0]) && !(t[2] < e[2]) && !(t[1] > e[1]) && !(t[3] < e[3]);
  }
  function Xc(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  function Wc(t, e) {
    return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2];
  }
  Ac(Dc, 'booleanContains'),
    Ac(jc, 'isPolygonInMultiPolygon'),
    Ac(Fc, 'isPointInMultiPoint'),
    Ac(Bc, 'isMultiPointInMultiPoint'),
    Ac(qc, 'isMultiPointOnLine'),
    Ac(Vc, 'isMultiPointInPoly'),
    Ac(Gc, 'isLineOnLine'),
    Ac(Yc, 'isLineInPoly'),
    Ac(zc, 'isPolyInPoly'),
    Ac(Uc, 'doBBoxOverlap'),
    Ac(Xc, 'compareCoords'),
    Ac(Wc, 'getMidpoint');
  var Hc = (function () {
    function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Zc;
      if ((n(this, t), (this.data = e), (this.length = this.data.length), (this.compare = r), this.length > 0))
        for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
    return (
      i(t, [
        {
          key: 'push',
          value: function (t) {
            this.data.push(t), this.length++, this._up(this.length - 1);
          },
        },
        {
          key: 'pop',
          value: function () {
            if (0 !== this.length) {
              var t = this.data[0],
                e = this.data.pop();
              return this.length--, this.length > 0 && ((this.data[0] = e), this._down(0)), t;
            }
          },
        },
        {
          key: 'peek',
          value: function () {
            return this.data[0];
          },
        },
        {
          key: '_up',
          value: function (t) {
            for (var e = this.data, n = this.compare, r = e[t]; t > 0; ) {
              var i = (t - 1) >> 1,
                o = e[i];
              if (n(r, o) >= 0) break;
              (e[t] = o), (t = i);
            }
            e[t] = r;
          },
        },
        {
          key: '_down',
          value: function (t) {
            for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r; ) {
              var o = 1 + (t << 1),
                a = e[o],
                s = o + 1;
              if ((s < this.length && n(e[s], a) < 0 && ((o = s), (a = e[s])), n(a, i) >= 0)) break;
              (e[t] = a), (t = o);
            }
            e[t] = i;
          },
        },
      ]),
      t
    );
  })();
  function Zc(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  function Jc(t, e) {
    return t.p.x > e.p.x ? 1 : t.p.x < e.p.x ? -1 : t.p.y !== e.p.y ? (t.p.y > e.p.y ? 1 : -1) : 1;
  }
  function $c(t, e) {
    return t.rightSweepEvent.p.x > e.rightSweepEvent.p.x
      ? 1
      : t.rightSweepEvent.p.x < e.rightSweepEvent.p.x
      ? -1
      : t.rightSweepEvent.p.y !== e.rightSweepEvent.p.y
      ? t.rightSweepEvent.p.y < e.rightSweepEvent.p.y
        ? 1
        : -1
      : 1;
  }
  var Qc = (function () {
    function t(e, r, i, o) {
      n(this, t),
        (this.p = { x: e[0], y: e[1] }),
        (this.featureId = r),
        (this.ringId = i),
        (this.eventId = o),
        (this.otherEvent = null),
        (this.isLeftEndpoint = null);
    }
    return (
      i(t, [
        {
          key: 'isSamePoint',
          value: function (t) {
            return this.p.x === t.p.x && this.p.y === t.p.y;
          },
        },
      ]),
      t
    );
  })();
  var Kc = 0,
    th = 0,
    eh = 0;
  function nh(t, e) {
    var n = 'Feature' === t.type ? t.geometry : t,
      r = n.coordinates;
    ('Polygon' !== n.type && 'MultiLineString' !== n.type) || (r = [r]), 'LineString' === n.type && (r = [[r]]);
    for (var i = 0; i < r.length; i++)
      for (var o = 0; o < r[i].length; o++) {
        var a = r[i][o][0],
          s = null;
        th += 1;
        for (var u = 0; u < r[i][o].length - 1; u++) {
          s = r[i][o][u + 1];
          var l = new Qc(a, Kc, th, eh),
            c = new Qc(s, Kc, th, eh + 1);
          (l.otherEvent = c),
            (c.otherEvent = l),
            Jc(l, c) > 0
              ? ((c.isLeftEndpoint = !0), (l.isLeftEndpoint = !1))
              : ((l.isLeftEndpoint = !0), (c.isLeftEndpoint = !1)),
            e.push(l),
            e.push(c),
            (a = s),
            (eh += 1);
        }
      }
    Kc += 1;
  }
  var rh = i(function t(e) {
    n(this, t), (this.leftSweepEvent = e), (this.rightSweepEvent = e.otherEvent);
  });
  function ih(t, e) {
    if (null === t || null === e) return !1;
    if (
      t.leftSweepEvent.ringId === e.leftSweepEvent.ringId &&
      (t.rightSweepEvent.isSamePoint(e.leftSweepEvent) ||
        t.rightSweepEvent.isSamePoint(e.leftSweepEvent) ||
        t.rightSweepEvent.isSamePoint(e.rightSweepEvent) ||
        t.leftSweepEvent.isSamePoint(e.leftSweepEvent) ||
        t.leftSweepEvent.isSamePoint(e.rightSweepEvent))
    )
      return !1;
    var n = t.leftSweepEvent.p.x,
      r = t.leftSweepEvent.p.y,
      i = t.rightSweepEvent.p.x,
      o = t.rightSweepEvent.p.y,
      a = e.leftSweepEvent.p.x,
      s = e.leftSweepEvent.p.y,
      u = e.rightSweepEvent.p.x,
      l = e.rightSweepEvent.p.y,
      c = (l - s) * (i - n) - (u - a) * (o - r),
      h = (u - a) * (r - s) - (l - s) * (n - a),
      f = (i - n) * (r - s) - (o - r) * (n - a);
    if (0 === c) return !1;
    var p = h / c,
      g = f / c;
    return p >= 0 && p <= 1 && g >= 0 && g <= 1 && [n + p * (i - n), r + p * (o - r)];
  }
  function oh(t, e) {
    var n = new Hc([], Jc);
    return (
      (function (t, e) {
        if ('FeatureCollection' === t.type) for (var n = t.features, r = 0; r < n.length; r++) nh(n[r], e);
        else nh(t, e);
      })(t, n),
      (function (t, e) {
        e = e || !1;
        for (var n = [], r = new Hc([], $c); t.length; ) {
          var i = t.pop();
          if (i.isLeftEndpoint) {
            for (var o = new rh(i), a = 0; a < r.data.length; a++) {
              var s = r.data[a];
              if (!e || s.leftSweepEvent.featureId !== i.featureId) {
                var u = ih(o, s);
                !1 !== u && n.push(u);
              }
            }
            r.push(o);
          } else !1 === i.isLeftEndpoint && r.pop();
        }
        return n;
      })(n, e)
    );
  }
  var ah = Object.defineProperty,
    sh = oh;
  function uh(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      r = n.removeDuplicates,
      i = void 0 === r || r,
      o = n.ignoreSelfIntersections,
      a = void 0 !== o && o,
      s = [];
    'FeatureCollection' === t.type
      ? (s = s.concat(t.features))
      : 'Feature' === t.type
      ? s.push(t)
      : ('LineString' !== t.type &&
          'Polygon' !== t.type &&
          'MultiLineString' !== t.type &&
          'MultiPolygon' !== t.type) ||
        s.push(Mu(t)),
      'FeatureCollection' === e.type
        ? (s = s.concat(e.features))
        : 'Feature' === e.type
        ? s.push(e)
        : ('LineString' !== e.type &&
            'Polygon' !== e.type &&
            'MultiLineString' !== e.type &&
            'MultiPolygon' !== e.type) ||
          s.push(Mu(e));
    var u = sh(ju(s), a),
      l = [];
    if (i) {
      var c = {};
      u.forEach(function (t) {
        var e = t.join(',');
        c[e] || ((c[e] = !0), l.push(t));
      });
    } else l = u;
    return ju(
      l.map(function (t) {
        return Lu(t);
      }),
    );
  }
  !(function (t, e) {
    ah(t, 'name', { value: e, configurable: !0 });
  })(uh, 'lineIntersect');
  var lh = Object.defineProperty,
    ch = function (t, e) {
      return lh(t, 'name', { value: e, configurable: !0 });
    };
  function hh(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = cl(t);
    switch ((e.properties || 'Feature' !== t.type || (e.properties = t.properties), n.type)) {
      case 'Polygon':
        return fh(n, e);
      case 'MultiPolygon':
        return ph(n, e);
      default:
        throw new Error('invalid poly');
    }
  }
  function fh(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return gh(cl(t).coordinates, e.properties ? e.properties : 'Feature' === t.type ? t.properties : {});
  }
  function ph(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = cl(t).coordinates,
      r = e.properties ? e.properties : 'Feature' === t.type ? t.properties : {},
      i = [];
    return (
      n.forEach(function (t) {
        i.push(gh(t, r));
      }),
      ju(i)
    );
  }
  function gh(t, e) {
    return t.length > 1 ? Fu(t, e) : Au(t[0], e);
  }
  ch(hh, 'polygonToLine'), ch(fh, 'singlePolygonToLine'), ch(ph, 'multiPolygonToLine'), ch(gh, 'coordsToLine');
  var yh = Object.defineProperty,
    vh = function (t, e) {
      return yh(t, 'name', { value: e, configurable: !0 });
    };
  function dh(t, e) {
    var n = cl(t),
      r = cl(e),
      i = n.type,
      o = r.type;
    switch (i) {
      case 'MultiPoint':
        switch (o) {
          case 'LineString':
            return mh(n, r);
          case 'Polygon':
            return xh(n, r);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'LineString':
        switch (o) {
          case 'MultiPoint':
            return mh(r, n);
          case 'LineString':
            return _h(n, r);
          case 'Polygon':
            return bh(n, r);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'Polygon':
        switch (o) {
          case 'MultiPoint':
            return xh(r, n);
          case 'LineString':
            return bh(r, n);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      default:
        throw new Error('feature1 ' + i + ' geometry not supported');
    }
  }
  function mh(t, e) {
    for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && !n && !r; ) {
      for (var a = 0; a < e.coordinates.length - 1; a++) {
        var s = !0;
        (0 !== a && a !== e.coordinates.length - 2) || (s = !1),
          Eh(e.coordinates[a], e.coordinates[a + 1], t.coordinates[o], s) ? (n = !0) : (r = !0);
      }
      o++;
    }
    return n && r;
  }
  function _h(t, e) {
    if (uh(t, e).features.length > 0)
      for (var n = 0; n < t.coordinates.length - 1; n++)
        for (var r = 0; r < e.coordinates.length - 1; r++) {
          var i = !0;
          if (
            ((0 !== r && r !== e.coordinates.length - 2) || (i = !1),
            Eh(t.coordinates[n], t.coordinates[n + 1], e.coordinates[r], i))
          )
            return !0;
        }
    return !1;
  }
  function bh(t, e) {
    return uh(t, hh(e)).features.length > 0;
  }
  function xh(t, e) {
    for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && (!n || !r); o++)
      Nc(Lu(t.coordinates[o]), e) ? (n = !0) : (r = !0);
    return r && n;
  }
  function Eh(t, e, n, r) {
    var i = n[0] - t[0],
      o = n[1] - t[1],
      a = e[0] - t[0],
      s = e[1] - t[1];
    return (
      0 == i * s - o * a &&
      (r
        ? Math.abs(a) >= Math.abs(s)
          ? a > 0
            ? t[0] <= n[0] && n[0] <= e[0]
            : e[0] <= n[0] && n[0] <= t[0]
          : s > 0
          ? t[1] <= n[1] && n[1] <= e[1]
          : e[1] <= n[1] && n[1] <= t[1]
        : Math.abs(a) >= Math.abs(s)
        ? a > 0
          ? t[0] < n[0] && n[0] < e[0]
          : e[0] < n[0] && n[0] < t[0]
        : s > 0
        ? t[1] < n[1] && n[1] < e[1]
        : e[1] < n[1] && n[1] < t[1])
    );
  }
  vh(dh, 'booleanCrosses'),
    vh(mh, 'doMultiPointAndLineStringCross'),
    vh(_h, 'doLineStringsCross'),
    vh(bh, 'doLineStringAndPolygonCross'),
    vh(xh, 'doesMultiPointCrossPoly'),
    vh(Eh, 'isPointOnLineSegment');
  var wh = Object.defineProperty,
    kh = function (t, e) {
      return wh(t, 'name', { value: e, configurable: !0 });
    };
  function Sh(t, e) {
    var n = !0;
    return (
      Bl(t, function (t) {
        Bl(e, function (e) {
          if (!1 === n) return !1;
          n = Ih(t.geometry, e.geometry);
        });
      }),
      n
    );
  }
  function Ih(t, e) {
    switch (t.type) {
      case 'Point':
        switch (e.type) {
          case 'Point':
            return !Rh(t.coordinates, e.coordinates);
          case 'LineString':
            return !Ph(e, t);
          case 'Polygon':
            return !Nc(t, e);
        }
        break;
      case 'LineString':
        switch (e.type) {
          case 'Point':
            return !Ph(t, e);
          case 'LineString':
            return !Nh(t, e);
          case 'Polygon':
            return !Mh(e, t);
        }
        break;
      case 'Polygon':
        switch (e.type) {
          case 'Point':
            return !Nc(e, t);
          case 'LineString':
            return !Mh(t, e);
          case 'Polygon':
            return !Oh(e, t);
        }
    }
    return !1;
  }
  function Ph(t, e) {
    for (var n = 0; n < t.coordinates.length - 1; n++)
      if (Lh(t.coordinates[n], t.coordinates[n + 1], e.coordinates)) return !0;
    return !1;
  }
  function Nh(t, e) {
    return uh(t, e).features.length > 0;
  }
  function Mh(t, e) {
    var n,
      r = c(e.coordinates);
    try {
      for (r.s(); !(n = r.n()).done; ) {
        if (Nc(n.value, t)) return !0;
      }
    } catch (t) {
      r.e(t);
    } finally {
      r.f();
    }
    return uh(e, hh(t)).features.length > 0;
  }
  function Oh(t, e) {
    var n,
      r = c(t.coordinates[0]);
    try {
      for (r.s(); !(n = r.n()).done; ) {
        if (Nc(n.value, e)) return !0;
      }
    } catch (t) {
      r.e(t);
    } finally {
      r.f();
    }
    var i,
      o = c(e.coordinates[0]);
    try {
      for (o.s(); !(i = o.n()).done; ) {
        if (Nc(i.value, t)) return !0;
      }
    } catch (t) {
      o.e(t);
    } finally {
      o.f();
    }
    return uh(hh(t), hh(e)).features.length > 0;
  }
  function Lh(t, e, n) {
    var r = n[0] - t[0],
      i = n[1] - t[1],
      o = e[0] - t[0],
      a = e[1] - t[1];
    return (
      0 == r * a - i * o &&
      (Math.abs(o) >= Math.abs(a)
        ? o > 0
          ? t[0] <= n[0] && n[0] <= e[0]
          : e[0] <= n[0] && n[0] <= t[0]
        : a > 0
        ? t[1] <= n[1] && n[1] <= e[1]
        : e[1] <= n[1] && n[1] <= t[1])
    );
  }
  function Rh(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  kh(Sh, 'booleanDisjoint'),
    kh(Ih, 'disjoint'),
    kh(Ph, 'isPointOnLine'),
    kh(Nh, 'isLineOnLine'),
    kh(Mh, 'isLineInPoly'),
    kh(Oh, 'isPolyInPoly'),
    kh(Lh, 'isPointOnLineSegment'),
    kh(Rh, 'compareCoords');
  var Ch = Object.defineProperty,
    Th = function (t, e) {
      return Ch(t, 'name', { value: e, configurable: !0 });
    };
  function Ah(t) {
    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      r = 'object' === e(n) ? n.mutate : n;
    if (!t) throw new Error('geojson is required');
    var i = hl(t),
      o = [];
    switch (i) {
      case 'LineString':
        o = Dh(t, i);
        break;
      case 'MultiLineString':
      case 'Polygon':
        ol(t).forEach(function (t) {
          o.push(Dh(t, i));
        });
        break;
      case 'MultiPolygon':
        ol(t).forEach(function (t) {
          var e = [];
          t.forEach(function (t) {
            e.push(Dh(t, i));
          }),
            o.push(e);
        });
        break;
      case 'Point':
        return t;
      case 'MultiPoint':
        var a = {};
        ol(t).forEach(function (t) {
          var e = t.join('-');
          Object.prototype.hasOwnProperty.call(a, e) || (o.push(t), (a[e] = !0));
        });
        break;
      default:
        throw new Error(i + ' geometry not supported');
    }
    return t.coordinates
      ? !0 === r
        ? ((t.coordinates = o), t)
        : { type: i, coordinates: o }
      : !0 === r
      ? ((t.geometry.coordinates = o), t)
      : Mu({ type: i, coordinates: o }, t.properties, { bbox: t.bbox, id: t.id });
  }
  function Dh(t, e) {
    var n = ol(t);
    if (2 === n.length && !jh(n[0], n[1])) return n;
    var r = [],
      i = n.length - 1,
      o = r.length;
    r.push(n[0]);
    for (var a = 1; a < i; a++) {
      var s = r[r.length - 1];
      (n[a][0] === s[0] && n[a][1] === s[1]) ||
        (r.push(n[a]), (o = r.length) > 2 && Fh(r[o - 3], r[o - 1], r[o - 2]) && r.splice(r.length - 2, 1));
    }
    if (
      (r.push(n[n.length - 1]),
      (o = r.length),
      ('Polygon' === e || 'MultiPolygon' === e) && jh(n[0], n[n.length - 1]) && o < 4)
    )
      throw new Error('invalid polygon');
    return ('LineString' === e && o < 3) || (Fh(r[o - 3], r[o - 1], r[o - 2]) && r.splice(r.length - 2, 1)), r;
  }
  function jh(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  function Fh(t, e, n) {
    var r = n[0],
      i = n[1],
      o = t[0],
      a = t[1],
      s = e[0],
      u = e[1],
      l = s - o,
      c = u - a;
    return (
      0 === (r - o) * c - (i - a) * l &&
      (Math.abs(l) >= Math.abs(c)
        ? l > 0
          ? o <= r && r <= s
          : s <= r && r <= o
        : c > 0
        ? a <= i && i <= u
        : u <= i && i <= a)
    );
  }
  Th(Ah, 'cleanCoords'), Th(Dh, 'cleanLine'), Th(jh, 'equals'), Th(Fh, 'isPointOnLineSegment');
  var Bh = Object.defineProperty;
  function qh(t, e) {
    var n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).precision;
    if ('number' != typeof (n = null == n || isNaN(n) ? 6 : n) || !(n >= 0))
      throw new Error('precision must be a positive number');
    return cl(t).type === cl(e).type && new wu({ precision: n }).compare(Ah(t), Ah(e));
  }
  !(function (t, e) {
    Bh(t, 'name', { value: e, configurable: !0 });
  })(qh, 'booleanEqual');
  var Vh = Object.defineProperty;
  function Gh(t, e) {
    var n = !1;
    return (
      Bl(t, function (t) {
        Bl(e, function (e) {
          if (!0 === n) return !0;
          n = !Sh(t.geometry, e.geometry);
        });
      }),
      n
    );
  }
  function Yh(t, e, n, r, i) {
    zh(t, e, n || 0, r || t.length - 1, i || Xh);
  }
  function zh(t, e, n, r, i) {
    for (; r > n; ) {
      if (r - n > 600) {
        var o = r - n + 1,
          a = e - n + 1,
          s = Math.log(o),
          u = 0.5 * Math.exp((2 * s) / 3),
          l = 0.5 * Math.sqrt((s * u * (o - u)) / o) * (a - o / 2 < 0 ? -1 : 1);
        zh(t, e, Math.max(n, Math.floor(e - (a * u) / o + l)), Math.min(r, Math.floor(e + ((o - a) * u) / o + l)), i);
      }
      var c = t[e],
        h = n,
        f = r;
      for (Uh(t, n, e), i(t[r], c) > 0 && Uh(t, n, r); h < f; ) {
        for (Uh(t, h, f), h++, f--; i(t[h], c) < 0; ) h++;
        for (; i(t[f], c) > 0; ) f--;
      }
      0 === i(t[n], c) ? Uh(t, n, f) : Uh(t, ++f, r), f <= e && (n = f + 1), e <= f && (r = f - 1);
    }
  }
  function Uh(t, e, n) {
    var r = t[e];
    (t[e] = t[n]), (t[n] = r);
  }
  function Xh(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  !(function (t, e) {
    Vh(t, 'name', { value: e, configurable: !0 });
  })(Gh, 'booleanIntersects');
  var Wh = (function () {
    function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 9;
      n(this, t),
        (this._maxEntries = Math.max(4, e)),
        (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
        this.clear();
    }
    return (
      i(t, [
        {
          key: 'all',
          value: function () {
            return this._all(this.data, []);
          },
        },
        {
          key: 'search',
          value: function (t) {
            var e = this.data,
              n = [];
            if (!rf(t, e)) return n;
            for (var r = this.toBBox, i = []; e; ) {
              for (var o = 0; o < e.children.length; o++) {
                var a = e.children[o],
                  s = e.leaf ? r(a) : a;
                rf(t, s) && (e.leaf ? n.push(a) : nf(t, s) ? this._all(a, n) : i.push(a));
              }
              e = i.pop();
            }
            return n;
          },
        },
        {
          key: 'collides',
          value: function (t) {
            var e = this.data;
            if (!rf(t, e)) return !1;
            for (var n = []; e; ) {
              for (var r = 0; r < e.children.length; r++) {
                var i = e.children[r],
                  o = e.leaf ? this.toBBox(i) : i;
                if (rf(t, o)) {
                  if (e.leaf || nf(t, o)) return !0;
                  n.push(i);
                }
              }
              e = n.pop();
            }
            return !1;
          },
        },
        {
          key: 'load',
          value: function (t) {
            if (!t || !t.length) return this;
            if (t.length < this._minEntries) {
              for (var e = 0; e < t.length; e++) this.insert(t[e]);
              return this;
            }
            var n = this._build(t.slice(), 0, t.length - 1, 0);
            if (this.data.children.length)
              if (this.data.height === n.height) this._splitRoot(this.data, n);
              else {
                if (this.data.height < n.height) {
                  var r = this.data;
                  (this.data = n), (n = r);
                }
                this._insert(n, this.data.height - n.height - 1, !0);
              }
            else this.data = n;
            return this;
          },
        },
        {
          key: 'insert',
          value: function (t) {
            return t && this._insert(t, this.data.height - 1), this;
          },
        },
        {
          key: 'clear',
          value: function () {
            return (this.data = of([])), this;
          },
        },
        {
          key: 'remove',
          value: function (t, e) {
            if (!t) return this;
            for (var n, r, i, o = this.data, a = this.toBBox(t), s = [], u = []; o || s.length; ) {
              if ((o || ((o = s.pop()), (r = s[s.length - 1]), (n = u.pop()), (i = !0)), o.leaf)) {
                var l = Hh(t, o.children, e);
                if (-1 !== l) return o.children.splice(l, 1), s.push(o), this._condense(s), this;
              }
              i || o.leaf || !nf(o, a)
                ? r
                  ? (n++, (o = r.children[n]), (i = !1))
                  : (o = null)
                : (s.push(o), u.push(n), (n = 0), (r = o), (o = o.children[0]));
            }
            return this;
          },
        },
        {
          key: 'toBBox',
          value: function (t) {
            return t;
          },
        },
        {
          key: 'compareMinX',
          value: function (t, e) {
            return t.minX - e.minX;
          },
        },
        {
          key: 'compareMinY',
          value: function (t, e) {
            return t.minY - e.minY;
          },
        },
        {
          key: 'toJSON',
          value: function () {
            return this.data;
          },
        },
        {
          key: 'fromJSON',
          value: function (t) {
            return (this.data = t), this;
          },
        },
        {
          key: '_all',
          value: function (t, e) {
            for (var n = []; t; )
              t.leaf ? e.push.apply(e, s(t.children)) : n.push.apply(n, s(t.children)), (t = n.pop());
            return e;
          },
        },
        {
          key: '_build',
          value: function (t, e, n, r) {
            var i,
              o = n - e + 1,
              a = this._maxEntries;
            if (o <= a) return Zh((i = of(t.slice(e, n + 1))), this.toBBox), i;
            r || ((r = Math.ceil(Math.log(o) / Math.log(a))), (a = Math.ceil(o / Math.pow(a, r - 1)))),
              ((i = of([])).leaf = !1),
              (i.height = r);
            var s = Math.ceil(o / a),
              u = s * Math.ceil(Math.sqrt(a));
            af(t, e, n, u, this.compareMinX);
            for (var l = e; l <= n; l += u) {
              var c = Math.min(l + u - 1, n);
              af(t, l, c, s, this.compareMinY);
              for (var h = l; h <= c; h += s) {
                var f = Math.min(h + s - 1, c);
                i.children.push(this._build(t, h, f, r - 1));
              }
            }
            return Zh(i, this.toBBox), i;
          },
        },
        {
          key: '_chooseSubtree',
          value: function (t, e, n, r) {
            for (; r.push(e), !e.leaf && r.length - 1 !== n; ) {
              for (var i = 1 / 0, o = 1 / 0, a = void 0, s = 0; s < e.children.length; s++) {
                var u = e.children[s],
                  l = tf(u),
                  c =
                    ((h = t),
                    (f = u),
                    (Math.max(f.maxX, h.maxX) - Math.min(f.minX, h.minX)) *
                      (Math.max(f.maxY, h.maxY) - Math.min(f.minY, h.minY)) -
                      l);
                c < o ? ((o = c), (i = l < i ? l : i), (a = u)) : c === o && l < i && ((i = l), (a = u));
              }
              e = a || e.children[0];
            }
            var h, f;
            return e;
          },
        },
        {
          key: '_insert',
          value: function (t, e, n) {
            var r = n ? t : this.toBBox(t),
              i = [],
              o = this._chooseSubtree(r, this.data, e, i);
            for (o.children.push(t), $h(o, r); e >= 0 && i[e].children.length > this._maxEntries; )
              this._split(i, e), e--;
            this._adjustParentBBoxes(r, i, e);
          },
        },
        {
          key: '_split',
          value: function (t, e) {
            var n = t[e],
              r = n.children.length,
              i = this._minEntries;
            this._chooseSplitAxis(n, i, r);
            var o = this._chooseSplitIndex(n, i, r),
              a = of(n.children.splice(o, n.children.length - o));
            (a.height = n.height),
              (a.leaf = n.leaf),
              Zh(n, this.toBBox),
              Zh(a, this.toBBox),
              e ? t[e - 1].children.push(a) : this._splitRoot(n, a);
          },
        },
        {
          key: '_splitRoot',
          value: function (t, e) {
            (this.data = of([t, e])),
              (this.data.height = t.height + 1),
              (this.data.leaf = !1),
              Zh(this.data, this.toBBox);
          },
        },
        {
          key: '_chooseSplitIndex',
          value: function (t, e, n) {
            for (var r, i, o, a, s, u, l, c = 1 / 0, h = 1 / 0, f = e; f <= n - e; f++) {
              var p = Jh(t, 0, f, this.toBBox),
                g = Jh(t, f, n, this.toBBox),
                y =
                  ((i = p),
                  (o = g),
                  (a = void 0),
                  (s = void 0),
                  (u = void 0),
                  (l = void 0),
                  (a = Math.max(i.minX, o.minX)),
                  (s = Math.max(i.minY, o.minY)),
                  (u = Math.min(i.maxX, o.maxX)),
                  (l = Math.min(i.maxY, o.maxY)),
                  Math.max(0, u - a) * Math.max(0, l - s)),
                v = tf(p) + tf(g);
              y < c ? ((c = y), (r = f), (h = v < h ? v : h)) : y === c && v < h && ((h = v), (r = f));
            }
            return r || n - e;
          },
        },
        {
          key: '_chooseSplitAxis',
          value: function (t, e, n) {
            var r = t.leaf ? this.compareMinX : Qh,
              i = t.leaf ? this.compareMinY : Kh;
            this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r);
          },
        },
        {
          key: '_allDistMargin',
          value: function (t, e, n, r) {
            t.children.sort(r);
            for (
              var i = this.toBBox, o = Jh(t, 0, e, i), a = Jh(t, n - e, n, i), s = ef(o) + ef(a), u = e;
              u < n - e;
              u++
            ) {
              var l = t.children[u];
              $h(o, t.leaf ? i(l) : l), (s += ef(o));
            }
            for (var c = n - e - 1; c >= e; c--) {
              var h = t.children[c];
              $h(a, t.leaf ? i(h) : h), (s += ef(a));
            }
            return s;
          },
        },
        {
          key: '_adjustParentBBoxes',
          value: function (t, e, n) {
            for (var r = n; r >= 0; r--) $h(e[r], t);
          },
        },
        {
          key: '_condense',
          value: function (t) {
            for (var e, n = t.length - 1; n >= 0; n--)
              0 === t[n].children.length
                ? n > 0
                  ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1)
                  : this.clear()
                : Zh(t[n], this.toBBox);
          },
        },
      ]),
      t
    );
  })();
  function Hh(t, e, n) {
    if (!n) return e.indexOf(t);
    for (var r = 0; r < e.length; r++) if (n(t, e[r])) return r;
    return -1;
  }
  function Zh(t, e) {
    Jh(t, 0, t.children.length, e, t);
  }
  function Jh(t, e, n, r, i) {
    i || (i = of(null)), (i.minX = 1 / 0), (i.minY = 1 / 0), (i.maxX = -1 / 0), (i.maxY = -1 / 0);
    for (var o = e; o < n; o++) {
      var a = t.children[o];
      $h(i, t.leaf ? r(a) : a);
    }
    return i;
  }
  function $h(t, e) {
    return (
      (t.minX = Math.min(t.minX, e.minX)),
      (t.minY = Math.min(t.minY, e.minY)),
      (t.maxX = Math.max(t.maxX, e.maxX)),
      (t.maxY = Math.max(t.maxY, e.maxY)),
      t
    );
  }
  function Qh(t, e) {
    return t.minX - e.minX;
  }
  function Kh(t, e) {
    return t.minY - e.minY;
  }
  function tf(t) {
    return (t.maxX - t.minX) * (t.maxY - t.minY);
  }
  function ef(t) {
    return t.maxX - t.minX + (t.maxY - t.minY);
  }
  function nf(t, e) {
    return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;
  }
  function rf(t, e) {
    return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;
  }
  function of(t) {
    return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
  }
  function af(t, e, n, r, i) {
    for (var o = [e, n]; o.length; )
      if (!((n = o.pop()) - (e = o.pop()) <= r)) {
        var a = e + Math.ceil((n - e) / r / 2) * r;
        Yh(t, a, e, n, i), o.push(e, a, a, n);
      }
  }
  var sf = Object.freeze({ __proto__: null, default: Wh }),
    uf = Object.defineProperty;
  function lf(t) {
    var e = new Wh(t);
    return (
      (e.insert = function (t) {
        if ('Feature' !== t.type) throw new Error('invalid feature');
        return (t.bbox = t.bbox ? t.bbox : rc(t)), Wh.prototype.insert.call(this, t);
      }),
      (e.load = function (t) {
        var e = [];
        return (
          Array.isArray(t)
            ? t.forEach(function (t) {
                if ('Feature' !== t.type) throw new Error('invalid features');
                (t.bbox = t.bbox ? t.bbox : rc(t)), e.push(t);
              })
            : Tl(t, function (t) {
                if ('Feature' !== t.type) throw new Error('invalid features');
                (t.bbox = t.bbox ? t.bbox : rc(t)), e.push(t);
              }),
          Wh.prototype.load.call(this, e)
        );
      }),
      (e.remove = function (t, e) {
        if ('Feature' !== t.type) throw new Error('invalid feature');
        return (t.bbox = t.bbox ? t.bbox : rc(t)), Wh.prototype.remove.call(this, t, e);
      }),
      (e.clear = function () {
        return Wh.prototype.clear.call(this);
      }),
      (e.search = function (t) {
        return ju(Wh.prototype.search.call(this, this.toBBox(t)));
      }),
      (e.collides = function (t) {
        return Wh.prototype.collides.call(this, this.toBBox(t));
      }),
      (e.all = function () {
        return ju(Wh.prototype.all.call(this));
      }),
      (e.toJSON = function () {
        return Wh.prototype.toJSON.call(this);
      }),
      (e.fromJSON = function (t) {
        return Wh.prototype.fromJSON.call(this, t);
      }),
      (e.toBBox = function (t) {
        var e;
        if (t.bbox) e = t.bbox;
        else if (Array.isArray(t) && 4 === t.length) e = t;
        else if (Array.isArray(t) && 6 === t.length) e = [t[0], t[1], t[3], t[4]];
        else if ('Feature' === t.type) e = rc(t);
        else {
          if ('FeatureCollection' !== t.type) throw new Error('invalid geojson');
          e = rc(t);
        }
        return { minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] };
      }),
      e
    );
  }
  !(function (t, e) {
    uf(t, 'name', { value: e, configurable: !0 });
  })(lf, 'geojsonRbush');
  var cf = Object.defineProperty,
    hf = function (t, e) {
      return cf(t, 'name', { value: e, configurable: !0 });
    };
  function ff(t) {
    if (!t) throw new Error('geojson is required');
    var e = [];
    return (
      Bl(t, function (t) {
        pf(t, e);
      }),
      ju(e)
    );
  }
  function pf(t, e) {
    var n = [],
      r = t.geometry;
    if (null !== r) {
      switch (r.type) {
        case 'Polygon':
          n = ol(r);
          break;
        case 'LineString':
          n = [ol(r)];
      }
      n.forEach(function (n) {
        gf(n, t.properties).forEach(function (t) {
          (t.id = e.length), e.push(t);
        });
      });
    }
  }
  function gf(t, e) {
    var n = [];
    return (
      t.reduce(function (t, r) {
        var i = Au([t, r], e);
        return (i.bbox = yf(t, r)), n.push(i), r;
      }),
      n
    );
  }
  function yf(t, e) {
    var n = t[0],
      r = t[1],
      i = e[0],
      o = e[1];
    return [n < i ? n : i, r < o ? r : o, n > i ? n : i, r > o ? r : o];
  }
  hf(ff, 'lineSegment'), hf(pf, 'lineSegmentFeature'), hf(gf, 'createSegments'), hf(yf, 'bbox');
  var vf = Object.defineProperty,
    df = Object.defineProperties,
    mf = Object.getOwnPropertyDescriptors,
    _f = Object.getOwnPropertySymbols,
    bf = Object.prototype.hasOwnProperty,
    xf = Object.prototype.propertyIsEnumerable,
    Ef = function (t, e, n) {
      return e in t ? vf(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n);
    },
    wf = function (t, e) {
      for (var n in e || (e = {})) bf.call(e, n) && Ef(t, n, e[n]);
      if (_f) {
        var r,
          i = c(_f(e));
        try {
          for (i.s(); !(r = i.n()).done; ) {
            n = r.value;
            xf.call(e, n) && Ef(t, n, e[n]);
          }
        } catch (t) {
          i.e(t);
        } finally {
          i.f();
        }
      }
      return t;
    },
    kf = function (t, e) {
      return df(t, mf(e));
    };
  function Sf(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (!t || !e) throw new Error('lines and pt are required arguments');
    var r = Lu([1 / 0, 1 / 0], { dist: 1 / 0, index: -1, location: -1 }),
      i = 0;
    return (
      Bl(t, function (t) {
        for (var o = ol(t), a = 0; a < o.length - 1; a++) {
          var s = Lu(o[a]);
          s.properties.dist = _l(e, s, n);
          var u = Lu(o[a + 1]);
          u.properties.dist = _l(e, u, n);
          var l = _l(s, u, n),
            c = Math.max(s.properties.dist, u.properties.dist),
            h = yl(s, u),
            f = dl(e, c, h + 90, n),
            p = dl(e, c, h - 90, n),
            g = uh(
              Au([f.geometry.coordinates, p.geometry.coordinates]),
              Au([s.geometry.coordinates, u.geometry.coordinates]),
            ),
            y = void 0;
          g.features.length > 0 &&
            g.features[0] &&
            (y = kf(wf({}, g.features[0]), {
              properties: { dist: _l(e, g.features[0], n), location: i + _l(s, g.features[0], n) },
            })),
            s.properties.dist < r.properties.dist &&
              (r = kf(wf({}, s), { properties: kf(wf({}, s.properties), { index: a, location: i }) })),
            u.properties.dist < r.properties.dist &&
              (r = kf(wf({}, u), { properties: kf(wf({}, u.properties), { index: a + 1, location: i + l }) })),
            y &&
              y.properties.dist < r.properties.dist &&
              (r = kf(wf({}, y), { properties: kf(wf({}, y.properties), { index: a }) })),
            (i += l);
        }
      }),
      r
    );
  }
  !(function (t, e) {
    vf(t, 'name', { value: e, configurable: !0 });
  })(Sf, 'nearestPointOnLine');
  var If = Object.defineProperty,
    Pf = function (t, e) {
      return If(t, 'name', { value: e, configurable: !0 });
    };
  function Nf(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (!Qu((n = n || {}))) throw new Error('options is invalid');
    var r,
      i = n.tolerance || 0,
      o = [],
      a = lf(),
      s = ff(t);
    a.load(s);
    var u = [];
    return (
      Vl(e, function (t) {
        var e = !1;
        t &&
          (Tl(a.search(t), function (n) {
            if (!1 === e) {
              var o = ol(t).sort(),
                a = ol(n).sort();
              if (_u(o, a)) (e = !0), (r = r ? Mf(r, t) || r : t);
              else if (
                0 === i
                  ? Rc(o[0], n) && Rc(o[1], n)
                  : Sf(n, o[0]).properties.dist <= i && Sf(n, o[1]).properties.dist <= i
              )
                (e = !0), (r = r ? Mf(r, t) || r : t);
              else if (
                0 === i
                  ? Rc(a[0], t) && Rc(a[1], t)
                  : Sf(t, a[0]).properties.dist <= i && Sf(t, a[1]).properties.dist <= i
              )
                if (r) {
                  var s = Mf(r, n);
                  s ? (r = s) : u.push(n);
                } else r = n;
            }
          }),
          !1 === e && r && (o.push(r), u.length && ((o = o.concat(u)), (u = [])), (r = void 0)));
      }),
      r && o.push(r),
      ju(o)
    );
  }
  function Mf(t, e) {
    var n = ol(e),
      r = ol(t),
      i = r[0],
      o = r[r.length - 1],
      a = t.geometry.coordinates;
    if (_u(n[0], i)) a.unshift(n[1]);
    else if (_u(n[0], o)) a.push(n[1]);
    else if (_u(n[1], i)) a.unshift(n[0]);
    else {
      if (!_u(n[1], o)) return;
      a.push(n[0]);
    }
    return t;
  }
  Pf(Nf, 'lineOverlap'), Pf(Mf, 'concatSegment');
  var Of = Object.defineProperty;
  function Lf(t, e) {
    var n = cl(t),
      r = cl(e),
      i = n.type,
      o = r.type;
    if (
      ('MultiPoint' === i && 'MultiPoint' !== o) ||
      (('LineString' === i || 'MultiLineString' === i) && 'LineString' !== o && 'MultiLineString' !== o) ||
      (('Polygon' === i || 'MultiPolygon' === i) && 'Polygon' !== o && 'MultiPolygon' !== o)
    )
      throw new Error('features must be of the same type');
    if ('Point' === i) throw new Error('Point geometry not supported');
    if (new wu({ precision: 6 }).compare(t, e)) return !1;
    var a = 0;
    switch (i) {
      case 'MultiPoint':
        for (var s = 0; s < n.coordinates.length; s++)
          for (var u = 0; u < r.coordinates.length; u++) {
            var l = n.coordinates[s],
              c = r.coordinates[u];
            if (l[0] === c[0] && l[1] === c[1]) return !0;
          }
        return !1;
      case 'LineString':
      case 'MultiLineString':
        Vl(t, function (t) {
          Vl(e, function (e) {
            Nf(t, e).features.length && a++;
          });
        });
        break;
      case 'Polygon':
      case 'MultiPolygon':
        Vl(t, function (t) {
          Vl(e, function (e) {
            uh(t, e).features.length && a++;
          });
        });
    }
    return a > 0;
  }
  !(function (t, e) {
    Of(t, 'name', { value: e, configurable: !0 });
  })(Lf, 'booleanOverlap');
  var Rf = Object.defineProperty,
    Cf = function (t, e) {
      return Rf(t, 'name', { value: e, configurable: !0 });
    };
  function Tf(t, e) {
    if (!t) throw new Error('line1 is required');
    if (!e) throw new Error('line2 is required');
    if ('LineString' !== Df(t, 'line1')) throw new Error('line1 must be a LineString');
    if ('LineString' !== Df(e, 'line2')) throw new Error('line2 must be a LineString');
    for (var n = ff(Ah(t)).features, r = ff(Ah(e)).features, i = 0; i < n.length; i++) {
      var o = n[i].geometry.coordinates;
      if (!r[i]) break;
      if (!Af(o, r[i].geometry.coordinates)) return !1;
    }
    return !0;
  }
  function Af(t, e) {
    var n = Xu(kl(t[0], t[1])),
      r = Xu(kl(e[0], e[1]));
    return n === r || (r - n) % 180 == 0;
  }
  function Df(t, e) {
    if (t.geometry && t.geometry.type) return t.geometry.type;
    if (t.type) return t.type;
    throw new Error('Invalid GeoJSON object for ' + e);
  }
  Cf(Tf, 'booleanParallel'), Cf(Af, 'isParallel'), Cf(Df, 'getType');
  var jf = Object.defineProperty,
    Ff = function (t, e) {
      return jf(t, 'name', { value: e, configurable: !0 });
    };
  function Bf(t, e) {
    var n = cl(t),
      r = cl(e),
      i = n.type,
      o = r.type;
    switch (i) {
      case 'Point':
        switch (o) {
          case 'LineString':
            return qf(n, r);
          case 'MultiLineString':
            for (var a = !1, s = 0; s < r.coordinates.length; s++)
              qf(n, { type: 'LineString', coordinates: r.coordinates[s] }) && (a = !0);
            return a;
          case 'Polygon':
            for (var u = 0; u < r.coordinates.length; u++)
              if (Rc(n, { type: 'LineString', coordinates: r.coordinates[u] })) return !0;
            return !1;
          case 'MultiPolygon':
            for (u = 0; u < r.coordinates.length; u++)
              for (s = 0; s < r.coordinates[u].length; s++)
                if (Rc(n, { type: 'LineString', coordinates: r.coordinates[u][s] })) return !0;
            return !1;
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'MultiPoint':
        switch (o) {
          case 'LineString':
            for (a = !1, u = 0; u < n.coordinates.length; u++)
              if (
                (a || (qf({ type: 'Point', coordinates: n.coordinates[u] }, r) && (a = !0)),
                Rc({ type: 'Point', coordinates: n.coordinates[u] }, r, { ignoreEndVertices: !0 }))
              )
                return !1;
            return a;
          case 'MultiLineString':
            for (a = !1, u = 0; u < n.coordinates.length; u++)
              for (s = 0; s < r.coordinates.length; s++)
                if (
                  (a ||
                    (qf(
                      { type: 'Point', coordinates: n.coordinates[u] },
                      { type: 'LineString', coordinates: r.coordinates[s] },
                    ) &&
                      (a = !0)),
                  Rc(
                    { type: 'Point', coordinates: n.coordinates[u] },
                    { type: 'LineString', coordinates: r.coordinates[s] },
                    { ignoreEndVertices: !0 },
                  ))
                )
                  return !1;
            return a;
          case 'Polygon':
            for (a = !1, u = 0; u < n.coordinates.length; u++)
              if (
                (a ||
                  (Rc(
                    { type: 'Point', coordinates: n.coordinates[u] },
                    { type: 'LineString', coordinates: r.coordinates[0] },
                  ) &&
                    (a = !0)),
                Nc({ type: 'Point', coordinates: n.coordinates[u] }, r, { ignoreBoundary: !0 }))
              )
                return !1;
            return a;
          case 'MultiPolygon':
            for (a = !1, u = 0; u < n.coordinates.length; u++)
              for (s = 0; s < r.coordinates.length; s++)
                if (
                  (a ||
                    (Rc(
                      { type: 'Point', coordinates: n.coordinates[u] },
                      { type: 'LineString', coordinates: r.coordinates[s][0] },
                    ) &&
                      (a = !0)),
                  Nc(
                    { type: 'Point', coordinates: n.coordinates[u] },
                    { type: 'Polygon', coordinates: r.coordinates[s] },
                    { ignoreBoundary: !0 },
                  ))
                )
                  return !1;
            return a;
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'LineString':
        switch (o) {
          case 'Point':
            return qf(r, n);
          case 'MultiPoint':
            for (a = !1, u = 0; u < r.coordinates.length; u++)
              if (
                (a || (qf({ type: 'Point', coordinates: r.coordinates[u] }, n) && (a = !0)),
                Rc({ type: 'Point', coordinates: r.coordinates[u] }, n, { ignoreEndVertices: !0 }))
              )
                return !1;
            return a;
          case 'LineString':
            var l = !1;
            if (
              (qf({ type: 'Point', coordinates: n.coordinates[0] }, r) && (l = !0),
              qf({ type: 'Point', coordinates: n.coordinates[n.coordinates.length - 1] }, r) && (l = !0),
              !1 === l)
            )
              return !1;
            for (u = 0; u < n.coordinates.length; u++)
              if (Rc({ type: 'Point', coordinates: n.coordinates[u] }, r, { ignoreEndVertices: !0 })) return !1;
            return l;
          case 'MultiLineString':
            for (l = !1, u = 0; u < r.coordinates.length; u++) {
              qf(
                { type: 'Point', coordinates: n.coordinates[0] },
                { type: 'LineString', coordinates: r.coordinates[u] },
              ) && (l = !0),
                qf(
                  { type: 'Point', coordinates: n.coordinates[n.coordinates.length - 1] },
                  { type: 'LineString', coordinates: r.coordinates[u] },
                ) && (l = !0);
              for (s = 0; s < n.coordinates[u].length; s++)
                if (
                  Rc(
                    { type: 'Point', coordinates: n.coordinates[s] },
                    { type: 'LineString', coordinates: r.coordinates[u] },
                    { ignoreEndVertices: !0 },
                  )
                )
                  return !1;
            }
            return l;
          case 'Polygon':
            for (a = !1, u = 0; u < n.coordinates.length; u++)
              if (
                (a ||
                  (Rc(
                    { type: 'Point', coordinates: n.coordinates[u] },
                    { type: 'LineString', coordinates: r.coordinates[0] },
                  ) &&
                    (a = !0)),
                Nc({ type: 'Point', coordinates: n.coordinates[u] }, r, { ignoreBoundary: !0 }))
              )
                return !1;
            return a;
          case 'MultiPolygon':
            for (a = !1, u = 0; u < n.coordinates.length; u++) {
              for (s = 0; s < r.coordinates.length; s++)
                a ||
                  (Rc(
                    { type: 'Point', coordinates: n.coordinates[u] },
                    { type: 'LineString', coordinates: r.coordinates[s][0] },
                  ) &&
                    (a = !0));
              if (Nc({ type: 'Point', coordinates: n.coordinates[u] }, r, { ignoreBoundary: !0 })) return !1;
            }
            return a;
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'MultiLineString':
        switch (o) {
          case 'Point':
            for (u = 0; u < n.coordinates.length; u++)
              if (qf(r, { type: 'LineString', coordinates: n.coordinates[u] })) return !0;
            return !1;
          case 'MultiPoint':
            for (a = !1, u = 0; u < n.coordinates.length; u++)
              for (s = 0; s < r.coordinates.length; s++)
                if (
                  (a ||
                    (qf(
                      { type: 'Point', coordinates: r.coordinates[s] },
                      { type: 'LineString', coordinates: n.coordinates[s] },
                    ) &&
                      (a = !0)),
                  Rc(
                    { type: 'Point', coordinates: r.coordinates[s] },
                    { type: 'LineString', coordinates: n.coordinates[s] },
                    { ignoreEndVertices: !0 },
                  ))
                )
                  return !1;
            return a;
          case 'LineString':
            for (l = !1, u = 0; u < n.coordinates.length; u++) {
              qf({ type: 'Point', coordinates: n.coordinates[u][0] }, r) && (l = !0),
                qf({ type: 'Point', coordinates: n.coordinates[u][n.coordinates[u].length - 1] }, r) && (l = !0);
              for (s = 0; s < r.coordinates.length; s++)
                if (
                  Rc(
                    { type: 'Point', coordinates: r.coordinates[s] },
                    { type: 'LineString', coordinates: n.coordinates[u] },
                    { ignoreEndVertices: !0 },
                  )
                )
                  return !1;
            }
            return l;
          case 'MultiLineString':
            for (l = !1, u = 0; u < n.coordinates.length; u++)
              for (s = 0; s < r.coordinates.length; s++) {
                qf(
                  { type: 'Point', coordinates: n.coordinates[u][0] },
                  { type: 'LineString', coordinates: r.coordinates[s] },
                ) && (l = !0),
                  qf(
                    { type: 'Point', coordinates: n.coordinates[u][n.coordinates[u].length - 1] },
                    { type: 'LineString', coordinates: r.coordinates[s] },
                  ) && (l = !0);
                for (var c = 0; c < n.coordinates[u].length; c++)
                  if (
                    Rc(
                      { type: 'Point', coordinates: n.coordinates[u][c] },
                      { type: 'LineString', coordinates: r.coordinates[s] },
                      { ignoreEndVertices: !0 },
                    )
                  )
                    return !1;
              }
            return l;
          case 'Polygon':
            for (a = !1, u = 0; u < n.coordinates.length; u++)
              for (s = 0; s < n.coordinates.length; s++)
                if (
                  (a ||
                    (Rc(
                      { type: 'Point', coordinates: n.coordinates[u][s] },
                      { type: 'LineString', coordinates: r.coordinates[0] },
                    ) &&
                      (a = !0)),
                  Nc({ type: 'Point', coordinates: n.coordinates[u][s] }, r, { ignoreBoundary: !0 }))
                )
                  return !1;
            return a;
          case 'MultiPolygon':
            for (a = !1, u = 0; u < r.coordinates[0].length; u++)
              for (s = 0; s < n.coordinates.length; s++)
                for (c = 0; c < n.coordinates[s].length; c++)
                  if (
                    (a ||
                      (Rc(
                        { type: 'Point', coordinates: n.coordinates[s][c] },
                        { type: 'LineString', coordinates: r.coordinates[0][u] },
                      ) &&
                        (a = !0)),
                    Nc(
                      { type: 'Point', coordinates: n.coordinates[s][c] },
                      { type: 'Polygon', coordinates: [r.coordinates[0][u]] },
                      { ignoreBoundary: !0 },
                    ))
                  )
                    return !1;
            return a;
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'Polygon':
        switch (o) {
          case 'Point':
            for (u = 0; u < n.coordinates.length; u++)
              if (Rc(r, { type: 'LineString', coordinates: n.coordinates[u] })) return !0;
            return !1;
          case 'MultiPoint':
            for (a = !1, u = 0; u < r.coordinates.length; u++)
              if (
                (a ||
                  (Rc(
                    { type: 'Point', coordinates: r.coordinates[u] },
                    { type: 'LineString', coordinates: n.coordinates[0] },
                  ) &&
                    (a = !0)),
                Nc({ type: 'Point', coordinates: r.coordinates[u] }, n, { ignoreBoundary: !0 }))
              )
                return !1;
            return a;
          case 'LineString':
            for (a = !1, u = 0; u < r.coordinates.length; u++)
              if (
                (a ||
                  (Rc(
                    { type: 'Point', coordinates: r.coordinates[u] },
                    { type: 'LineString', coordinates: n.coordinates[0] },
                  ) &&
                    (a = !0)),
                Nc({ type: 'Point', coordinates: r.coordinates[u] }, n, { ignoreBoundary: !0 }))
              )
                return !1;
            return a;
          case 'MultiLineString':
            for (a = !1, u = 0; u < r.coordinates.length; u++)
              for (s = 0; s < r.coordinates[u].length; s++)
                if (
                  (a ||
                    (Rc(
                      { type: 'Point', coordinates: r.coordinates[u][s] },
                      { type: 'LineString', coordinates: n.coordinates[0] },
                    ) &&
                      (a = !0)),
                  Nc({ type: 'Point', coordinates: r.coordinates[u][s] }, n, { ignoreBoundary: !0 }))
                )
                  return !1;
            return a;
          case 'Polygon':
            for (a = !1, u = 0; u < n.coordinates[0].length; u++)
              if (
                (a ||
                  (Rc(
                    { type: 'Point', coordinates: n.coordinates[0][u] },
                    { type: 'LineString', coordinates: r.coordinates[0] },
                  ) &&
                    (a = !0)),
                Nc({ type: 'Point', coordinates: n.coordinates[0][u] }, r, { ignoreBoundary: !0 }))
              )
                return !1;
            return a;
          case 'MultiPolygon':
            for (a = !1, u = 0; u < r.coordinates[0].length; u++)
              for (s = 0; s < n.coordinates[0].length; s++)
                if (
                  (a ||
                    (Rc(
                      { type: 'Point', coordinates: n.coordinates[0][s] },
                      { type: 'LineString', coordinates: r.coordinates[0][u] },
                    ) &&
                      (a = !0)),
                  Nc(
                    { type: 'Point', coordinates: n.coordinates[0][s] },
                    { type: 'Polygon', coordinates: r.coordinates[0][u] },
                    { ignoreBoundary: !0 },
                  ))
                )
                  return !1;
            return a;
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'MultiPolygon':
        switch (o) {
          case 'Point':
            for (u = 0; u < n.coordinates[0].length; u++)
              if (Rc(r, { type: 'LineString', coordinates: n.coordinates[0][u] })) return !0;
            return !1;
          case 'MultiPoint':
            for (a = !1, u = 0; u < n.coordinates[0].length; u++)
              for (s = 0; s < r.coordinates.length; s++)
                if (
                  (a ||
                    (Rc(
                      { type: 'Point', coordinates: r.coordinates[s] },
                      { type: 'LineString', coordinates: n.coordinates[0][u] },
                    ) &&
                      (a = !0)),
                  Nc(
                    { type: 'Point', coordinates: r.coordinates[s] },
                    { type: 'Polygon', coordinates: n.coordinates[0][u] },
                    { ignoreBoundary: !0 },
                  ))
                )
                  return !1;
            return a;
          case 'LineString':
            for (a = !1, u = 0; u < n.coordinates[0].length; u++)
              for (s = 0; s < r.coordinates.length; s++)
                if (
                  (a ||
                    (Rc(
                      { type: 'Point', coordinates: r.coordinates[s] },
                      { type: 'LineString', coordinates: n.coordinates[0][u] },
                    ) &&
                      (a = !0)),
                  Nc(
                    { type: 'Point', coordinates: r.coordinates[s] },
                    { type: 'Polygon', coordinates: n.coordinates[0][u] },
                    { ignoreBoundary: !0 },
                  ))
                )
                  return !1;
            return a;
          case 'MultiLineString':
            for (a = !1, u = 0; u < n.coordinates.length; u++)
              for (s = 0; s < r.coordinates.length; s++)
                for (c = 0; c < r.coordinates[s].length; c++)
                  if (
                    (a ||
                      (Rc(
                        { type: 'Point', coordinates: r.coordinates[s][c] },
                        { type: 'LineString', coordinates: n.coordinates[u][0] },
                      ) &&
                        (a = !0)),
                    Nc(
                      { type: 'Point', coordinates: r.coordinates[s][c] },
                      { type: 'Polygon', coordinates: [n.coordinates[u][0]] },
                      { ignoreBoundary: !0 },
                    ))
                  )
                    return !1;
            return a;
          case 'Polygon':
            for (a = !1, u = 0; u < n.coordinates[0].length; u++)
              for (s = 0; s < n.coordinates[0][u].length; s++)
                if (
                  (a ||
                    (Rc(
                      { type: 'Point', coordinates: n.coordinates[0][u][s] },
                      { type: 'LineString', coordinates: r.coordinates[0] },
                    ) &&
                      (a = !0)),
                  Nc({ type: 'Point', coordinates: n.coordinates[0][u][s] }, r, { ignoreBoundary: !0 }))
                )
                  return !1;
            return a;
          case 'MultiPolygon':
            for (a = !1, u = 0; u < n.coordinates[0].length; u++)
              for (s = 0; s < r.coordinates[0].length; s++)
                for (c = 0; c < n.coordinates[0].length; c++)
                  if (
                    (a ||
                      (Rc(
                        { type: 'Point', coordinates: n.coordinates[0][u][c] },
                        { type: 'LineString', coordinates: r.coordinates[0][s] },
                      ) &&
                        (a = !0)),
                    Nc(
                      { type: 'Point', coordinates: n.coordinates[0][u][c] },
                      { type: 'Polygon', coordinates: r.coordinates[0][s] },
                      { ignoreBoundary: !0 },
                    ))
                  )
                    return !1;
            return a;
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      default:
        throw new Error('feature1 ' + i + ' geometry not supported');
    }
  }
  function qf(t, e) {
    return !!Vf(e.coordinates[0], t.coordinates) || !!Vf(e.coordinates[e.coordinates.length - 1], t.coordinates);
  }
  function Vf(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  Ff(Bf, 'booleanTouches'), Ff(qf, 'isPointOnLineEnd'), Ff(Vf, 'compareCoords');
  var Gf = Object.defineProperty,
    Yf = function (t, e) {
      return Gf(t, 'name', { value: e, configurable: !0 });
    };
  function zf(t) {
    if (!t.type) return !1;
    var e = cl(t),
      n = e.type,
      r = e.coordinates;
    switch (n) {
      case 'Point':
        return r.length > 1;
      case 'MultiPoint':
        for (var i = 0; i < r.length; i++) if (r[i].length < 2) return !1;
        return !0;
      case 'LineString':
        if (r.length < 2) return !1;
        for (i = 0; i < r.length; i++) if (r[i].length < 2) return !1;
        return !0;
      case 'MultiLineString':
        if (r.length < 2) return !1;
        for (i = 0; i < r.length; i++) if (r[i].length < 2) return !1;
        return !0;
      case 'Polygon':
        for (i = 0; i < e.coordinates.length; i++) {
          if (r[i].length < 4) return !1;
          if (!Uf(r[i])) return !1;
          if (Xf(r[i])) return !1;
          if (i > 0 && uh(Cu([r[0]]), Cu([r[i]])).features.length > 1) return !1;
        }
        return !0;
      case 'MultiPolygon':
        for (i = 0; i < e.coordinates.length; i++)
          for (var o = e.coordinates[i], a = 0; a < o.length; a++) {
            if (o[a].length < 4) return !1;
            if (!Uf(o[a])) return !1;
            if (Xf(o[a])) return !1;
            if (0 === a && !Wf(o, e.coordinates, i)) return !1;
            if (a > 0 && uh(Cu([o[0]]), Cu([o[a]])).features.length > 1) return !1;
          }
        return !0;
      default:
        return !1;
    }
  }
  function Uf(t) {
    return t[0][0] === t[t.length - 1][0] || t[0][1] === t[t.length - 1][1];
  }
  function Xf(t) {
    for (var e = 0; e < t.length - 1; e++)
      for (var n = t[e], r = e + 1; r < t.length - 2; r++) {
        if (Rc(n, Au([t[r], t[r + 1]]))) return !0;
      }
    return !1;
  }
  function Wf(t, e, n) {
    for (var r = Cu(t), i = n + 1; i < e.length; i++) if (!Sh(r, Cu(e[i])) && dh(r, Au(e[i][0]))) return !1;
    return !0;
  }
  Yf(zf, 'booleanValid'),
    Yf(Uf, 'checkRingsClose'),
    Yf(Xf, 'checkRingsForSpikesPunctures'),
    Yf(Wf, 'checkPolygonAgainstOthers');
  var Hf = Object.defineProperty,
    Zf = function (t, e) {
      return Hf(t, 'name', { value: e, configurable: !0 });
    };
  function Jf(t, e) {
    var n = cl(t),
      r = cl(e),
      i = n.type,
      o = r.type;
    switch (i) {
      case 'Point':
        switch (o) {
          case 'MultiPoint':
            return $f(n, r);
          case 'LineString':
            return Rc(n, r, { ignoreEndVertices: !0 });
          case 'Polygon':
          case 'MultiPolygon':
            return Nc(n, r, { ignoreBoundary: !0 });
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'MultiPoint':
        switch (o) {
          case 'MultiPoint':
            return Qf(n, r);
          case 'LineString':
            return Kf(n, r);
          case 'Polygon':
          case 'MultiPolygon':
            return tp(n, r);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'LineString':
        switch (o) {
          case 'LineString':
            return ep(n, r);
          case 'Polygon':
          case 'MultiPolygon':
            return np(n, r);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      case 'Polygon':
        switch (o) {
          case 'Polygon':
          case 'MultiPolygon':
            return rp(n, r);
          default:
            throw new Error('feature2 ' + o + ' geometry not supported');
        }
      default:
        throw new Error('feature1 ' + i + ' geometry not supported');
    }
  }
  function $f(t, e) {
    var n,
      r = !1;
    for (n = 0; n < e.coordinates.length; n++)
      if (op(e.coordinates[n], t.coordinates)) {
        r = !0;
        break;
      }
    return r;
  }
  function Qf(t, e) {
    for (var n = 0; n < t.coordinates.length; n++) {
      for (var r = !1, i = 0; i < e.coordinates.length; i++) op(t.coordinates[n], e.coordinates[i]) && (r = !0);
      if (!r) return !1;
    }
    return !0;
  }
  function Kf(t, e) {
    for (var n = !1, r = 0; r < t.coordinates.length; r++) {
      if (!Rc(t.coordinates[r], e)) return !1;
      n || (n = Rc(t.coordinates[r], e, { ignoreEndVertices: !0 }));
    }
    return n;
  }
  function tp(t, e) {
    for (var n = !0, r = !1, i = 0; i < t.coordinates.length; i++) {
      if (!(r = Nc(t.coordinates[i], e))) {
        n = !1;
        break;
      }
      r = Nc(t.coordinates[i], e, { ignoreBoundary: !0 });
    }
    return n && r;
  }
  function ep(t, e) {
    for (var n = 0; n < t.coordinates.length; n++) if (!Rc(t.coordinates[n], e)) return !1;
    return !0;
  }
  function np(t, e) {
    if (!ip(rc(e), rc(t))) return !1;
    for (var n = !1, r = 0; r < t.coordinates.length; r++) {
      if (!Nc(t.coordinates[r], e)) return !1;
      if ((n || (n = Nc(t.coordinates[r], e, { ignoreBoundary: !0 })), !n && r < t.coordinates.length - 1))
        n = Nc(ap(t.coordinates[r], t.coordinates[r + 1]), e, { ignoreBoundary: !0 });
    }
    return n;
  }
  function rp(t, e) {
    var n = rc(t);
    if (!ip(rc(e), n)) return !1;
    for (var r = 0; r < t.coordinates[0].length; r++) if (!Nc(t.coordinates[0][r], e)) return !1;
    return !0;
  }
  function ip(t, e) {
    return !(t[0] > e[0]) && !(t[2] < e[2]) && !(t[1] > e[1]) && !(t[3] < e[3]);
  }
  function op(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  function ap(t, e) {
    return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2];
  }
  Zf(Jf, 'booleanWithin'),
    Zf($f, 'isPointInMultiPoint'),
    Zf(Qf, 'isMultiPointInMultiPoint'),
    Zf(Kf, 'isMultiPointOnLine'),
    Zf(tp, 'isMultiPointInPoly'),
    Zf(ep, 'isLineOnLine'),
    Zf(np, 'isLineInPoly'),
    Zf(rp, 'isPolyInPoly'),
    Zf(ip, 'doBBoxOverlap'),
    Zf(op, 'compareCoords'),
    Zf(ap, 'getMidpoint');
  var sp = Object.defineProperty;
  function up(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = rc(t);
    return Lu([(n[0] + n[2]) / 2, (n[1] + n[3]) / 2], e.properties, e);
  }
  !(function (t, e) {
    sp(t, 'name', { value: e, configurable: !0 });
  })(up, 'center');
  var lp = { exports: {} };
  !(function (t, n) {
    t.exports = (function () {
      function t(t, e) {
        if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function');
      }
      function n(t, e) {
        for (var n = 0; n < e.length; n++) {
          var r = e[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            'value' in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function r(t, e, r) {
        return e && n(t.prototype, e), r && n(t, r), t;
      }
      function i(t, e) {
        if ('function' != typeof e && null !== e)
          throw new TypeError('Super expression must either be null or a function');
        (t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } })),
          e && a(t, e);
      }
      function o(t) {
        return (
          (o = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t);
              }),
          o(t)
        );
      }
      function a(t, e) {
        return (
          (a =
            Object.setPrototypeOf ||
            function (t, e) {
              return (t.__proto__ = e), t;
            }),
          a(t, e)
        );
      }
      function s() {
        if ('undefined' == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ('function' == typeof Proxy) return !0;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
        } catch (t) {
          return !1;
        }
      }
      function u(t, e, n) {
        return (
          (u = s()
            ? Reflect.construct
            : function (t, e, n) {
                var r = [null];
                r.push.apply(r, e);
                var i = new (Function.bind.apply(t, r))();
                return n && a(i, n.prototype), i;
              }),
          u.apply(null, arguments)
        );
      }
      function l(t) {
        var e = 'function' == typeof Map ? new Map() : void 0;
        return (
          (l = function (t) {
            if (null === t || ((n = t), -1 === Function.toString.call(n).indexOf('[native code]'))) return t;
            var n;
            if ('function' != typeof t) throw new TypeError('Super expression must either be null or a function');
            if (void 0 !== e) {
              if (e.has(t)) return e.get(t);
              e.set(t, r);
            }
            function r() {
              return u(t, arguments, o(this).constructor);
            }
            return (
              (r.prototype = Object.create(t.prototype, {
                constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 },
              })),
              a(r, t)
            );
          }),
          l(t)
        );
      }
      function c(t) {
        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t;
      }
      function h(t, n) {
        if (n && ('object' == e(n) || 'function' == typeof n)) return n;
        if (void 0 !== n) throw new TypeError('Derived constructors may only return object or undefined');
        return c(t);
      }
      function f(t) {
        var e = s();
        return function () {
          var n,
            r = o(t);
          if (e) {
            var i = o(this).constructor;
            n = Reflect.construct(r, arguments, i);
          } else n = r.apply(this, arguments);
          return h(this, n);
        };
      }
      function p(t, e, n) {
        return (
          (p =
            'undefined' != typeof Reflect && Reflect.get
              ? Reflect.get
              : function (t, e, n) {
                  var r = (function (t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = o(t)); );
                    return t;
                  })(t, e);
                  if (r) {
                    var i = Object.getOwnPropertyDescriptor(r, e);
                    return i.get ? i.get.call(n) : i.value;
                  }
                }),
          p(t, e, n || t)
        );
      }
      function g(t) {
        return (
          (function (t) {
            if (Array.isArray(t)) return v(t);
          })(t) ||
          (function (t) {
            if (('undefined' != typeof Symbol && null != t[Symbol.iterator]) || null != t['@@iterator'])
              return Array.from(t);
          })(t) ||
          y(t) ||
          (function () {
            throw new TypeError(
              'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
            );
          })()
        );
      }
      function y(t, e) {
        if (t) {
          if ('string' == typeof t) return v(t, e);
          var n = Object.prototype.toString.call(t).slice(8, -1);
          return (
            'Object' === n && t.constructor && (n = t.constructor.name),
            'Map' === n || 'Set' === n
              ? Array.from(t)
              : 'Arguments' === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? v(t, e)
              : void 0
          );
        }
      }
      function v(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      function d(t, e) {
        var n = ('undefined' != typeof Symbol && t[Symbol.iterator]) || t['@@iterator'];
        if (!n) {
          if (Array.isArray(t) || (n = y(t)) || (e && t && 'number' == typeof t.length)) {
            n && (t = n);
            var r = 0,
              i = function () {};
            return {
              s: i,
              n: function () {
                return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] };
              },
              e: function (t) {
                throw t;
              },
              f: i,
            };
          }
          throw new TypeError(
            'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
          );
        }
        var o,
          a = !0,
          s = !1;
        return {
          s: function () {
            n = n.call(t);
          },
          n: function () {
            var t = n.next();
            return (a = t.done), t;
          },
          e: function (t) {
            (s = !0), (o = t);
          },
          f: function () {
            try {
              a || null == n.return || n.return();
            } finally {
              if (s) throw o;
            }
          },
        };
      }
      var m = (function () {
        function e() {
          t(this, e), e.constructor_.apply(this, arguments);
        }
        return (
          r(
            e,
            [
              {
                key: 'getEndCapStyle',
                value: function () {
                  return this._endCapStyle;
                },
              },
              {
                key: 'isSingleSided',
                value: function () {
                  return this._isSingleSided;
                },
              },
              {
                key: 'setQuadrantSegments',
                value: function (t) {
                  (this._quadrantSegments = t),
                    0 === this._quadrantSegments && (this._joinStyle = e.JOIN_BEVEL),
                    this._quadrantSegments < 0 &&
                      ((this._joinStyle = e.JOIN_MITRE), (this._mitreLimit = Math.abs(this._quadrantSegments))),
                    t <= 0 && (this._quadrantSegments = 1),
                    this._joinStyle !== e.JOIN_ROUND && (this._quadrantSegments = e.DEFAULT_QUADRANT_SEGMENTS);
                },
              },
              {
                key: 'getJoinStyle',
                value: function () {
                  return this._joinStyle;
                },
              },
              {
                key: 'setJoinStyle',
                value: function (t) {
                  this._joinStyle = t;
                },
              },
              {
                key: 'setSimplifyFactor',
                value: function (t) {
                  this._simplifyFactor = t < 0 ? 0 : t;
                },
              },
              {
                key: 'getSimplifyFactor',
                value: function () {
                  return this._simplifyFactor;
                },
              },
              {
                key: 'getQuadrantSegments',
                value: function () {
                  return this._quadrantSegments;
                },
              },
              {
                key: 'setEndCapStyle',
                value: function (t) {
                  this._endCapStyle = t;
                },
              },
              {
                key: 'getMitreLimit',
                value: function () {
                  return this._mitreLimit;
                },
              },
              {
                key: 'setMitreLimit',
                value: function (t) {
                  this._mitreLimit = t;
                },
              },
              {
                key: 'setSingleSided',
                value: function (t) {
                  this._isSingleSided = t;
                },
              },
            ],
            [
              {
                key: 'constructor_',
                value: function () {
                  if (
                    ((this._quadrantSegments = e.DEFAULT_QUADRANT_SEGMENTS),
                    (this._endCapStyle = e.CAP_ROUND),
                    (this._joinStyle = e.JOIN_ROUND),
                    (this._mitreLimit = e.DEFAULT_MITRE_LIMIT),
                    (this._isSingleSided = !1),
                    (this._simplifyFactor = e.DEFAULT_SIMPLIFY_FACTOR),
                    0 === arguments.length)
                  );
                  else if (1 === arguments.length) {
                    var t = arguments[0];
                    this.setQuadrantSegments(t);
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      r = arguments[1];
                    this.setQuadrantSegments(n), this.setEndCapStyle(r);
                  } else if (4 === arguments.length) {
                    var i = arguments[0],
                      o = arguments[1],
                      a = arguments[2],
                      s = arguments[3];
                    this.setQuadrantSegments(i), this.setEndCapStyle(o), this.setJoinStyle(a), this.setMitreLimit(s);
                  }
                },
              },
              {
                key: 'bufferDistanceError',
                value: function (t) {
                  var e = Math.PI / 2 / t;
                  return 1 - Math.cos(e / 2);
                },
              },
            ],
          ),
          e
        );
      })();
      (m.CAP_ROUND = 1),
        (m.CAP_FLAT = 2),
        (m.CAP_SQUARE = 3),
        (m.JOIN_ROUND = 1),
        (m.JOIN_MITRE = 2),
        (m.JOIN_BEVEL = 3),
        (m.DEFAULT_QUADRANT_SEGMENTS = 8),
        (m.DEFAULT_MITRE_LIMIT = 5),
        (m.DEFAULT_SIMPLIFY_FACTOR = 0.01);
      var _ = (function (e) {
          i(o, e);
          var n = f(o);
          function o(e) {
            var r;
            return t(this, o), ((r = n.call(this, e)).name = Object.keys({ Exception: o })[0]), r;
          }
          return (
            r(o, [
              {
                key: 'toString',
                value: function () {
                  return this.message;
                },
              },
            ]),
            o
          );
        })(l(Error)),
        b = (function (e) {
          i(r, e);
          var n = f(r);
          function r(e) {
            var i;
            return t(this, r), ((i = n.call(this, e)).name = Object.keys({ IllegalArgumentException: r })[0]), i;
          }
          return r;
        })(_),
        x = (function () {
          function e() {
            t(this, e);
          }
          return r(e, [{ key: 'filter', value: function (t) {} }]), e;
        })();
      function E() {}
      function w() {}
      function k() {}
      var S,
        I,
        P,
        N,
        M,
        O,
        L,
        R,
        C = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'equalsWithTolerance',
                value: function (t, e, n) {
                  return Math.abs(t - e) <= n;
                },
              },
            ]),
            e
          );
        })(),
        T = (function () {
          function e(n, r) {
            t(this, e), (this.low = r || 0), (this.high = n || 0);
          }
          return (
            r(e, null, [
              {
                key: 'toBinaryString',
                value: function (t) {
                  var e,
                    n = '';
                  for (e = 2147483648; e > 0; e >>>= 1) n += (t.high & e) === e ? '1' : '0';
                  for (e = 2147483648; e > 0; e >>>= 1) n += (t.low & e) === e ? '1' : '0';
                  return n;
                },
              },
            ]),
            e
          );
        })();
      function A() {}
      function D() {}
      (A.NaN = NaN),
        (A.isNaN = function (t) {
          return Number.isNaN(t);
        }),
        (A.isInfinite = function (t) {
          return !Number.isFinite(t);
        }),
        (A.MAX_VALUE = Number.MAX_VALUE),
        (A.POSITIVE_INFINITY = Number.POSITIVE_INFINITY),
        (A.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY),
        'function' == typeof Float64Array && 'function' == typeof Int32Array
          ? ((O = 2146435072),
            (L = new Float64Array(1)),
            (R = new Int32Array(L.buffer)),
            (A.doubleToLongBits = function (t) {
              L[0] = t;
              var e = 0 | R[0],
                n = 0 | R[1];
              return (n & O) === O && 0 != (1048575 & n) && 0 !== e && ((e = 0), (n = 2146959360)), new T(n, e);
            }),
            (A.longBitsToDouble = function (t) {
              return (R[0] = t.low), (R[1] = t.high), L[0];
            }))
          : ((S = 1023),
            (I = Math.log2),
            (P = Math.floor),
            (N = Math.pow),
            (M = (function () {
              for (var t = 53; t > 0; t--) {
                var e = N(2, t) - 1;
                if (P(I(e)) + 1 === t) return e;
              }
              return 0;
            })()),
            (A.doubleToLongBits = function (t) {
              var e, n, r, i, o, a, s, u, l;
              if ((t < 0 || 1 / t === Number.NEGATIVE_INFINITY ? ((a = 1 << 31), (t = -t)) : (a = 0), 0 === t))
                return new T((u = a), (l = 0));
              if (t === 1 / 0) return new T((u = 2146435072 | a), (l = 0));
              if (t != t) return new T((u = 2146959360), (l = 0));
              if (((i = 0), (l = 0), (e = P(t)) > 1))
                if (e <= M)
                  (i = P(I(e))) <= 20
                    ? ((l = 0), (u = (e << (20 - i)) & 1048575))
                    : ((l = e % (n = N(2, (r = i - 20))) << (32 - r)), (u = (e / n) & 1048575));
                else
                  for (r = e, l = 0; 0 !== (r = P((n = r / 2))); )
                    i++, (l >>>= 1), (l |= (1 & u) << 31), (u >>>= 1), n !== r && (u |= 524288);
              if (((s = i + S), (o = 0 === e), (e = t - e), i < 52 && 0 !== e))
                for (r = 0; ; ) {
                  if (
                    ((n = 2 * e) >= 1
                      ? ((e = n - 1), o ? (s--, (o = !1)) : ((r <<= 1), (r |= 1), i++))
                      : ((e = n), o ? 0 == --s && (i++, (o = !1)) : ((r <<= 1), i++)),
                    20 === i)
                  )
                    (u |= r), (r = 0);
                  else if (52 === i) {
                    l |= r;
                    break;
                  }
                  if (1 === n) {
                    i < 20 ? (u |= r << (20 - i)) : i < 52 && (l |= r << (52 - i));
                    break;
                  }
                }
              return (u |= s << 20), new T((u |= a), l);
            }),
            (A.longBitsToDouble = function (t) {
              var e,
                n,
                r,
                i,
                o = t.high,
                a = t.low,
                s = o & (1 << 31) ? -1 : 1;
              for (r = ((2146435072 & o) >> 20) - S, i = 0, n = 1 << 19, e = 1; e <= 20; e++)
                o & n && (i += N(2, -e)), (n >>>= 1);
              for (n = 1 << 31, e = 21; e <= 52; e++) a & n && (i += N(2, -e)), (n >>>= 1);
              if (-1023 === r) {
                if (0 === i) return 0 * s;
                r = -1022;
              } else {
                if (1024 === r) return 0 === i ? s / 0 : NaN;
                i += 1;
              }
              return s * i * N(2, r);
            }));
      var j = (function (e) {
          i(r, e);
          var n = f(r);
          function r(e) {
            var i;
            return t(this, r), ((i = n.call(this, e)).name = Object.keys({ RuntimeException: r })[0]), i;
          }
          return r;
        })(_),
        F = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(o, null, [
              {
                key: 'constructor_',
                value: function () {
                  if (0 === arguments.length) j.constructor_.call(this);
                  else if (1 === arguments.length) {
                    var t = arguments[0];
                    j.constructor_.call(this, t);
                  }
                },
              },
            ]),
            o
          );
        })(j),
        B = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'shouldNeverReachHere',
                value: function () {
                  if (0 === arguments.length) e.shouldNeverReachHere(null);
                  else if (1 === arguments.length) {
                    var t = arguments[0];
                    throw new F('Should never reach here' + (null !== t ? ': ' + t : ''));
                  }
                },
              },
              {
                key: 'isTrue',
                value: function () {
                  if (1 === arguments.length) {
                    var t = arguments[0];
                    e.isTrue(t, null);
                  } else if (2 === arguments.length) {
                    var n = arguments[1];
                    if (!arguments[0]) throw null === n ? new F() : new F(n);
                  }
                },
              },
              {
                key: 'equals',
                value: function () {
                  if (2 === arguments.length) {
                    var t = arguments[0],
                      n = arguments[1];
                    e.equals(t, n, null);
                  } else if (3 === arguments.length) {
                    var r = arguments[0],
                      i = arguments[1],
                      o = arguments[2];
                    if (!i.equals(r))
                      throw new F('Expected ' + r + ' but encountered ' + i + (null !== o ? ': ' + o : ''));
                  }
                },
              },
            ]),
            e
          );
        })(),
        q = new ArrayBuffer(8),
        V = new Float64Array(q),
        G = new Int32Array(q),
        Y = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getM',
                  value: function () {
                    return A.NaN;
                  },
                },
                {
                  key: 'setOrdinate',
                  value: function (t, n) {
                    switch (t) {
                      case e.X:
                        this.x = n;
                        break;
                      case e.Y:
                        this.y = n;
                        break;
                      case e.Z:
                        this.setZ(n);
                        break;
                      default:
                        throw new b('Invalid ordinate index: ' + t);
                    }
                  },
                },
                {
                  key: 'equals2D',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      return this.x === t.x && this.y === t.y;
                    }
                    if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      return !!C.equalsWithTolerance(this.x, e.x, n) && !!C.equalsWithTolerance(this.y, e.y, n);
                    }
                  },
                },
                {
                  key: 'setM',
                  value: function (t) {
                    throw new b('Invalid ordinate index: ' + e.M);
                  },
                },
                {
                  key: 'getZ',
                  value: function () {
                    return this.z;
                  },
                },
                {
                  key: 'getOrdinate',
                  value: function (t) {
                    switch (t) {
                      case e.X:
                        return this.x;
                      case e.Y:
                        return this.y;
                      case e.Z:
                        return this.getZ();
                    }
                    throw new b('Invalid ordinate index: ' + t);
                  },
                },
                {
                  key: 'equals3D',
                  value: function (t) {
                    return (
                      this.x === t.x &&
                      this.y === t.y &&
                      (this.getZ() === t.getZ() || (A.isNaN(this.getZ()) && A.isNaN(t.getZ())))
                    );
                  },
                },
                {
                  key: 'equals',
                  value: function (t) {
                    return t instanceof e && this.equals2D(t);
                  },
                },
                {
                  key: 'equalInZ',
                  value: function (t, e) {
                    return C.equalsWithTolerance(this.getZ(), t.getZ(), e);
                  },
                },
                {
                  key: 'setX',
                  value: function (t) {
                    this.x = t;
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0;
                  },
                },
                {
                  key: 'getX',
                  value: function () {
                    return this.x;
                  },
                },
                {
                  key: 'setZ',
                  value: function (t) {
                    this.z = t;
                  },
                },
                {
                  key: 'clone',
                  value: function () {
                    try {
                      return null;
                    } catch (t) {
                      if (t instanceof CloneNotSupportedException)
                        return B.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
                      throw t;
                    }
                  },
                },
                {
                  key: 'copy',
                  value: function () {
                    return new e(this);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ')';
                  },
                },
                {
                  key: 'distance3D',
                  value: function (t) {
                    var e = this.x - t.x,
                      n = this.y - t.y,
                      r = this.getZ() - t.getZ();
                    return Math.sqrt(e * e + n * n + r * r);
                  },
                },
                {
                  key: 'getY',
                  value: function () {
                    return this.y;
                  },
                },
                {
                  key: 'setY',
                  value: function (t) {
                    this.y = t;
                  },
                },
                {
                  key: 'distance',
                  value: function (t) {
                    var e = this.x - t.x,
                      n = this.y - t.y;
                    return Math.sqrt(e * e + n * n);
                  },
                },
                {
                  key: 'hashCode',
                  value: function () {
                    var t = 17;
                    return 37 * (t = 37 * t + e.hashCode(this.x)) + e.hashCode(this.y);
                  },
                },
                {
                  key: 'setCoordinate',
                  value: function (t) {
                    (this.x = t.x), (this.y = t.y), (this.z = t.getZ());
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E, w, k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this.x = null), (this.y = null), (this.z = null), 0 === arguments.length))
                      e.constructor_.call(this, 0, 0);
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      e.constructor_.call(this, t.x, t.y, t.getZ());
                    } else if (2 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1];
                      e.constructor_.call(this, n, r, e.NULL_ORDINATE);
                    } else if (3 === arguments.length) {
                      var i = arguments[0],
                        o = arguments[1],
                        a = arguments[2];
                      (this.x = i), (this.y = o), (this.z = a);
                    }
                  },
                },
                {
                  key: 'hashCode',
                  value: function (t) {
                    return (V[0] = t), G[0] ^ G[1];
                  },
                },
              ],
            ),
            e
          );
        })(),
        z = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'compare',
                  value: function (t, n) {
                    var r = e.compare(t.x, n.x);
                    if (0 !== r) return r;
                    var i = e.compare(t.y, n.y);
                    return 0 !== i ? i : this._dimensionsToTest <= 2 ? 0 : e.compare(t.getZ(), n.getZ());
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [D];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._dimensionsToTest = 2), 0 === arguments.length)) e.constructor_.call(this, 2);
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      if (2 !== t && 3 !== t) throw new b('only 2 or 3 dimensions may be specified');
                      this._dimensionsToTest = t;
                    }
                  },
                },
                {
                  key: 'compare',
                  value: function (t, e) {
                    return t < e ? -1 : t > e ? 1 : A.isNaN(t) ? (A.isNaN(e) ? 0 : -1) : A.isNaN(e) ? 1 : 0;
                  },
                },
              ],
            ),
            e
          );
        })();
      (Y.DimensionalComparator = z), (Y.NULL_ORDINATE = A.NaN), (Y.X = 0), (Y.Y = 1), (Y.Z = 2), (Y.M = 3);
      var U = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getArea',
                  value: function () {
                    return this.getWidth() * this.getHeight();
                  },
                },
                {
                  key: 'equals',
                  value: function (t) {
                    if (!(t instanceof e)) return !1;
                    var n = t;
                    return this.isNull()
                      ? n.isNull()
                      : this._maxx === n.getMaxX() &&
                          this._maxy === n.getMaxY() &&
                          this._minx === n.getMinX() &&
                          this._miny === n.getMinY();
                  },
                },
                {
                  key: 'intersection',
                  value: function (t) {
                    if (this.isNull() || t.isNull() || !this.intersects(t)) return new e();
                    var n = this._minx > t._minx ? this._minx : t._minx,
                      r = this._miny > t._miny ? this._miny : t._miny;
                    return new e(
                      n,
                      this._maxx < t._maxx ? this._maxx : t._maxx,
                      r,
                      this._maxy < t._maxy ? this._maxy : t._maxy,
                    );
                  },
                },
                {
                  key: 'isNull',
                  value: function () {
                    return this._maxx < this._minx;
                  },
                },
                {
                  key: 'getMaxX',
                  value: function () {
                    return this._maxx;
                  },
                },
                {
                  key: 'covers',
                  value: function () {
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof Y) {
                        var t = arguments[0];
                        return this.covers(t.x, t.y);
                      }
                      if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        return (
                          !this.isNull() &&
                          !n.isNull() &&
                          n.getMinX() >= this._minx &&
                          n.getMaxX() <= this._maxx &&
                          n.getMinY() >= this._miny &&
                          n.getMaxY() <= this._maxy
                        );
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      return !this.isNull() && r >= this._minx && r <= this._maxx && i >= this._miny && i <= this._maxy;
                    }
                  },
                },
                {
                  key: 'intersects',
                  value: function () {
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof e) {
                        var t = arguments[0];
                        return (
                          !this.isNull() &&
                          !t.isNull() &&
                          !(
                            t._minx > this._maxx ||
                            t._maxx < this._minx ||
                            t._miny > this._maxy ||
                            t._maxy < this._miny
                          )
                        );
                      }
                      if (arguments[0] instanceof Y) {
                        var n = arguments[0];
                        return this.intersects(n.x, n.y);
                      }
                    } else if (2 === arguments.length) {
                      if (arguments[0] instanceof Y && arguments[1] instanceof Y) {
                        var r = arguments[0],
                          i = arguments[1];
                        return !(
                          this.isNull() ||
                          (r.x < i.x ? r.x : i.x) > this._maxx ||
                          (r.x > i.x ? r.x : i.x) < this._minx ||
                          (r.y < i.y ? r.y : i.y) > this._maxy ||
                          (r.y > i.y ? r.y : i.y) < this._miny
                        );
                      }
                      if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
                        var o = arguments[0],
                          a = arguments[1];
                        return (
                          !this.isNull() && !(o > this._maxx || o < this._minx || a > this._maxy || a < this._miny)
                        );
                      }
                    }
                  },
                },
                {
                  key: 'getMinY',
                  value: function () {
                    return this._miny;
                  },
                },
                {
                  key: 'getDiameter',
                  value: function () {
                    if (this.isNull()) return 0;
                    var t = this.getWidth(),
                      e = this.getHeight();
                    return Math.sqrt(t * t + e * e);
                  },
                },
                {
                  key: 'getMinX',
                  value: function () {
                    return this._minx;
                  },
                },
                {
                  key: 'expandToInclude',
                  value: function () {
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof Y) {
                        var t = arguments[0];
                        this.expandToInclude(t.x, t.y);
                      } else if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        if (n.isNull()) return null;
                        this.isNull()
                          ? ((this._minx = n.getMinX()),
                            (this._maxx = n.getMaxX()),
                            (this._miny = n.getMinY()),
                            (this._maxy = n.getMaxY()))
                          : (n._minx < this._minx && (this._minx = n._minx),
                            n._maxx > this._maxx && (this._maxx = n._maxx),
                            n._miny < this._miny && (this._miny = n._miny),
                            n._maxy > this._maxy && (this._maxy = n._maxy));
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      this.isNull()
                        ? ((this._minx = r), (this._maxx = r), (this._miny = i), (this._maxy = i))
                        : (r < this._minx && (this._minx = r),
                          r > this._maxx && (this._maxx = r),
                          i < this._miny && (this._miny = i),
                          i > this._maxy && (this._maxy = i));
                    }
                  },
                },
                {
                  key: 'minExtent',
                  value: function () {
                    if (this.isNull()) return 0;
                    var t = this.getWidth(),
                      e = this.getHeight();
                    return t < e ? t : e;
                  },
                },
                {
                  key: 'getWidth',
                  value: function () {
                    return this.isNull() ? 0 : this._maxx - this._minx;
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    return this.isNull()
                      ? e.isNull()
                        ? 0
                        : -1
                      : e.isNull()
                      ? 1
                      : this._minx < e._minx
                      ? -1
                      : this._minx > e._minx
                      ? 1
                      : this._miny < e._miny
                      ? -1
                      : this._miny > e._miny
                      ? 1
                      : this._maxx < e._maxx
                      ? -1
                      : this._maxx > e._maxx
                      ? 1
                      : this._maxy < e._maxy
                      ? -1
                      : this._maxy > e._maxy
                      ? 1
                      : 0;
                  },
                },
                {
                  key: 'translate',
                  value: function (t, e) {
                    if (this.isNull()) return null;
                    this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e);
                  },
                },
                {
                  key: 'copy',
                  value: function () {
                    return new e(this);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']';
                  },
                },
                {
                  key: 'setToNull',
                  value: function () {
                    (this._minx = 0), (this._maxx = -1), (this._miny = 0), (this._maxy = -1);
                  },
                },
                {
                  key: 'disjoint',
                  value: function (t) {
                    return (
                      !(!this.isNull() && !t.isNull()) ||
                      t._minx > this._maxx ||
                      t._maxx < this._minx ||
                      t._miny > this._maxy ||
                      t._maxy < this._miny
                    );
                  },
                },
                {
                  key: 'getHeight',
                  value: function () {
                    return this.isNull() ? 0 : this._maxy - this._miny;
                  },
                },
                {
                  key: 'maxExtent',
                  value: function () {
                    if (this.isNull()) return 0;
                    var t = this.getWidth(),
                      e = this.getHeight();
                    return t > e ? t : e;
                  },
                },
                {
                  key: 'expandBy',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      this.expandBy(t, t);
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      if (this.isNull()) return null;
                      (this._minx -= e),
                        (this._maxx += e),
                        (this._miny -= n),
                        (this._maxy += n),
                        (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
                    }
                  },
                },
                {
                  key: 'contains',
                  value: function () {
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof e) {
                        var t = arguments[0];
                        return this.covers(t);
                      }
                      if (arguments[0] instanceof Y) {
                        var n = arguments[0];
                        return this.covers(n);
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      return this.covers(r, i);
                    }
                  },
                },
                {
                  key: 'centre',
                  value: function () {
                    return this.isNull()
                      ? null
                      : new Y((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
                  },
                },
                {
                  key: 'init',
                  value: function () {
                    if (0 === arguments.length) this.setToNull();
                    else if (1 === arguments.length) {
                      if (arguments[0] instanceof Y) {
                        var t = arguments[0];
                        this.init(t.x, t.x, t.y, t.y);
                      } else if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        (this._minx = n._minx), (this._maxx = n._maxx), (this._miny = n._miny), (this._maxy = n._maxy);
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      this.init(r.x, i.x, r.y, i.y);
                    } else if (4 === arguments.length) {
                      var o = arguments[0],
                        a = arguments[1],
                        s = arguments[2],
                        u = arguments[3];
                      o < a ? ((this._minx = o), (this._maxx = a)) : ((this._minx = a), (this._maxx = o)),
                        s < u ? ((this._miny = s), (this._maxy = u)) : ((this._miny = u), (this._maxy = s));
                    }
                  },
                },
                {
                  key: 'getMaxY',
                  value: function () {
                    return this._maxy;
                  },
                },
                {
                  key: 'distance',
                  value: function (t) {
                    if (this.intersects(t)) return 0;
                    var e = 0;
                    this._maxx < t._minx
                      ? (e = t._minx - this._maxx)
                      : this._minx > t._maxx && (e = this._minx - t._maxx);
                    var n = 0;
                    return (
                      this._maxy < t._miny
                        ? (n = t._miny - this._maxy)
                        : this._miny > t._maxy && (n = this._miny - t._maxy),
                      0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n)
                    );
                  },
                },
                {
                  key: 'hashCode',
                  value: function () {
                    var t = 17;
                    return (
                      37 *
                        (t =
                          37 * (t = 37 * (t = 37 * t + Y.hashCode(this._minx)) + Y.hashCode(this._maxx)) +
                          Y.hashCode(this._miny)) +
                      Y.hashCode(this._maxy)
                    );
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E, k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._minx = null),
                      (this._maxx = null),
                      (this._miny = null),
                      (this._maxy = null),
                      0 === arguments.length)
                    )
                      this.init();
                    else if (1 === arguments.length) {
                      if (arguments[0] instanceof Y) {
                        var t = arguments[0];
                        this.init(t.x, t.x, t.y, t.y);
                      } else if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        this.init(n);
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      this.init(r.x, i.x, r.y, i.y);
                    } else if (4 === arguments.length) {
                      var o = arguments[0],
                        a = arguments[1],
                        s = arguments[2],
                        u = arguments[3];
                      this.init(o, a, s, u);
                    }
                  },
                },
                {
                  key: 'intersects',
                  value: function () {
                    if (3 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2];
                      return (
                        n.x >= (t.x < e.x ? t.x : e.x) &&
                        n.x <= (t.x > e.x ? t.x : e.x) &&
                        n.y >= (t.y < e.y ? t.y : e.y) &&
                        n.y <= (t.y > e.y ? t.y : e.y)
                      );
                    }
                    if (4 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1],
                        o = arguments[2],
                        a = arguments[3],
                        s = Math.min(o.x, a.x),
                        u = Math.max(o.x, a.x),
                        l = Math.min(r.x, i.x),
                        c = Math.max(r.x, i.x);
                      return !(
                        l > u ||
                        c < s ||
                        ((s = Math.min(o.y, a.y)),
                        (u = Math.max(o.y, a.y)),
                        (l = Math.min(r.y, i.y)),
                        (c = Math.max(r.y, i.y)),
                        l > u || c < s)
                      );
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        X = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'isGeometryCollection',
                  value: function () {
                    return this.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION;
                  },
                },
                {
                  key: 'getFactory',
                  value: function () {
                    return this._factory;
                  },
                },
                {
                  key: 'getGeometryN',
                  value: function (t) {
                    return this;
                  },
                },
                {
                  key: 'getArea',
                  value: function () {
                    return 0;
                  },
                },
                {
                  key: 'isRectangle',
                  value: function () {
                    return !1;
                  },
                },
                {
                  key: 'equalsExact',
                  value: function (t) {
                    return this === t || this.equalsExact(t, 0);
                  },
                },
                {
                  key: 'geometryChanged',
                  value: function () {
                    this.apply(e.geometryChangedFilter);
                  },
                },
                {
                  key: 'geometryChangedAction',
                  value: function () {
                    this._envelope = null;
                  },
                },
                {
                  key: 'equalsNorm',
                  value: function (t) {
                    return null !== t && this.norm().equalsExact(t.norm());
                  },
                },
                {
                  key: 'getLength',
                  value: function () {
                    return 0;
                  },
                },
                {
                  key: 'getNumGeometries',
                  value: function () {
                    return 1;
                  },
                },
                {
                  key: 'compareTo',
                  value: function () {
                    var t;
                    if (1 === arguments.length) {
                      var e = arguments[0];
                      return (
                        (t = e),
                        this.getTypeCode() !== t.getTypeCode()
                          ? this.getTypeCode() - t.getTypeCode()
                          : this.isEmpty() && t.isEmpty()
                          ? 0
                          : this.isEmpty()
                          ? -1
                          : t.isEmpty()
                          ? 1
                          : this.compareToSameClass(e)
                      );
                    }
                    if (2 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1];
                      return (
                        (t = n),
                        this.getTypeCode() !== t.getTypeCode()
                          ? this.getTypeCode() - t.getTypeCode()
                          : this.isEmpty() && t.isEmpty()
                          ? 0
                          : this.isEmpty()
                          ? -1
                          : t.isEmpty()
                          ? 1
                          : this.compareToSameClass(n, r)
                      );
                    }
                  },
                },
                {
                  key: 'getUserData',
                  value: function () {
                    return this._userData;
                  },
                },
                {
                  key: 'getSRID',
                  value: function () {
                    return this._SRID;
                  },
                },
                {
                  key: 'getEnvelope',
                  value: function () {
                    return this.getFactory().toGeometry(this.getEnvelopeInternal());
                  },
                },
                {
                  key: 'checkNotGeometryCollection',
                  value: function (t) {
                    if (t.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION)
                      throw new b('This method does not support GeometryCollection arguments');
                  },
                },
                {
                  key: 'equal',
                  value: function (t, e, n) {
                    return 0 === n ? t.equals(e) : t.distance(e) <= n;
                  },
                },
                {
                  key: 'norm',
                  value: function () {
                    var t = this.copy();
                    return t.normalize(), t;
                  },
                },
                {
                  key: 'reverse',
                  value: function () {
                    var t = this.reverseInternal();
                    return null != this.envelope && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t;
                  },
                },
                {
                  key: 'copy',
                  value: function () {
                    var t = this.copyInternal();
                    return (
                      (t.envelope = null == this._envelope ? null : this._envelope.copy()),
                      (t._SRID = this._SRID),
                      (t._userData = this._userData),
                      t
                    );
                  },
                },
                {
                  key: 'getPrecisionModel',
                  value: function () {
                    return this._factory.getPrecisionModel();
                  },
                },
                {
                  key: 'getEnvelopeInternal',
                  value: function () {
                    return (
                      null === this._envelope && (this._envelope = this.computeEnvelopeInternal()),
                      new U(this._envelope)
                    );
                  },
                },
                {
                  key: 'setSRID',
                  value: function (t) {
                    this._SRID = t;
                  },
                },
                {
                  key: 'setUserData',
                  value: function (t) {
                    this._userData = t;
                  },
                },
                {
                  key: 'compare',
                  value: function (t, e) {
                    for (var n = t.iterator(), r = e.iterator(); n.hasNext() && r.hasNext(); ) {
                      var i = n.next(),
                        o = r.next(),
                        a = i.compareTo(o);
                      if (0 !== a) return a;
                    }
                    return n.hasNext() ? 1 : r.hasNext() ? -1 : 0;
                  },
                },
                {
                  key: 'hashCode',
                  value: function () {
                    return this.getEnvelopeInternal().hashCode();
                  },
                },
                {
                  key: 'isEquivalentClass',
                  value: function (t) {
                    return this.getClass() === t.getClass();
                  },
                },
                {
                  key: 'isGeometryCollectionOrDerived',
                  value: function () {
                    return (
                      this.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION ||
                      this.getTypeCode() === e.TYPECODE_MULTIPOINT ||
                      this.getTypeCode() === e.TYPECODE_MULTILINESTRING ||
                      this.getTypeCode() === e.TYPECODE_MULTIPOLYGON
                    );
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [w, E, k];
                  },
                },
                {
                  key: 'getClass',
                  value: function () {
                    return e;
                  },
                },
              ],
              [
                {
                  key: 'hasNonEmptyElements',
                  value: function (t) {
                    for (var e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0;
                    return !1;
                  },
                },
                {
                  key: 'hasNullElements',
                  value: function (t) {
                    for (var e = 0; e < t.length; e++) if (null === t[e]) return !0;
                    return !1;
                  },
                },
              ],
            ),
            e
          );
        })();
      (X.constructor_ = function (t) {
        t && ((this._envelope = null), (this._userData = null), (this._factory = t), (this._SRID = t.getSRID()));
      }),
        (X.TYPECODE_POINT = 0),
        (X.TYPECODE_MULTIPOINT = 1),
        (X.TYPECODE_LINESTRING = 2),
        (X.TYPECODE_LINEARRING = 3),
        (X.TYPECODE_MULTILINESTRING = 4),
        (X.TYPECODE_POLYGON = 5),
        (X.TYPECODE_MULTIPOLYGON = 6),
        (X.TYPECODE_GEOMETRYCOLLECTION = 7),
        (X.TYPENAME_POINT = 'Point'),
        (X.TYPENAME_MULTIPOINT = 'MultiPoint'),
        (X.TYPENAME_LINESTRING = 'LineString'),
        (X.TYPENAME_LINEARRING = 'LinearRing'),
        (X.TYPENAME_MULTILINESTRING = 'MultiLineString'),
        (X.TYPENAME_POLYGON = 'Polygon'),
        (X.TYPENAME_MULTIPOLYGON = 'MultiPolygon'),
        (X.TYPENAME_GEOMETRYCOLLECTION = 'GeometryCollection'),
        (X.geometryChangedFilter = {
          get interfaces_() {
            return [x];
          },
          filter: function (t) {
            t.geometryChangedAction();
          },
        });
      var W = (function () {
        function e() {
          t(this, e);
        }
        return (
          r(e, null, [
            {
              key: 'toLocationSymbol',
              value: function (t) {
                switch (t) {
                  case e.EXTERIOR:
                    return 'e';
                  case e.BOUNDARY:
                    return 'b';
                  case e.INTERIOR:
                    return 'i';
                  case e.NONE:
                    return '-';
                }
                throw new b('Unknown location value: ' + t);
              },
            },
          ]),
          e
        );
      })();
      (W.INTERIOR = 0), (W.BOUNDARY = 1), (W.EXTERIOR = 2), (W.NONE = -1);
      var H = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'add', value: function () {} },
              { key: 'addAll', value: function () {} },
              { key: 'isEmpty', value: function () {} },
              { key: 'iterator', value: function () {} },
              { key: 'size', value: function () {} },
              { key: 'toArray', value: function () {} },
              { key: 'remove', value: function () {} },
            ]),
            e
          );
        })(),
        Z = (function (e) {
          i(r, e);
          var n = f(r);
          function r(e) {
            var i;
            return t(this, r), ((i = n.call(this, e)).name = Object.keys({ NoSuchElementException: r })[0]), i;
          }
          return r;
        })(_),
        J = (function (e) {
          i(r, e);
          var n = f(r);
          function r(e) {
            var i;
            return t(this, r), ((i = n.call(this, e)).name = Object.keys({ UnsupportedOperationException: r })[0]), i;
          }
          return r;
        })(_),
        $ = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            return t(this, o), n.apply(this, arguments);
          }
          return r(o, [{ key: 'contains', value: function () {} }]), o;
        })(H),
        Q = (function (e, n) {
          i(a, e);
          var o = f(a);
          function a(e) {
            var n;
            return t(this, a), ((n = o.call(this)).map = new Map()), e instanceof H && n.addAll(e), n;
          }
          return (
            r(a, [
              {
                key: 'contains',
                value: function (t) {
                  var e = t.hashCode ? t.hashCode() : t;
                  return !!this.map.has(e);
                },
              },
              {
                key: 'add',
                value: function (t) {
                  var e = t.hashCode ? t.hashCode() : t;
                  return !this.map.has(e) && !!this.map.set(e, t);
                },
              },
              {
                key: 'addAll',
                value: function (t) {
                  var e,
                    n = d(t);
                  try {
                    for (n.s(); !(e = n.n()).done; ) {
                      var r = e.value;
                      this.add(r);
                    }
                  } catch (t) {
                    n.e(t);
                  } finally {
                    n.f();
                  }
                  return !0;
                },
              },
              {
                key: 'remove',
                value: function () {
                  throw new J();
                },
              },
              {
                key: 'size',
                value: function () {
                  return this.map.size;
                },
              },
              {
                key: 'isEmpty',
                value: function () {
                  return 0 === this.map.size;
                },
              },
              {
                key: 'toArray',
                value: function () {
                  return Array.from(this.map.values());
                },
              },
              {
                key: 'iterator',
                value: function () {
                  return new K(this.map);
                },
              },
              {
                key: n,
                value: function () {
                  return this.map;
                },
              },
            ]),
            a
          );
        })($, Symbol.iterator),
        K = (function () {
          function e(n) {
            t(this, e), (this.iterator = n.values());
            var r = this.iterator.next(),
              i = r.done,
              o = r.value;
            (this.done = i), (this.value = o);
          }
          return (
            r(e, [
              {
                key: 'next',
                value: function () {
                  if (this.done) throw new Z();
                  var t = this.value,
                    e = this.iterator.next(),
                    n = e.done,
                    r = e.value;
                  return (this.done = n), (this.value = r), t;
                },
              },
              {
                key: 'hasNext',
                value: function () {
                  return !this.done;
                },
              },
              {
                key: 'remove',
                value: function () {
                  throw new J();
                },
              },
            ]),
            e
          );
        })(),
        tt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'opposite',
                value: function (t) {
                  return t === e.LEFT ? e.RIGHT : t === e.RIGHT ? e.LEFT : t;
                },
              },
            ]),
            e
          );
        })();
      (tt.ON = 0), (tt.LEFT = 1), (tt.RIGHT = 2);
      var et = (function (e) {
          i(r, e);
          var n = f(r);
          function r(e) {
            var i;
            return t(this, r), ((i = n.call(this, e)).name = Object.keys({ EmptyStackException: r })[0]), i;
          }
          return r;
        })(_),
        nt = (function (e) {
          i(r, e);
          var n = f(r);
          function r(e) {
            var i;
            return t(this, r), ((i = n.call(this, e)).name = Object.keys({ IndexOutOfBoundsException: r })[0]), i;
          }
          return r;
        })(_),
        rt = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            return t(this, o), n.apply(this, arguments);
          }
          return (
            r(o, [
              { key: 'get', value: function () {} },
              { key: 'set', value: function () {} },
              { key: 'isEmpty', value: function () {} },
            ]),
            o
          );
        })(H),
        it = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), ((e = n.call(this)).array = []), e;
          }
          return (
            r(o, [
              {
                key: 'add',
                value: function (t) {
                  return this.array.push(t), !0;
                },
              },
              {
                key: 'get',
                value: function (t) {
                  if (t < 0 || t >= this.size()) throw new nt();
                  return this.array[t];
                },
              },
              {
                key: 'push',
                value: function (t) {
                  return this.array.push(t), t;
                },
              },
              {
                key: 'pop',
                value: function () {
                  if (0 === this.array.length) throw new et();
                  return this.array.pop();
                },
              },
              {
                key: 'peek',
                value: function () {
                  if (0 === this.array.length) throw new et();
                  return this.array[this.array.length - 1];
                },
              },
              {
                key: 'empty',
                value: function () {
                  return 0 === this.array.length;
                },
              },
              {
                key: 'isEmpty',
                value: function () {
                  return this.empty();
                },
              },
              {
                key: 'search',
                value: function (t) {
                  return this.array.indexOf(t);
                },
              },
              {
                key: 'size',
                value: function () {
                  return this.array.length;
                },
              },
              {
                key: 'toArray',
                value: function () {
                  return this.array.slice();
                },
              },
            ]),
            o
          );
        })(rt);
      function ot(t, e) {
        return t.interfaces_ && t.interfaces_.indexOf(e) > -1;
      }
      var at = (function () {
          function e(n) {
            t(this, e), (this.str = n);
          }
          return (
            r(e, [
              {
                key: 'append',
                value: function (t) {
                  this.str += t;
                },
              },
              {
                key: 'setCharAt',
                value: function (t, e) {
                  this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
                },
              },
              {
                key: 'toString',
                value: function () {
                  return this.str;
                },
              },
            ]),
            e
          );
        })(),
        st = (function () {
          function e(n) {
            t(this, e), (this.value = n);
          }
          return (
            r(
              e,
              [
                {
                  key: 'intValue',
                  value: function () {
                    return this.value;
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    return this.value < t ? -1 : this.value > t ? 1 : 0;
                  },
                },
              ],
              [
                {
                  key: 'compare',
                  value: function (t, e) {
                    return t < e ? -1 : t > e ? 1 : 0;
                  },
                },
                {
                  key: 'isNan',
                  value: function (t) {
                    return Number.isNaN(t);
                  },
                },
                {
                  key: 'valueOf',
                  value: function (t) {
                    return new e(t);
                  },
                },
              ],
            ),
            e
          );
        })(),
        ut = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'isWhitespace',
                value: function (t) {
                  return (t <= 32 && t >= 0) || 127 === t;
                },
              },
              {
                key: 'toUpperCase',
                value: function (t) {
                  return t.toUpperCase();
                },
              },
            ]),
            e
          );
        })(),
        lt = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'le',
                  value: function (t) {
                    return this._hi < t._hi || (this._hi === t._hi && this._lo <= t._lo);
                  },
                },
                {
                  key: 'extractSignificantDigits',
                  value: function (t, n) {
                    var r = this.abs(),
                      i = e.magnitude(r._hi),
                      o = e.TEN.pow(i);
                    (r = r.divide(o)).gt(e.TEN)
                      ? ((r = r.divide(e.TEN)), (i += 1))
                      : r.lt(e.ONE) && ((r = r.multiply(e.TEN)), (i -= 1));
                    for (var a = i + 1, s = new at(), u = e.MAX_PRINT_DIGITS - 1, l = 0; l <= u; l++) {
                      t && l === a && s.append('.');
                      var c = Math.trunc(r._hi);
                      if (c < 0) break;
                      var h = !1,
                        f = 0;
                      c > 9 ? ((h = !0), (f = '9')) : (f = '0' + c),
                        s.append(f),
                        (r = r.subtract(e.valueOf(c)).multiply(e.TEN)),
                        h && r.selfAdd(e.TEN);
                      var p = !0,
                        g = e.magnitude(r._hi);
                      if ((g < 0 && Math.abs(g) >= u - l && (p = !1), !p)) break;
                    }
                    return (n[0] = i), s.toString();
                  },
                },
                {
                  key: 'sqr',
                  value: function () {
                    return this.multiply(this);
                  },
                },
                {
                  key: 'doubleValue',
                  value: function () {
                    return this._hi + this._lo;
                  },
                },
                {
                  key: 'subtract',
                  value: function () {
                    if (arguments[0] instanceof e) {
                      var t = arguments[0];
                      return this.add(t.negate());
                    }
                    if ('number' == typeof arguments[0]) {
                      var n = arguments[0];
                      return this.add(-n);
                    }
                  },
                },
                {
                  key: 'equals',
                  value: function () {
                    if (1 === arguments.length && arguments[0] instanceof e) {
                      var t = arguments[0];
                      return this._hi === t._hi && this._lo === t._lo;
                    }
                  },
                },
                {
                  key: 'isZero',
                  value: function () {
                    return 0 === this._hi && 0 === this._lo;
                  },
                },
                {
                  key: 'selfSubtract',
                  value: function () {
                    if (arguments[0] instanceof e) {
                      var t = arguments[0];
                      return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo);
                    }
                    if ('number' == typeof arguments[0]) {
                      var n = arguments[0];
                      return this.isNaN() ? this : this.selfAdd(-n, 0);
                    }
                  },
                },
                {
                  key: 'getSpecialNumberString',
                  value: function () {
                    return this.isZero() ? '0.0' : this.isNaN() ? 'NaN ' : null;
                  },
                },
                {
                  key: 'min',
                  value: function (t) {
                    return this.le(t) ? this : t;
                  },
                },
                {
                  key: 'selfDivide',
                  value: function () {
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof e) {
                        var t = arguments[0];
                        return this.selfDivide(t._hi, t._lo);
                      }
                      if ('number' == typeof arguments[0]) {
                        var n = arguments[0];
                        return this.selfDivide(n, 0);
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1],
                        o = null,
                        a = null,
                        s = null,
                        u = null,
                        l = null,
                        c = null,
                        h = null,
                        f = null;
                      return (
                        (l = this._hi / r),
                        (f =
                          (o = (c = e.SPLIT * l) - (o = c - l)) * (s = (f = e.SPLIT * r) - (s = f - r)) -
                          (h = l * r) +
                          o * (u = r - s) +
                          (a = l - o) * s +
                          a * u),
                        (f = l + (c = (this._hi - h - f + this._lo - l * i) / r)),
                        (this._hi = f),
                        (this._lo = l - f + c),
                        this
                      );
                    }
                  },
                },
                {
                  key: 'dump',
                  value: function () {
                    return 'DD<' + this._hi + ', ' + this._lo + '>';
                  },
                },
                {
                  key: 'divide',
                  value: function () {
                    if (arguments[0] instanceof e) {
                      var t = arguments[0],
                        n = null,
                        r = null,
                        i = null,
                        o = null,
                        a = null,
                        s = null,
                        u = null,
                        l = null;
                      return (
                        (r = (a = this._hi / t._hi) - (n = (s = e.SPLIT * a) - (n = s - a))),
                        (l =
                          n * (i = (l = e.SPLIT * t._hi) - (i = l - t._hi)) -
                          (u = a * t._hi) +
                          n * (o = t._hi - i) +
                          r * i +
                          r * o),
                        new e((l = a + (s = (this._hi - u - l + this._lo - a * t._lo) / t._hi)), a - l + s)
                      );
                    }
                    if ('number' == typeof arguments[0]) {
                      var c = arguments[0];
                      return A.isNaN(c) ? e.createNaN() : e.copy(this).selfDivide(c, 0);
                    }
                  },
                },
                {
                  key: 'ge',
                  value: function (t) {
                    return this._hi > t._hi || (this._hi === t._hi && this._lo >= t._lo);
                  },
                },
                {
                  key: 'pow',
                  value: function (t) {
                    if (0 === t) return e.valueOf(1);
                    var n = new e(this),
                      r = e.valueOf(1),
                      i = Math.abs(t);
                    if (i > 1) for (; i > 0; ) i % 2 == 1 && r.selfMultiply(n), (i /= 2) > 0 && (n = n.sqr());
                    else r = n;
                    return t < 0 ? r.reciprocal() : r;
                  },
                },
                {
                  key: 'ceil',
                  value: function () {
                    if (this.isNaN()) return e.NaN;
                    var t = Math.ceil(this._hi),
                      n = 0;
                    return t === this._hi && (n = Math.ceil(this._lo)), new e(t, n);
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    return this._hi < e._hi
                      ? -1
                      : this._hi > e._hi
                      ? 1
                      : this._lo < e._lo
                      ? -1
                      : this._lo > e._lo
                      ? 1
                      : 0;
                  },
                },
                {
                  key: 'rint',
                  value: function () {
                    return this.isNaN() ? this : this.add(0.5).floor();
                  },
                },
                {
                  key: 'setValue',
                  value: function () {
                    if (arguments[0] instanceof e) {
                      var t = arguments[0];
                      return this.init(t), this;
                    }
                    if ('number' == typeof arguments[0]) {
                      var n = arguments[0];
                      return this.init(n), this;
                    }
                  },
                },
                {
                  key: 'max',
                  value: function (t) {
                    return this.ge(t) ? this : t;
                  },
                },
                {
                  key: 'sqrt',
                  value: function () {
                    if (this.isZero()) return e.valueOf(0);
                    if (this.isNegative()) return e.NaN;
                    var t = 1 / Math.sqrt(this._hi),
                      n = this._hi * t,
                      r = e.valueOf(n),
                      i = this.subtract(r.sqr())._hi * (0.5 * t);
                    return r.add(i);
                  },
                },
                {
                  key: 'selfAdd',
                  value: function () {
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof e) {
                        var t = arguments[0];
                        return this.selfAdd(t._hi, t._lo);
                      }
                      if ('number' == typeof arguments[0]) {
                        var n = arguments[0],
                          r = null,
                          i = null,
                          o = null,
                          a = null,
                          s = null,
                          u = null;
                        return (
                          (a = (o = this._hi + n) - (s = o - this._hi)),
                          (i = (u = (a = n - s + (this._hi - a)) + this._lo) + (o - (r = o + u))),
                          (this._hi = r + i),
                          (this._lo = i + (r - this._hi)),
                          this
                        );
                      }
                    } else if (2 === arguments.length) {
                      var l = arguments[0],
                        c = arguments[1],
                        h = null,
                        f = null,
                        p = null,
                        g = null,
                        y = null,
                        v = null,
                        d = null;
                      (g = this._hi + l),
                        (f = this._lo + c),
                        (y = g - (v = g - this._hi)),
                        (p = f - (d = f - this._lo));
                      var m =
                          (h = g + (v = (y = l - v + (this._hi - y)) + f)) +
                          (v = (p = c - d + (this._lo - p)) + (v + (g - h))),
                        _ = v + (h - m);
                      return (this._hi = m), (this._lo = _), this;
                    }
                  },
                },
                {
                  key: 'selfMultiply',
                  value: function () {
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof e) {
                        var t = arguments[0];
                        return this.selfMultiply(t._hi, t._lo);
                      }
                      if ('number' == typeof arguments[0]) {
                        var n = arguments[0];
                        return this.selfMultiply(n, 0);
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1],
                        o = null,
                        a = null,
                        s = null,
                        u = null,
                        l = null,
                        c = null;
                      (o = (l = e.SPLIT * this._hi) - this._hi),
                        (c = e.SPLIT * r),
                        (o = l - o),
                        (a = this._hi - o),
                        (s = c - r);
                      var h =
                          (l = this._hi * r) +
                          (c = o * (s = c - s) - l + o * (u = r - s) + a * s + a * u + (this._hi * i + this._lo * r)),
                        f = c + (o = l - h);
                      return (this._hi = h), (this._lo = f), this;
                    }
                  },
                },
                {
                  key: 'selfSqr',
                  value: function () {
                    return this.selfMultiply(this);
                  },
                },
                {
                  key: 'floor',
                  value: function () {
                    if (this.isNaN()) return e.NaN;
                    var t = Math.floor(this._hi),
                      n = 0;
                    return t === this._hi && (n = Math.floor(this._lo)), new e(t, n);
                  },
                },
                {
                  key: 'negate',
                  value: function () {
                    return this.isNaN() ? this : new e(-this._hi, -this._lo);
                  },
                },
                {
                  key: 'clone',
                  value: function () {
                    try {
                      return null;
                    } catch (t) {
                      if (t instanceof CloneNotSupportedException) return null;
                      throw t;
                    }
                  },
                },
                {
                  key: 'multiply',
                  value: function () {
                    if (arguments[0] instanceof e) {
                      var t = arguments[0];
                      return t.isNaN() ? e.createNaN() : e.copy(this).selfMultiply(t);
                    }
                    if ('number' == typeof arguments[0]) {
                      var n = arguments[0];
                      return A.isNaN(n) ? e.createNaN() : e.copy(this).selfMultiply(n, 0);
                    }
                  },
                },
                {
                  key: 'isNaN',
                  value: function () {
                    return A.isNaN(this._hi);
                  },
                },
                {
                  key: 'intValue',
                  value: function () {
                    return Math.trunc(this._hi);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    var t = e.magnitude(this._hi);
                    return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation();
                  },
                },
                {
                  key: 'toStandardNotation',
                  value: function () {
                    var t = this.getSpecialNumberString();
                    if (null !== t) return t;
                    var n = new Array(1).fill(null),
                      r = this.extractSignificantDigits(!0, n),
                      i = n[0] + 1,
                      o = r;
                    if ('.' === r.charAt(0)) o = '0' + r;
                    else if (i < 0) o = '0.' + e.stringOfChar('0', -i) + r;
                    else if (-1 === r.indexOf('.')) {
                      var a = i - r.length;
                      o = r + e.stringOfChar('0', a) + '.0';
                    }
                    return this.isNegative() ? '-' + o : o;
                  },
                },
                {
                  key: 'reciprocal',
                  value: function () {
                    var t,
                      n,
                      r,
                      i,
                      o = null,
                      a = null,
                      s = null,
                      u = null;
                    (t = (r = 1 / this._hi) - (o = (s = e.SPLIT * r) - (o = s - r))),
                      (a = (u = e.SPLIT * this._hi) - this._hi);
                    var l =
                      r +
                      (s =
                        (1 -
                          (i = r * this._hi) -
                          (u = o * (a = u - a) - i + o * (n = this._hi - a) + t * a + t * n) -
                          r * this._lo) /
                        this._hi);
                    return new e(l, r - l + s);
                  },
                },
                {
                  key: 'toSciNotation',
                  value: function () {
                    if (this.isZero()) return e.SCI_NOT_ZERO;
                    var t = this.getSpecialNumberString();
                    if (null !== t) return t;
                    var n = new Array(1).fill(null),
                      r = this.extractSignificantDigits(!1, n),
                      i = e.SCI_NOT_EXPONENT_CHAR + n[0];
                    if ('0' === r.charAt(0)) throw new IllegalStateException('Found leading zero: ' + r);
                    var o = '';
                    r.length > 1 && (o = r.substring(1));
                    var a = r.charAt(0) + '.' + o;
                    return this.isNegative() ? '-' + a + i : a + i;
                  },
                },
                {
                  key: 'abs',
                  value: function () {
                    return this.isNaN() ? e.NaN : this.isNegative() ? this.negate() : new e(this);
                  },
                },
                {
                  key: 'isPositive',
                  value: function () {
                    return this._hi > 0 || (0 === this._hi && this._lo > 0);
                  },
                },
                {
                  key: 'lt',
                  value: function (t) {
                    return this._hi < t._hi || (this._hi === t._hi && this._lo < t._lo);
                  },
                },
                {
                  key: 'add',
                  value: function () {
                    if (arguments[0] instanceof e) {
                      var t = arguments[0];
                      return e.copy(this).selfAdd(t);
                    }
                    if ('number' == typeof arguments[0]) {
                      var n = arguments[0];
                      return e.copy(this).selfAdd(n);
                    }
                  },
                },
                {
                  key: 'init',
                  value: function () {
                    if (1 === arguments.length) {
                      if ('number' == typeof arguments[0]) {
                        var t = arguments[0];
                        (this._hi = t), (this._lo = 0);
                      } else if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        (this._hi = n._hi), (this._lo = n._lo);
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      (this._hi = r), (this._lo = i);
                    }
                  },
                },
                {
                  key: 'gt',
                  value: function (t) {
                    return this._hi > t._hi || (this._hi === t._hi && this._lo > t._lo);
                  },
                },
                {
                  key: 'isNegative',
                  value: function () {
                    return this._hi < 0 || (0 === this._hi && this._lo < 0);
                  },
                },
                {
                  key: 'trunc',
                  value: function () {
                    return this.isNaN() ? e.NaN : this.isPositive() ? this.floor() : this.ceil();
                  },
                },
                {
                  key: 'signum',
                  value: function () {
                    return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [k, E, w];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._hi = 0), (this._lo = 0), 0 === arguments.length)) this.init(0);
                    else if (1 === arguments.length) {
                      if ('number' == typeof arguments[0]) {
                        var t = arguments[0];
                        this.init(t);
                      } else if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        this.init(n);
                      } else if ('string' == typeof arguments[0]) {
                        var r = arguments[0];
                        e.constructor_.call(this, e.parse(r));
                      }
                    } else if (2 === arguments.length) {
                      var i = arguments[0],
                        o = arguments[1];
                      this.init(i, o);
                    }
                  },
                },
                {
                  key: 'determinant',
                  value: function () {
                    if (
                      'number' == typeof arguments[3] &&
                      'number' == typeof arguments[2] &&
                      'number' == typeof arguments[0] &&
                      'number' == typeof arguments[1]
                    ) {
                      var t = arguments[0],
                        n = arguments[1],
                        r = arguments[2],
                        i = arguments[3];
                      return e.determinant(e.valueOf(t), e.valueOf(n), e.valueOf(r), e.valueOf(i));
                    }
                    if (
                      arguments[3] instanceof e &&
                      arguments[2] instanceof e &&
                      arguments[0] instanceof e &&
                      arguments[1] instanceof e
                    ) {
                      var o = arguments[1],
                        a = arguments[2],
                        s = arguments[3];
                      return arguments[0].multiply(s).selfSubtract(o.multiply(a));
                    }
                  },
                },
                {
                  key: 'sqr',
                  value: function (t) {
                    return e.valueOf(t).selfMultiply(t);
                  },
                },
                {
                  key: 'valueOf',
                  value: function () {
                    if ('string' == typeof arguments[0]) {
                      var t = arguments[0];
                      return e.parse(t);
                    }
                    if ('number' == typeof arguments[0]) return new e(arguments[0]);
                  },
                },
                {
                  key: 'sqrt',
                  value: function (t) {
                    return e.valueOf(t).sqrt();
                  },
                },
                {
                  key: 'parse',
                  value: function (t) {
                    for (var n = 0, r = t.length; ut.isWhitespace(t.charAt(n)); ) n++;
                    var i = !1;
                    if (n < r) {
                      var o = t.charAt(n);
                      ('-' !== o && '+' !== o) || (n++, '-' === o && (i = !0));
                    }
                    for (var a = new e(), s = 0, u = 0, l = 0, c = !1; !(n >= r); ) {
                      var h = t.charAt(n);
                      if ((n++, ut.isDigit(h))) {
                        var f = h - '0';
                        a.selfMultiply(e.TEN), a.selfAdd(f), s++;
                      } else {
                        if ('.' !== h) {
                          if ('e' === h || 'E' === h) {
                            var p = t.substring(n);
                            try {
                              l = st.parseInt(p);
                            } catch (e) {
                              throw e instanceof NumberFormatException
                                ? new NumberFormatException('Invalid exponent ' + p + ' in string ' + t)
                                : e;
                            }
                            break;
                          }
                          throw new NumberFormatException(
                            "Unexpected character '" + h + "' at position " + n + ' in string ' + t,
                          );
                        }
                        (u = s), (c = !0);
                      }
                    }
                    var g = a;
                    c || (u = s);
                    var y = s - u - l;
                    if (0 === y) g = a;
                    else if (y > 0) {
                      var v = e.TEN.pow(y);
                      g = a.divide(v);
                    } else if (y < 0) {
                      var d = e.TEN.pow(-y);
                      g = a.multiply(d);
                    }
                    return i ? g.negate() : g;
                  },
                },
                {
                  key: 'createNaN',
                  value: function () {
                    return new e(A.NaN, A.NaN);
                  },
                },
                {
                  key: 'copy',
                  value: function (t) {
                    return new e(t);
                  },
                },
                {
                  key: 'magnitude',
                  value: function (t) {
                    var e = Math.abs(t),
                      n = Math.log(e) / Math.log(10),
                      r = Math.trunc(Math.floor(n));
                    return 10 * Math.pow(10, r) <= e && (r += 1), r;
                  },
                },
                {
                  key: 'stringOfChar',
                  value: function (t, e) {
                    for (var n = new at(), r = 0; r < e; r++) n.append(t);
                    return n.toString();
                  },
                },
              ],
            ),
            e
          );
        })();
      (lt.PI = new lt(3.141592653589793, 12246467991473532e-32)),
        (lt.TWO_PI = new lt(6.283185307179586, 24492935982947064e-32)),
        (lt.PI_2 = new lt(1.5707963267948966, 6123233995736766e-32)),
        (lt.E = new lt(2.718281828459045, 14456468917292502e-32)),
        (lt.NaN = new lt(A.NaN, A.NaN)),
        (lt.EPS = 123259516440783e-46),
        (lt.SPLIT = 134217729),
        (lt.MAX_PRINT_DIGITS = 32),
        (lt.TEN = lt.valueOf(10)),
        (lt.ONE = lt.valueOf(1)),
        (lt.SCI_NOT_EXPONENT_CHAR = 'E'),
        (lt.SCI_NOT_ZERO = '0.0E0');
      var ct = (function () {
        function e() {
          t(this, e);
        }
        return (
          r(e, null, [
            {
              key: 'orientationIndex',
              value: function (t, n, r) {
                var i = e.orientationIndexFilter(t, n, r);
                if (i <= 1) return i;
                var o = lt.valueOf(n.x).selfAdd(-t.x),
                  a = lt.valueOf(n.y).selfAdd(-t.y),
                  s = lt.valueOf(r.x).selfAdd(-n.x),
                  u = lt.valueOf(r.y).selfAdd(-n.y);
                return o.selfMultiply(u).selfSubtract(a.selfMultiply(s)).signum();
              },
            },
            {
              key: 'signOfDet2x2',
              value: function () {
                if (
                  arguments[3] instanceof lt &&
                  arguments[2] instanceof lt &&
                  arguments[0] instanceof lt &&
                  arguments[1] instanceof lt
                ) {
                  var t = arguments[1],
                    e = arguments[2],
                    n = arguments[3];
                  return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum();
                }
                if (
                  'number' == typeof arguments[3] &&
                  'number' == typeof arguments[2] &&
                  'number' == typeof arguments[0] &&
                  'number' == typeof arguments[1]
                ) {
                  var r = arguments[0],
                    i = arguments[1],
                    o = arguments[2],
                    a = arguments[3],
                    s = lt.valueOf(r),
                    u = lt.valueOf(i),
                    l = lt.valueOf(o),
                    c = lt.valueOf(a);
                  return s.multiply(c).selfSubtract(u.multiply(l)).signum();
                }
              },
            },
            {
              key: 'intersection',
              value: function (t, e, n, r) {
                var i = new lt(t.y).selfSubtract(e.y),
                  o = new lt(e.x).selfSubtract(t.x),
                  a = new lt(t.x).selfMultiply(e.y).selfSubtract(new lt(e.x).selfMultiply(t.y)),
                  s = new lt(n.y).selfSubtract(r.y),
                  u = new lt(r.x).selfSubtract(n.x),
                  l = new lt(n.x).selfMultiply(r.y).selfSubtract(new lt(r.x).selfMultiply(n.y)),
                  c = o.multiply(l).selfSubtract(u.multiply(a)),
                  h = s.multiply(a).selfSubtract(i.multiply(l)),
                  f = i.multiply(u).selfSubtract(s.multiply(o)),
                  p = c.selfDivide(f).doubleValue(),
                  g = h.selfDivide(f).doubleValue();
                return A.isNaN(p) || A.isInfinite(p) || A.isNaN(g) || A.isInfinite(g) ? null : new Y(p, g);
              },
            },
            {
              key: 'orientationIndexFilter',
              value: function (t, n, r) {
                var i = null,
                  o = (t.x - r.x) * (n.y - r.y),
                  a = (t.y - r.y) * (n.x - r.x),
                  s = o - a;
                if (o > 0) {
                  if (a <= 0) return e.signum(s);
                  i = o + a;
                } else {
                  if (!(o < 0)) return e.signum(s);
                  if (a >= 0) return e.signum(s);
                  i = -o - a;
                }
                var u = e.DP_SAFE_EPSILON * i;
                return s >= u || -s >= u ? e.signum(s) : 2;
              },
            },
            {
              key: 'signum',
              value: function (t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0;
              },
            },
          ]),
          e
        );
      })();
      ct.DP_SAFE_EPSILON = 1e-15;
      var ht = (function () {
        function e() {
          t(this, e);
        }
        return (
          r(e, [
            {
              key: 'getM',
              value: function (t) {
                if (this.hasM()) {
                  var e = this.getDimension() - this.getMeasures();
                  return this.getOrdinate(t, e);
                }
                return A.NaN;
              },
            },
            { key: 'setOrdinate', value: function (t, e, n) {} },
            {
              key: 'getZ',
              value: function (t) {
                return this.hasZ() ? this.getOrdinate(t, 2) : A.NaN;
              },
            },
            { key: 'size', value: function () {} },
            { key: 'getOrdinate', value: function (t, e) {} },
            { key: 'getCoordinate', value: function () {} },
            { key: 'getCoordinateCopy', value: function (t) {} },
            { key: 'createCoordinate', value: function () {} },
            { key: 'getDimension', value: function () {} },
            {
              key: 'hasM',
              value: function () {
                return this.getMeasures() > 0;
              },
            },
            { key: 'getX', value: function (t) {} },
            {
              key: 'hasZ',
              value: function () {
                return this.getDimension() - this.getMeasures() > 2;
              },
            },
            {
              key: 'getMeasures',
              value: function () {
                return 0;
              },
            },
            { key: 'expandEnvelope', value: function (t) {} },
            { key: 'copy', value: function () {} },
            { key: 'getY', value: function (t) {} },
            { key: 'toCoordinateArray', value: function () {} },
            {
              key: 'interfaces_',
              get: function () {
                return [w];
              },
            },
          ]),
          e
        );
      })();
      (ht.X = 0), (ht.Y = 1), (ht.Z = 2), (ht.M = 3);
      var ft = (function () {
        function e() {
          t(this, e);
        }
        return (
          r(e, null, [
            {
              key: 'index',
              value: function (t, e, n) {
                return ct.orientationIndex(t, e, n);
              },
            },
            {
              key: 'isCCW',
              value: function () {
                if (arguments[0] instanceof Array) {
                  var t = arguments[0],
                    n = t.length - 1;
                  if (n < 3) throw new b('Ring has fewer than 4 points, so orientation cannot be determined');
                  for (var r = t[0], i = 0, o = 1; o <= n; o++) {
                    var a = t[o];
                    a.y > r.y && ((r = a), (i = o));
                  }
                  var s = i;
                  do {
                    (s -= 1) < 0 && (s = n);
                  } while (t[s].equals2D(r) && s !== i);
                  var u = i;
                  do {
                    u = (u + 1) % n;
                  } while (t[u].equals2D(r) && u !== i);
                  var l = t[s],
                    c = t[u];
                  if (l.equals2D(r) || c.equals2D(r) || l.equals2D(c)) return !1;
                  var h = e.index(l, r, c);
                  return 0 === h ? l.x > c.x : h > 0;
                }
                if (ot(arguments[0], ht)) {
                  var f = arguments[0],
                    p = f.size() - 1;
                  if (p < 3) throw new b('Ring has fewer than 4 points, so orientation cannot be determined');
                  for (var g = f.getCoordinate(0), y = 0, v = 1; v <= p; v++) {
                    var d = f.getCoordinate(v);
                    d.y > g.y && ((g = d), (y = v));
                  }
                  var m = null,
                    _ = y;
                  do {
                    (_ -= 1) < 0 && (_ = p), (m = f.getCoordinate(_));
                  } while (m.equals2D(g) && _ !== y);
                  var x = null,
                    E = y;
                  do {
                    (E = (E + 1) % p), (x = f.getCoordinate(E));
                  } while (x.equals2D(g) && E !== y);
                  if (m.equals2D(g) || x.equals2D(g) || m.equals2D(x)) return !1;
                  var w = e.index(m, g, x);
                  return 0 === w ? m.x > x.x : w > 0;
                }
              },
            },
          ]),
          e
        );
      })();
      (ft.CLOCKWISE = -1),
        (ft.RIGHT = ft.CLOCKWISE),
        (ft.COUNTERCLOCKWISE = 1),
        (ft.LEFT = ft.COUNTERCLOCKWISE),
        (ft.COLLINEAR = 0),
        (ft.STRAIGHT = ft.COLLINEAR);
      var pt = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getCoordinate',
                  value: function () {
                    return this._minCoord;
                  },
                },
                {
                  key: 'getRightmostSide',
                  value: function (t, e) {
                    var n = this.getRightmostSideOfSegment(t, e);
                    return (
                      n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)),
                      n < 0 && ((this._minCoord = null), this.checkForRightmostCoordinate(t)),
                      n
                    );
                  },
                },
                {
                  key: 'findRightmostEdgeAtVertex',
                  value: function () {
                    var t = this._minDe.getEdge().getCoordinates();
                    B.isTrue(
                      this._minIndex > 0 && this._minIndex < t.length,
                      'rightmost point expected to be interior vertex of edge',
                    );
                    var e = t[this._minIndex - 1],
                      n = t[this._minIndex + 1],
                      r = ft.index(this._minCoord, n, e),
                      i = !1;
                    ((e.y < this._minCoord.y && n.y < this._minCoord.y && r === ft.COUNTERCLOCKWISE) ||
                      (e.y > this._minCoord.y && n.y > this._minCoord.y && r === ft.CLOCKWISE)) &&
                      (i = !0),
                      i && (this._minIndex = this._minIndex - 1);
                  },
                },
                {
                  key: 'getRightmostSideOfSegment',
                  value: function (t, e) {
                    var n = t.getEdge().getCoordinates();
                    if (e < 0 || e + 1 >= n.length) return -1;
                    if (n[e].y === n[e + 1].y) return -1;
                    var r = tt.LEFT;
                    return n[e].y < n[e + 1].y && (r = tt.RIGHT), r;
                  },
                },
                {
                  key: 'getEdge',
                  value: function () {
                    return this._orientedDe;
                  },
                },
                {
                  key: 'checkForRightmostCoordinate',
                  value: function (t) {
                    for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++)
                      (null === this._minCoord || e[n].x > this._minCoord.x) &&
                        ((this._minDe = t), (this._minIndex = n), (this._minCoord = e[n]));
                  },
                },
                {
                  key: 'findRightmostEdgeAtNode',
                  value: function () {
                    var t = this._minDe.getNode().getEdges();
                    (this._minDe = t.getRightmostEdge()),
                      this._minDe.isForward() ||
                        ((this._minDe = this._minDe.getSym()),
                        (this._minIndex = this._minDe.getEdge().getCoordinates().length - 1));
                  },
                },
                {
                  key: 'findEdge',
                  value: function (t) {
                    for (var e = t.iterator(); e.hasNext(); ) {
                      var n = e.next();
                      n.isForward() && this.checkForRightmostCoordinate(n);
                    }
                    B.isTrue(
                      0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()),
                      'inconsistency in rightmost processing',
                    ),
                      0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(),
                      (this._orientedDe = this._minDe),
                      this.getRightmostSide(this._minDe, this._minIndex) === tt.LEFT &&
                        (this._orientedDe = this._minDe.getSym());
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._minIndex = -1), (this._minCoord = null), (this._minDe = null), (this._orientedDe = null);
                  },
                },
              ],
            ),
            e
          );
        })(),
        gt = (function (e) {
          i(o, e);
          var n = f(o);
          function o(e, r) {
            var i;
            return (
              t(this, o),
              ((i = n.call(this, r ? e + ' [ ' + r + ' ]' : e)).pt = r ? new Y(r) : void 0),
              (i.name = Object.keys({ TopologyException: o })[0]),
              i
            );
          }
          return (
            r(o, [
              {
                key: 'getCoordinate',
                value: function () {
                  return this.pt;
                },
              },
            ]),
            o
          );
        })(j),
        yt = (function () {
          function e() {
            t(this, e), (this.array = []);
          }
          return (
            r(e, [
              {
                key: 'addLast',
                value: function (t) {
                  this.array.push(t);
                },
              },
              {
                key: 'removeFirst',
                value: function () {
                  return this.array.shift();
                },
              },
              {
                key: 'isEmpty',
                value: function () {
                  return 0 === this.array.length;
                },
              },
            ]),
            e
          );
        })(),
        vt = (function (e, n) {
          i(a, e);
          var o = f(a);
          function a(e) {
            var n;
            return t(this, a), ((n = o.call(this)).array = []), e instanceof H && n.addAll(e), n;
          }
          return (
            r(a, [
              {
                key: 'interfaces_',
                get: function () {
                  return [rt, H];
                },
              },
              { key: 'ensureCapacity', value: function () {} },
              {
                key: 'add',
                value: function (t) {
                  return (
                    1 === arguments.length ? this.array.push(t) : this.array.splice(arguments[0], 0, arguments[1]), !0
                  );
                },
              },
              {
                key: 'clear',
                value: function () {
                  this.array = [];
                },
              },
              {
                key: 'addAll',
                value: function (t) {
                  var e,
                    n = d(t);
                  try {
                    for (n.s(); !(e = n.n()).done; ) {
                      var r = e.value;
                      this.array.push(r);
                    }
                  } catch (t) {
                    n.e(t);
                  } finally {
                    n.f();
                  }
                },
              },
              {
                key: 'set',
                value: function (t, e) {
                  var n = this.array[t];
                  return (this.array[t] = e), n;
                },
              },
              {
                key: 'iterator',
                value: function () {
                  return new dt(this);
                },
              },
              {
                key: 'get',
                value: function (t) {
                  if (t < 0 || t >= this.size()) throw new nt();
                  return this.array[t];
                },
              },
              {
                key: 'isEmpty',
                value: function () {
                  return 0 === this.array.length;
                },
              },
              {
                key: 'sort',
                value: function (t) {
                  t
                    ? this.array.sort(function (e, n) {
                        return t.compare(e, n);
                      })
                    : this.array.sort();
                },
              },
              {
                key: 'size',
                value: function () {
                  return this.array.length;
                },
              },
              {
                key: 'toArray',
                value: function () {
                  return this.array.slice();
                },
              },
              {
                key: 'remove',
                value: function (t) {
                  for (var e = 0, n = this.array.length; e < n; e++)
                    if (this.array[e] === t) return !!this.array.splice(e, 1);
                  return !1;
                },
              },
              {
                key: n,
                value: function () {
                  return this.array.values();
                },
              },
            ]),
            a
          );
        })(rt, Symbol.iterator),
        dt = (function () {
          function e(n) {
            t(this, e), (this.arrayList = n), (this.position = 0);
          }
          return (
            r(e, [
              {
                key: 'next',
                value: function () {
                  if (this.position === this.arrayList.size()) throw new Z();
                  return this.arrayList.get(this.position++);
                },
              },
              {
                key: 'hasNext',
                value: function () {
                  return this.position < this.arrayList.size();
                },
              },
              {
                key: 'set',
                value: function (t) {
                  return this.arrayList.set(this.position - 1, t);
                },
              },
              {
                key: 'remove',
                value: function () {
                  this.arrayList.remove(this.arrayList.get(this.position));
                },
              },
            ]),
            e
          );
        })(),
        mt = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'clearVisitedEdges',
                  value: function () {
                    for (var t = this._dirEdgeList.iterator(); t.hasNext(); ) t.next().setVisited(!1);
                  },
                },
                {
                  key: 'getRightmostCoordinate',
                  value: function () {
                    return this._rightMostCoord;
                  },
                },
                {
                  key: 'computeNodeDepth',
                  value: function (t) {
                    for (var e = null, n = t.getEdges().iterator(); n.hasNext(); ) {
                      var r = n.next();
                      if (r.isVisited() || r.getSym().isVisited()) {
                        e = r;
                        break;
                      }
                    }
                    if (null === e) throw new gt('unable to find edge to compute depths at ' + t.getCoordinate());
                    t.getEdges().computeDepths(e);
                    for (var i = t.getEdges().iterator(); i.hasNext(); ) {
                      var o = i.next();
                      o.setVisited(!0), this.copySymDepths(o);
                    }
                  },
                },
                {
                  key: 'computeDepth',
                  value: function (t) {
                    this.clearVisitedEdges();
                    var e = this._finder.getEdge();
                    e.getNode(),
                      e.getLabel(),
                      e.setEdgeDepths(tt.RIGHT, t),
                      this.copySymDepths(e),
                      this.computeDepths(e);
                  },
                },
                {
                  key: 'create',
                  value: function (t) {
                    this.addReachable(t),
                      this._finder.findEdge(this._dirEdgeList),
                      (this._rightMostCoord = this._finder.getCoordinate());
                  },
                },
                {
                  key: 'findResultEdges',
                  value: function () {
                    for (var t = this._dirEdgeList.iterator(); t.hasNext(); ) {
                      var e = t.next();
                      e.getDepth(tt.RIGHT) >= 1 &&
                        e.getDepth(tt.LEFT) <= 0 &&
                        !e.isInteriorAreaEdge() &&
                        e.setInResult(!0);
                    }
                  },
                },
                {
                  key: 'computeDepths',
                  value: function (t) {
                    var e = new Q(),
                      n = new yt(),
                      r = t.getNode();
                    for (n.addLast(r), e.add(r), t.setVisited(!0); !n.isEmpty(); ) {
                      var i = n.removeFirst();
                      e.add(i), this.computeNodeDepth(i);
                      for (var o = i.getEdges().iterator(); o.hasNext(); ) {
                        var a = o.next().getSym();
                        if (!a.isVisited()) {
                          var s = a.getNode();
                          e.contains(s) || (n.addLast(s), e.add(s));
                        }
                      }
                    }
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    return this._rightMostCoord.x < e._rightMostCoord.x
                      ? -1
                      : this._rightMostCoord.x > e._rightMostCoord.x
                      ? 1
                      : 0;
                  },
                },
                {
                  key: 'getEnvelope',
                  value: function () {
                    if (null === this._env) {
                      for (var t = new U(), e = this._dirEdgeList.iterator(); e.hasNext(); )
                        for (var n = e.next().getEdge().getCoordinates(), r = 0; r < n.length - 1; r++)
                          t.expandToInclude(n[r]);
                      this._env = t;
                    }
                    return this._env;
                  },
                },
                {
                  key: 'addReachable',
                  value: function (t) {
                    var e = new it();
                    for (e.add(t); !e.empty(); ) {
                      var n = e.pop();
                      this.add(n, e);
                    }
                  },
                },
                {
                  key: 'copySymDepths',
                  value: function (t) {
                    var e = t.getSym();
                    e.setDepth(tt.LEFT, t.getDepth(tt.RIGHT)), e.setDepth(tt.RIGHT, t.getDepth(tt.LEFT));
                  },
                },
                {
                  key: 'add',
                  value: function (t, e) {
                    t.setVisited(!0), this._nodes.add(t);
                    for (var n = t.getEdges().iterator(); n.hasNext(); ) {
                      var r = n.next();
                      this._dirEdgeList.add(r);
                      var i = r.getSym().getNode();
                      i.isVisited() || e.push(i);
                    }
                  },
                },
                {
                  key: 'getNodes',
                  value: function () {
                    return this._nodes;
                  },
                },
                {
                  key: 'getDirectedEdges',
                  value: function () {
                    return this._dirEdgeList;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._finder = null),
                      (this._dirEdgeList = new vt()),
                      (this._nodes = new vt()),
                      (this._rightMostCoord = null),
                      (this._env = null),
                      (this._finder = new pt());
                  },
                },
              ],
            ),
            e
          );
        })(),
        _t = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'intersection',
                value: function (t, e, n, r) {
                  var i = t.x < e.x ? t.x : e.x,
                    o = t.y < e.y ? t.y : e.y,
                    a = t.x > e.x ? t.x : e.x,
                    s = t.y > e.y ? t.y : e.y,
                    u = n.x < r.x ? n.x : r.x,
                    l = n.y < r.y ? n.y : r.y,
                    c = n.x > r.x ? n.x : r.x,
                    h = n.y > r.y ? n.y : r.y,
                    f = ((i > u ? i : u) + (a < c ? a : c)) / 2,
                    p = ((o > l ? o : l) + (s < h ? s : h)) / 2,
                    g = t.x - f,
                    y = t.y - p,
                    v = e.x - f,
                    d = e.y - p,
                    m = n.x - f,
                    _ = n.y - p,
                    b = r.x - f,
                    x = r.y - p,
                    E = y - d,
                    w = v - g,
                    k = g * d - v * y,
                    S = _ - x,
                    I = b - m,
                    P = m * x - b * _,
                    N = E * I - S * w,
                    M = (w * P - I * k) / N,
                    O = (S * k - E * P) / N;
                  return A.isNaN(M) || A.isInfinite(M) || A.isNaN(O) || A.isInfinite(O) ? null : new Y(M + f, O + p);
                },
              },
            ]),
            e
          );
        })(),
        bt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'arraycopy',
                value: function (t, e, n, r, i) {
                  for (var o = 0, a = e; a < e + i; a++) (n[r + o] = t[a]), o++;
                },
              },
              {
                key: 'getProperty',
                value: function (t) {
                  return { 'line.separator': '\n' }[t];
                },
              },
            ]),
            e
          );
        })(),
        xt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'log10',
                value: function (t) {
                  var n = Math.log(t);
                  return A.isInfinite(n) || A.isNaN(n) ? n : n / e.LOG_10;
                },
              },
              {
                key: 'min',
                value: function (t, e, n, r) {
                  var i = t;
                  return e < i && (i = e), n < i && (i = n), r < i && (i = r), i;
                },
              },
              {
                key: 'clamp',
                value: function () {
                  if (
                    'number' == typeof arguments[2] &&
                    'number' == typeof arguments[0] &&
                    'number' == typeof arguments[1]
                  ) {
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2];
                    return t < e ? e : t > n ? n : t;
                  }
                  if (
                    Number.isInteger(arguments[2]) &&
                    Number.isInteger(arguments[0]) &&
                    Number.isInteger(arguments[1])
                  ) {
                    var r = arguments[0],
                      i = arguments[1],
                      o = arguments[2];
                    return r < i ? i : r > o ? o : r;
                  }
                },
              },
              {
                key: 'wrap',
                value: function (t, e) {
                  return t < 0 ? e - (-t % e) : t % e;
                },
              },
              {
                key: 'max',
                value: function () {
                  if (3 === arguments.length) {
                    var t = arguments[1],
                      e = arguments[2],
                      n = arguments[0];
                    return t > n && (n = t), e > n && (n = e), n;
                  }
                  if (4 === arguments.length) {
                    var r = arguments[1],
                      i = arguments[2],
                      o = arguments[3],
                      a = arguments[0];
                    return r > a && (a = r), i > a && (a = i), o > a && (a = o), a;
                  }
                },
              },
              {
                key: 'average',
                value: function (t, e) {
                  return (t + e) / 2;
                },
              },
            ]),
            e
          );
        })();
      xt.LOG_10 = Math.log(10);
      var Et = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'segmentToSegment',
                value: function (t, n, r, i) {
                  if (t.equals(n)) return e.pointToSegment(t, r, i);
                  if (r.equals(i)) return e.pointToSegment(i, t, n);
                  var o = !1;
                  if (U.intersects(t, n, r, i)) {
                    var a = (n.x - t.x) * (i.y - r.y) - (n.y - t.y) * (i.x - r.x);
                    if (0 === a) o = !0;
                    else {
                      var s = (t.y - r.y) * (i.x - r.x) - (t.x - r.x) * (i.y - r.y),
                        u = ((t.y - r.y) * (n.x - t.x) - (t.x - r.x) * (n.y - t.y)) / a,
                        l = s / a;
                      (l < 0 || l > 1 || u < 0 || u > 1) && (o = !0);
                    }
                  } else o = !0;
                  return o
                    ? xt.min(
                        e.pointToSegment(t, r, i),
                        e.pointToSegment(n, r, i),
                        e.pointToSegment(r, t, n),
                        e.pointToSegment(i, t, n),
                      )
                    : 0;
                },
              },
              {
                key: 'pointToSegment',
                value: function (t, e, n) {
                  if (e.x === n.x && e.y === n.y) return t.distance(e);
                  var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
                    i = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / r;
                  if (i <= 0) return t.distance(e);
                  if (i >= 1) return t.distance(n);
                  var o = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r;
                  return Math.abs(o) * Math.sqrt(r);
                },
              },
              {
                key: 'pointToLinePerpendicular',
                value: function (t, e, n) {
                  var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y),
                    i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r;
                  return Math.abs(i) * Math.sqrt(r);
                },
              },
              {
                key: 'pointToSegmentString',
                value: function (t, n) {
                  if (0 === n.length) throw new b('Line array must contain at least one vertex');
                  for (var r = t.distance(n[0]), i = 0; i < n.length - 1; i++) {
                    var o = e.pointToSegment(t, n[i], n[i + 1]);
                    o < r && (r = o);
                  }
                  return r;
                },
              },
            ]),
            e
          );
        })(),
        wt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              {
                key: 'create',
                value: function () {
                  if (1 === arguments.length) arguments[0] instanceof Array || ot(arguments[0], ht);
                  else if (2 === arguments.length);
                  else if (3 === arguments.length) {
                    var t = arguments[0],
                      e = arguments[1];
                    return this.create(t, e);
                  }
                },
              },
            ]),
            e
          );
        })(),
        kt = (function () {
          function e() {
            t(this, e);
          }
          return r(e, [{ key: 'filter', value: function (t) {} }]), e;
        })(),
        St = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'ofLine',
                value: function (t) {
                  var e = t.size();
                  if (e <= 1) return 0;
                  var n = 0,
                    r = new Y();
                  t.getCoordinate(0, r);
                  for (var i = r.x, o = r.y, a = 1; a < e; a++) {
                    t.getCoordinate(a, r);
                    var s = r.x,
                      u = r.y,
                      l = s - i,
                      c = u - o;
                    (n += Math.sqrt(l * l + c * c)), (i = s), (o = u);
                  }
                  return n;
                },
              },
            ]),
            e
          );
        })(),
        It = function e() {
          t(this, e);
        },
        Pt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'copyCoord',
                value: function (t, e, n, r) {
                  for (var i = Math.min(t.getDimension(), n.getDimension()), o = 0; o < i; o++)
                    n.setOrdinate(r, o, t.getOrdinate(e, o));
                },
              },
              {
                key: 'isRing',
                value: function (t) {
                  var e = t.size();
                  return (
                    0 === e ||
                    (!(e <= 3) &&
                      t.getOrdinate(0, ht.X) === t.getOrdinate(e - 1, ht.X) &&
                      t.getOrdinate(0, ht.Y) === t.getOrdinate(e - 1, ht.Y))
                  );
                },
              },
              {
                key: 'scroll',
                value: function () {
                  if (2 === arguments.length) {
                    if (ot(arguments[0], ht) && Number.isInteger(arguments[1])) {
                      var t = arguments[0],
                        n = arguments[1];
                      e.scroll(t, n, e.isRing(t));
                    } else if (ot(arguments[0], ht) && arguments[1] instanceof Y) {
                      var r = arguments[0],
                        i = arguments[1],
                        o = e.indexOf(i, r);
                      if (o <= 0) return null;
                      e.scroll(r, o);
                    }
                  } else if (3 === arguments.length) {
                    var a = arguments[0],
                      s = arguments[1],
                      u = arguments[2];
                    if (s <= 0) return null;
                    for (var l = a.copy(), c = u ? a.size() - 1 : a.size(), h = 0; h < c; h++)
                      for (var f = 0; f < a.getDimension(); f++) a.setOrdinate(h, f, l.getOrdinate((s + h) % c, f));
                    if (u) for (var p = 0; p < a.getDimension(); p++) a.setOrdinate(c, p, a.getOrdinate(0, p));
                  }
                },
              },
              {
                key: 'isEqual',
                value: function (t, e) {
                  var n = t.size();
                  if (n !== e.size()) return !1;
                  for (var r = Math.min(t.getDimension(), e.getDimension()), i = 0; i < n; i++)
                    for (var o = 0; o < r; o++) {
                      var a = t.getOrdinate(i, o),
                        s = e.getOrdinate(i, o);
                      if (!(t.getOrdinate(i, o) === e.getOrdinate(i, o) || (A.isNaN(a) && A.isNaN(s)))) return !1;
                    }
                  return !0;
                },
              },
              {
                key: 'minCoordinateIndex',
                value: function () {
                  if (1 === arguments.length) {
                    var t = arguments[0];
                    return e.minCoordinateIndex(t, 0, t.size() - 1);
                  }
                  if (3 === arguments.length) {
                    for (var n = arguments[0], r = arguments[2], i = -1, o = null, a = arguments[1]; a <= r; a++) {
                      var s = n.getCoordinate(a);
                      (null === o || o.compareTo(s) > 0) && ((o = s), (i = a));
                    }
                    return i;
                  }
                },
              },
              {
                key: 'extend',
                value: function (t, n, r) {
                  var i = t.create(r, n.getDimension()),
                    o = n.size();
                  if ((e.copy(n, 0, i, 0, o), o > 0)) for (var a = o; a < r; a++) e.copy(n, o - 1, i, a, 1);
                  return i;
                },
              },
              {
                key: 'reverse',
                value: function (t) {
                  for (var n = t.size() - 1, r = Math.trunc(n / 2), i = 0; i <= r; i++) e.swap(t, i, n - i);
                },
              },
              {
                key: 'swap',
                value: function (t, e, n) {
                  if (e === n) return null;
                  for (var r = 0; r < t.getDimension(); r++) {
                    var i = t.getOrdinate(e, r);
                    t.setOrdinate(e, r, t.getOrdinate(n, r)), t.setOrdinate(n, r, i);
                  }
                },
              },
              {
                key: 'copy',
                value: function (t, n, r, i, o) {
                  for (var a = 0; a < o; a++) e.copyCoord(t, n + a, r, i + a);
                },
              },
              {
                key: 'ensureValidRing',
                value: function (t, n) {
                  var r = n.size();
                  return 0 === r
                    ? n
                    : r <= 3
                    ? e.createClosedRing(t, n, 4)
                    : n.getOrdinate(0, ht.X) === n.getOrdinate(r - 1, ht.X) &&
                      n.getOrdinate(0, ht.Y) === n.getOrdinate(r - 1, ht.Y)
                    ? n
                    : e.createClosedRing(t, n, r + 1);
                },
              },
              {
                key: 'indexOf',
                value: function (t, e) {
                  for (var n = 0; n < e.size(); n++)
                    if (t.x === e.getOrdinate(n, ht.X) && t.y === e.getOrdinate(n, ht.Y)) return n;
                  return -1;
                },
              },
              {
                key: 'createClosedRing',
                value: function (t, n, r) {
                  var i = t.create(r, n.getDimension()),
                    o = n.size();
                  e.copy(n, 0, i, 0, o);
                  for (var a = o; a < r; a++) e.copy(n, 0, i, a, 1);
                  return i;
                },
              },
              {
                key: 'minCoordinate',
                value: function (t) {
                  for (var e = null, n = 0; n < t.size(); n++) {
                    var r = t.getCoordinate(n);
                    (null === e || e.compareTo(r) > 0) && (e = r);
                  }
                  return e;
                },
              },
            ]),
            e
          );
        })(),
        Nt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'toDimensionSymbol',
                value: function (t) {
                  switch (t) {
                    case e.FALSE:
                      return e.SYM_FALSE;
                    case e.TRUE:
                      return e.SYM_TRUE;
                    case e.DONTCARE:
                      return e.SYM_DONTCARE;
                    case e.P:
                      return e.SYM_P;
                    case e.L:
                      return e.SYM_L;
                    case e.A:
                      return e.SYM_A;
                  }
                  throw new b('Unknown dimension value: ' + t);
                },
              },
              {
                key: 'toDimensionValue',
                value: function (t) {
                  switch (ut.toUpperCase(t)) {
                    case e.SYM_FALSE:
                      return e.FALSE;
                    case e.SYM_TRUE:
                      return e.TRUE;
                    case e.SYM_DONTCARE:
                      return e.DONTCARE;
                    case e.SYM_P:
                      return e.P;
                    case e.SYM_L:
                      return e.L;
                    case e.SYM_A:
                      return e.A;
                  }
                  throw new b('Unknown dimension symbol: ' + t);
                },
              },
            ]),
            e
          );
        })();
      (Nt.P = 0),
        (Nt.L = 1),
        (Nt.A = 2),
        (Nt.FALSE = -1),
        (Nt.TRUE = -2),
        (Nt.DONTCARE = -3),
        (Nt.SYM_FALSE = 'F'),
        (Nt.SYM_TRUE = 'T'),
        (Nt.SYM_DONTCARE = '*'),
        (Nt.SYM_P = '0'),
        (Nt.SYM_L = '1'),
        (Nt.SYM_A = '2');
      var Mt = (function () {
          function e() {
            t(this, e);
          }
          return r(e, [{ key: 'filter', value: function (t) {} }]), e;
        })(),
        Ot = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'filter', value: function (t, e) {} },
              { key: 'isDone', value: function () {} },
              { key: 'isGeometryChanged', value: function () {} },
            ]),
            e
          );
        })(),
        Lt = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'computeEnvelopeInternal',
                  value: function () {
                    return this.isEmpty() ? new U() : this._points.expandEnvelope(new U());
                  },
                },
                {
                  key: 'isRing',
                  value: function () {
                    return this.isClosed() && this.isSimple();
                  },
                },
                {
                  key: 'getCoordinates',
                  value: function () {
                    return this._points.toCoordinateArray();
                  },
                },
                {
                  key: 'copyInternal',
                  value: function () {
                    return new a(this._points.copy(), this._factory);
                  },
                },
                {
                  key: 'equalsExact',
                  value: function () {
                    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof X) {
                      var t = arguments[0],
                        e = arguments[1];
                      if (!this.isEquivalentClass(t)) return !1;
                      var n = t;
                      if (this._points.size() !== n._points.size()) return !1;
                      for (var r = 0; r < this._points.size(); r++)
                        if (!this.equal(this._points.getCoordinate(r), n._points.getCoordinate(r), e)) return !1;
                      return !0;
                    }
                    return p(o(a.prototype), 'equalsExact', this).apply(this, arguments);
                  },
                },
                {
                  key: 'normalize',
                  value: function () {
                    for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) {
                      var e = this._points.size() - 1 - t;
                      if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) {
                        if (this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0) {
                          var n = this._points.copy();
                          Pt.reverse(n), (this._points = n);
                        }
                        return null;
                      }
                    }
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    return this.isEmpty() ? null : this._points.getCoordinate(0);
                  },
                },
                {
                  key: 'getBoundaryDimension',
                  value: function () {
                    return this.isClosed() ? Nt.FALSE : 0;
                  },
                },
                {
                  key: 'isClosed',
                  value: function () {
                    return (
                      !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
                    );
                  },
                },
                {
                  key: 'reverseInternal',
                  value: function () {
                    var t = this._points.copy();
                    return Pt.reverse(t), this.getFactory().createLineString(t);
                  },
                },
                {
                  key: 'getEndPoint',
                  value: function () {
                    return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
                  },
                },
                {
                  key: 'getTypeCode',
                  value: function () {
                    return X.TYPECODE_LINESTRING;
                  },
                },
                {
                  key: 'getDimension',
                  value: function () {
                    return 1;
                  },
                },
                {
                  key: 'getLength',
                  value: function () {
                    return St.ofLine(this._points);
                  },
                },
                {
                  key: 'getNumPoints',
                  value: function () {
                    return this._points.size();
                  },
                },
                {
                  key: 'compareToSameClass',
                  value: function () {
                    if (1 === arguments.length) {
                      for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size(); ) {
                        var r = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));
                        if (0 !== r) return r;
                        e++, n++;
                      }
                      return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0;
                    }
                    if (2 === arguments.length) {
                      var i = arguments[0];
                      return arguments[1].compare(this._points, i._points);
                    }
                  },
                },
                {
                  key: 'apply',
                  value: function () {
                    if (ot(arguments[0], kt))
                      for (var t = arguments[0], e = 0; e < this._points.size(); e++)
                        t.filter(this._points.getCoordinate(e));
                    else if (ot(arguments[0], Ot)) {
                      var n = arguments[0];
                      if (0 === this._points.size()) return null;
                      for (var r = 0; r < this._points.size() && (n.filter(this._points, r), !n.isDone()); r++);
                      n.isGeometryChanged() && this.geometryChanged();
                    } else (ot(arguments[0], Mt) || ot(arguments[0], x)) && arguments[0].filter(this);
                  },
                },
                {
                  key: 'getBoundary',
                  value: function () {
                    throw new J();
                  },
                },
                {
                  key: 'isEquivalentClass',
                  value: function (t) {
                    return t instanceof a;
                  },
                },
                {
                  key: 'getCoordinateN',
                  value: function (t) {
                    return this._points.getCoordinate(t);
                  },
                },
                {
                  key: 'getGeometryType',
                  value: function () {
                    return X.TYPENAME_LINESTRING;
                  },
                },
                {
                  key: 'getCoordinateSequence',
                  value: function () {
                    return this._points;
                  },
                },
                {
                  key: 'isEmpty',
                  value: function () {
                    return 0 === this._points.size();
                  },
                },
                {
                  key: 'init',
                  value: function (t) {
                    if (
                      (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size())
                    )
                      throw new b(
                        'Invalid number of points in LineString (found ' + t.size() + ' - must be 0 or >= 2)',
                      );
                    this._points = t;
                  },
                },
                {
                  key: 'isCoordinate',
                  value: function (t) {
                    for (var e = 0; e < this._points.size(); e++)
                      if (this._points.getCoordinate(e).equals(t)) return !0;
                    return !1;
                  },
                },
                {
                  key: 'getStartPoint',
                  value: function () {
                    return this.isEmpty() ? null : this.getPointN(0);
                  },
                },
                {
                  key: 'getPointN',
                  value: function (t) {
                    return this.getFactory().createPoint(this._points.getCoordinate(t));
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [It];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._points = null), 0 === arguments.length));
                    else if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1];
                      X.constructor_.call(this, e), this.init(t);
                    }
                  },
                },
              ],
            ),
            a
          );
        })(X),
        Rt = function e() {
          t(this, e);
        },
        Ct = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'computeEnvelopeInternal',
                  value: function () {
                    if (this.isEmpty()) return new U();
                    var t = new U();
                    return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t;
                  },
                },
                {
                  key: 'getCoordinates',
                  value: function () {
                    return this.isEmpty() ? [] : [this.getCoordinate()];
                  },
                },
                {
                  key: 'copyInternal',
                  value: function () {
                    return new a(this._coordinates.copy(), this._factory);
                  },
                },
                {
                  key: 'equalsExact',
                  value: function () {
                    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof X) {
                      var t = arguments[0],
                        e = arguments[1];
                      return (
                        !!this.isEquivalentClass(t) &&
                        (!(!this.isEmpty() || !t.isEmpty()) ||
                          (this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e)))
                      );
                    }
                    return p(o(a.prototype), 'equalsExact', this).apply(this, arguments);
                  },
                },
                { key: 'normalize', value: function () {} },
                {
                  key: 'getCoordinate',
                  value: function () {
                    return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
                  },
                },
                {
                  key: 'getBoundaryDimension',
                  value: function () {
                    return Nt.FALSE;
                  },
                },
                {
                  key: 'reverseInternal',
                  value: function () {
                    return this.getFactory().createPoint(this._coordinates.copy());
                  },
                },
                {
                  key: 'getTypeCode',
                  value: function () {
                    return X.TYPECODE_POINT;
                  },
                },
                {
                  key: 'getDimension',
                  value: function () {
                    return 0;
                  },
                },
                {
                  key: 'getNumPoints',
                  value: function () {
                    return this.isEmpty() ? 0 : 1;
                  },
                },
                {
                  key: 'getX',
                  value: function () {
                    if (null === this.getCoordinate()) throw new IllegalStateException('getX called on empty Point');
                    return this.getCoordinate().x;
                  },
                },
                {
                  key: 'compareToSameClass',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      return this.getCoordinate().compareTo(t.getCoordinate());
                    }
                    if (2 === arguments.length) {
                      var e = arguments[0];
                      return arguments[1].compare(this._coordinates, e._coordinates);
                    }
                  },
                },
                {
                  key: 'apply',
                  value: function () {
                    if (ot(arguments[0], kt)) {
                      var t = arguments[0];
                      if (this.isEmpty()) return null;
                      t.filter(this.getCoordinate());
                    } else if (ot(arguments[0], Ot)) {
                      var e = arguments[0];
                      if (this.isEmpty()) return null;
                      e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged();
                    } else (ot(arguments[0], Mt) || ot(arguments[0], x)) && arguments[0].filter(this);
                  },
                },
                {
                  key: 'getBoundary',
                  value: function () {
                    return this.getFactory().createGeometryCollection();
                  },
                },
                {
                  key: 'getGeometryType',
                  value: function () {
                    return X.TYPENAME_POINT;
                  },
                },
                {
                  key: 'getCoordinateSequence',
                  value: function () {
                    return this._coordinates;
                  },
                },
                {
                  key: 'getY',
                  value: function () {
                    if (null === this.getCoordinate()) throw new IllegalStateException('getY called on empty Point');
                    return this.getCoordinate().y;
                  },
                },
                {
                  key: 'isEmpty',
                  value: function () {
                    return 0 === this._coordinates.size();
                  },
                },
                {
                  key: 'init',
                  value: function (t) {
                    null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])),
                      B.isTrue(t.size() <= 1),
                      (this._coordinates = t);
                  },
                },
                {
                  key: 'isSimple',
                  value: function () {
                    return !0;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Rt];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    this._coordinates = null;
                    var t = arguments[0],
                      e = arguments[1];
                    X.constructor_.call(this, e), this.init(t);
                  },
                },
              ],
            ),
            a
          );
        })(X),
        Tt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'ofRing',
                value: function () {
                  if (arguments[0] instanceof Array) {
                    var t = arguments[0];
                    return Math.abs(e.ofRingSigned(t));
                  }
                  if (ot(arguments[0], ht)) {
                    var n = arguments[0];
                    return Math.abs(e.ofRingSigned(n));
                  }
                },
              },
              {
                key: 'ofRingSigned',
                value: function () {
                  if (arguments[0] instanceof Array) {
                    var t = arguments[0];
                    if (t.length < 3) return 0;
                    for (var e = 0, n = t[0].x, r = 1; r < t.length - 1; r++) {
                      var i = t[r].x - n,
                        o = t[r + 1].y;
                      e += i * (t[r - 1].y - o);
                    }
                    return e / 2;
                  }
                  if (ot(arguments[0], ht)) {
                    var a = arguments[0],
                      s = a.size();
                    if (s < 3) return 0;
                    var u = new Y(),
                      l = new Y(),
                      c = new Y();
                    a.getCoordinate(0, l), a.getCoordinate(1, c);
                    var h = l.x;
                    c.x -= h;
                    for (var f = 0, p = 1; p < s - 1; p++)
                      (u.y = l.y),
                        (l.x = c.x),
                        (l.y = c.y),
                        a.getCoordinate(p + 1, c),
                        (c.x -= h),
                        (f += l.x * (u.y - c.y));
                    return f / 2;
                  }
                },
              },
            ]),
            e
          );
        })(),
        At = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'sort',
                value: function () {
                  var t = arguments,
                    e = arguments[0];
                  if (1 === arguments.length)
                    e.sort(function (t, e) {
                      return t.compareTo(e);
                    });
                  else if (2 === arguments.length)
                    e.sort(function (e, n) {
                      return t[1].compare(e, n);
                    });
                  else if (3 === arguments.length) {
                    var n = e.slice(arguments[1], arguments[2]);
                    n.sort();
                    var r = e.slice(0, arguments[1]).concat(n, e.slice(arguments[2], e.length));
                    e.splice(0, e.length);
                    var i,
                      o = d(r);
                    try {
                      for (o.s(); !(i = o.n()).done; ) {
                        var a = i.value;
                        e.push(a);
                      }
                    } catch (t) {
                      o.e(t);
                    } finally {
                      o.f();
                    }
                  } else if (4 === arguments.length) {
                    var s = e.slice(arguments[1], arguments[2]);
                    s.sort(function (e, n) {
                      return t[3].compare(e, n);
                    });
                    var u = e.slice(0, arguments[1]).concat(s, e.slice(arguments[2], e.length));
                    e.splice(0, e.length);
                    var l,
                      c = d(u);
                    try {
                      for (c.s(); !(l = c.n()).done; ) {
                        var h = l.value;
                        e.push(h);
                      }
                    } catch (t) {
                      c.e(t);
                    } finally {
                      c.f();
                    }
                  }
                },
              },
              {
                key: 'asList',
                value: function (t) {
                  var e,
                    n = new vt(),
                    r = d(t);
                  try {
                    for (r.s(); !(e = r.n()).done; ) {
                      var i = e.value;
                      n.add(i);
                    }
                  } catch (t) {
                    r.e(t);
                  } finally {
                    r.f();
                  }
                  return n;
                },
              },
              {
                key: 'copyOf',
                value: function (t, e) {
                  return t.slice(0, e);
                },
              },
            ]),
            e
          );
        })(),
        Dt = function e() {
          t(this, e);
        },
        jt = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'computeEnvelopeInternal',
                  value: function () {
                    return this._shell.getEnvelopeInternal();
                  },
                },
                {
                  key: 'getCoordinates',
                  value: function () {
                    if (this.isEmpty()) return [];
                    for (
                      var t = new Array(this.getNumPoints()).fill(null),
                        e = -1,
                        n = this._shell.getCoordinates(),
                        r = 0;
                      r < n.length;
                      r++
                    )
                      t[++e] = n[r];
                    for (var i = 0; i < this._holes.length; i++)
                      for (var o = this._holes[i].getCoordinates(), a = 0; a < o.length; a++) t[++e] = o[a];
                    return t;
                  },
                },
                {
                  key: 'getArea',
                  value: function () {
                    var t = 0;
                    t += Tt.ofRing(this._shell.getCoordinateSequence());
                    for (var e = 0; e < this._holes.length; e++) t -= Tt.ofRing(this._holes[e].getCoordinateSequence());
                    return t;
                  },
                },
                {
                  key: 'copyInternal',
                  value: function () {
                    for (
                      var t = this._shell.copy(), e = new Array(this._holes.length).fill(null), n = 0;
                      n < this._holes.length;
                      n++
                    )
                      e[n] = this._holes[n].copy();
                    return new a(t, e, this._factory);
                  },
                },
                {
                  key: 'isRectangle',
                  value: function () {
                    if (0 !== this.getNumInteriorRing()) return !1;
                    if (null === this._shell) return !1;
                    if (5 !== this._shell.getNumPoints()) return !1;
                    for (
                      var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0;
                      n < 5;
                      n++
                    ) {
                      var r = t.getX(n);
                      if (r !== e.getMinX() && r !== e.getMaxX()) return !1;
                      var i = t.getY(n);
                      if (i !== e.getMinY() && i !== e.getMaxY()) return !1;
                    }
                    for (var o = t.getX(0), a = t.getY(0), s = 1; s <= 4; s++) {
                      var u = t.getX(s),
                        l = t.getY(s);
                      if ((u !== o) == (l !== a)) return !1;
                      (o = u), (a = l);
                    }
                    return !0;
                  },
                },
                {
                  key: 'equalsExact',
                  value: function () {
                    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof X) {
                      var t = arguments[0],
                        e = arguments[1];
                      if (!this.isEquivalentClass(t)) return !1;
                      var n = t,
                        r = this._shell,
                        i = n._shell;
                      if (!r.equalsExact(i, e)) return !1;
                      if (this._holes.length !== n._holes.length) return !1;
                      for (var s = 0; s < this._holes.length; s++)
                        if (!this._holes[s].equalsExact(n._holes[s], e)) return !1;
                      return !0;
                    }
                    return p(o(a.prototype), 'equalsExact', this).apply(this, arguments);
                  },
                },
                {
                  key: 'normalize',
                  value: function () {
                    if (0 === arguments.length) {
                      this._shell = this.normalized(this._shell, !0);
                      for (var t = 0; t < this._holes.length; t++) this._holes[t] = this.normalized(this._holes[t], !1);
                      At.sort(this._holes);
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      if (e.isEmpty()) return null;
                      var r = e.getCoordinateSequence(),
                        i = Pt.minCoordinateIndex(r, 0, r.size() - 2);
                      Pt.scroll(r, i, !0), ft.isCCW(r) === n && Pt.reverse(r);
                    }
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    return this._shell.getCoordinate();
                  },
                },
                {
                  key: 'getNumInteriorRing',
                  value: function () {
                    return this._holes.length;
                  },
                },
                {
                  key: 'getBoundaryDimension',
                  value: function () {
                    return 1;
                  },
                },
                {
                  key: 'reverseInternal',
                  value: function () {
                    for (
                      var t = this.getExteriorRing().reverse(),
                        e = new Array(this.getNumInteriorRing()).fill(null),
                        n = 0;
                      n < e.length;
                      n++
                    )
                      e[n] = this.getInteriorRingN(n).reverse();
                    return this.getFactory().createPolygon(t, e);
                  },
                },
                {
                  key: 'getTypeCode',
                  value: function () {
                    return X.TYPECODE_POLYGON;
                  },
                },
                {
                  key: 'getDimension',
                  value: function () {
                    return 2;
                  },
                },
                {
                  key: 'getLength',
                  value: function () {
                    var t = 0;
                    t += this._shell.getLength();
                    for (var e = 0; e < this._holes.length; e++) t += this._holes[e].getLength();
                    return t;
                  },
                },
                {
                  key: 'getNumPoints',
                  value: function () {
                    for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++)
                      t += this._holes[e].getNumPoints();
                    return t;
                  },
                },
                {
                  key: 'convexHull',
                  value: function () {
                    return this.getExteriorRing().convexHull();
                  },
                },
                {
                  key: 'normalized',
                  value: function (t, e) {
                    var n = t.copy();
                    return this.normalize(n, e), n;
                  },
                },
                {
                  key: 'compareToSameClass',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0],
                        e = this._shell,
                        n = t._shell;
                      return e.compareToSameClass(n);
                    }
                    if (2 === arguments.length) {
                      var r = arguments[1],
                        i = arguments[0],
                        o = this._shell,
                        a = i._shell,
                        s = o.compareToSameClass(a, r);
                      if (0 !== s) return s;
                      for (var u = this.getNumInteriorRing(), l = i.getNumInteriorRing(), c = 0; c < u && c < l; ) {
                        var h = this.getInteriorRingN(c),
                          f = i.getInteriorRingN(c),
                          p = h.compareToSameClass(f, r);
                        if (0 !== p) return p;
                        c++;
                      }
                      return c < u ? 1 : c < l ? -1 : 0;
                    }
                  },
                },
                {
                  key: 'apply',
                  value: function () {
                    if (ot(arguments[0], kt)) {
                      var t = arguments[0];
                      this._shell.apply(t);
                      for (var e = 0; e < this._holes.length; e++) this._holes[e].apply(t);
                    } else if (ot(arguments[0], Ot)) {
                      var n = arguments[0];
                      if ((this._shell.apply(n), !n.isDone()))
                        for (var r = 0; r < this._holes.length && (this._holes[r].apply(n), !n.isDone()); r++);
                      n.isGeometryChanged() && this.geometryChanged();
                    } else if (ot(arguments[0], Mt)) arguments[0].filter(this);
                    else if (ot(arguments[0], x)) {
                      var i = arguments[0];
                      i.filter(this), this._shell.apply(i);
                      for (var o = 0; o < this._holes.length; o++) this._holes[o].apply(i);
                    }
                  },
                },
                {
                  key: 'getBoundary',
                  value: function () {
                    if (this.isEmpty()) return this.getFactory().createMultiLineString();
                    var t = new Array(this._holes.length + 1).fill(null);
                    t[0] = this._shell;
                    for (var e = 0; e < this._holes.length; e++) t[e + 1] = this._holes[e];
                    return t.length <= 1
                      ? this.getFactory().createLinearRing(t[0].getCoordinateSequence())
                      : this.getFactory().createMultiLineString(t);
                  },
                },
                {
                  key: 'getGeometryType',
                  value: function () {
                    return X.TYPENAME_POLYGON;
                  },
                },
                {
                  key: 'getExteriorRing',
                  value: function () {
                    return this._shell;
                  },
                },
                {
                  key: 'isEmpty',
                  value: function () {
                    return this._shell.isEmpty();
                  },
                },
                {
                  key: 'getInteriorRingN',
                  value: function (t) {
                    return this._holes[t];
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Dt];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._shell = null), (this._holes = null);
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2];
                    if (
                      (X.constructor_.call(this, n),
                      null === t && (t = this.getFactory().createLinearRing()),
                      null === e && (e = []),
                      X.hasNullElements(e))
                    )
                      throw new b('holes must not contain null elements');
                    if (t.isEmpty() && X.hasNonEmptyElements(e)) throw new b('shell is empty but holes are not');
                    (this._shell = t), (this._holes = e);
                  },
                },
              ],
            ),
            a
          );
        })(X),
        Ft = (function (e) {
          i(r, e);
          var n = f(r);
          function r() {
            return t(this, r), n.apply(this, arguments);
          }
          return r;
        })($),
        Bt = (function (e) {
          i(o, e);
          var n = f(o);
          function o(e) {
            var r;
            return t(this, o), ((r = n.call(this)).array = []), e instanceof H && r.addAll(e), r;
          }
          return (
            r(o, [
              {
                key: 'contains',
                value: function (t) {
                  var e,
                    n = d(this.array);
                  try {
                    for (n.s(); !(e = n.n()).done; ) if (0 === e.value.compareTo(t)) return !0;
                  } catch (t) {
                    n.e(t);
                  } finally {
                    n.f();
                  }
                  return !1;
                },
              },
              {
                key: 'add',
                value: function (t) {
                  if (this.contains(t)) return !1;
                  for (var e = 0, n = this.array.length; e < n; e++)
                    if (1 === this.array[e].compareTo(t)) return !!this.array.splice(e, 0, t);
                  return this.array.push(t), !0;
                },
              },
              {
                key: 'addAll',
                value: function (t) {
                  var e,
                    n = d(t);
                  try {
                    for (n.s(); !(e = n.n()).done; ) {
                      var r = e.value;
                      this.add(r);
                    }
                  } catch (t) {
                    n.e(t);
                  } finally {
                    n.f();
                  }
                  return !0;
                },
              },
              {
                key: 'remove',
                value: function () {
                  throw new J();
                },
              },
              {
                key: 'size',
                value: function () {
                  return this.array.length;
                },
              },
              {
                key: 'isEmpty',
                value: function () {
                  return 0 === this.array.length;
                },
              },
              {
                key: 'toArray',
                value: function () {
                  return this.array.slice();
                },
              },
              {
                key: 'iterator',
                value: function () {
                  return new qt(this.array);
                },
              },
            ]),
            o
          );
        })(Ft),
        qt = (function () {
          function e(n) {
            t(this, e), (this.array = n), (this.position = 0);
          }
          return (
            r(e, [
              {
                key: 'next',
                value: function () {
                  if (this.position === this.array.length) throw new Z();
                  return this.array[this.position++];
                },
              },
              {
                key: 'hasNext',
                value: function () {
                  return this.position < this.array.length;
                },
              },
              {
                key: 'remove',
                value: function () {
                  throw new J();
                },
              },
            ]),
            e
          );
        })(),
        Vt = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'computeEnvelopeInternal',
                  value: function () {
                    for (var t = new U(), e = 0; e < this._geometries.length; e++)
                      t.expandToInclude(this._geometries[e].getEnvelopeInternal());
                    return t;
                  },
                },
                {
                  key: 'getGeometryN',
                  value: function (t) {
                    return this._geometries[t];
                  },
                },
                {
                  key: 'getCoordinates',
                  value: function () {
                    for (
                      var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0;
                      n < this._geometries.length;
                      n++
                    )
                      for (var r = this._geometries[n].getCoordinates(), i = 0; i < r.length; i++) t[++e] = r[i];
                    return t;
                  },
                },
                {
                  key: 'getArea',
                  value: function () {
                    for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getArea();
                    return t;
                  },
                },
                {
                  key: 'copyInternal',
                  value: function () {
                    for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++)
                      t[e] = this._geometries[e].copy();
                    return new a(t, this._factory);
                  },
                },
                {
                  key: 'equalsExact',
                  value: function () {
                    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof X) {
                      var t = arguments[0],
                        e = arguments[1];
                      if (!this.isEquivalentClass(t)) return !1;
                      var n = t;
                      if (this._geometries.length !== n._geometries.length) return !1;
                      for (var r = 0; r < this._geometries.length; r++)
                        if (!this._geometries[r].equalsExact(n._geometries[r], e)) return !1;
                      return !0;
                    }
                    return p(o(a.prototype), 'equalsExact', this).apply(this, arguments);
                  },
                },
                {
                  key: 'normalize',
                  value: function () {
                    for (var t = 0; t < this._geometries.length; t++) this._geometries[t].normalize();
                    At.sort(this._geometries);
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    return this.isEmpty() ? null : this._geometries[0].getCoordinate();
                  },
                },
                {
                  key: 'getBoundaryDimension',
                  value: function () {
                    for (var t = Nt.FALSE, e = 0; e < this._geometries.length; e++)
                      t = Math.max(t, this._geometries[e].getBoundaryDimension());
                    return t;
                  },
                },
                {
                  key: 'reverseInternal',
                  value: function () {
                    for (var t = this._geometries.length, e = new vt(t), n = 0; n < t; n++)
                      e.add(this._geometries[n].reverse());
                    return this.getFactory().buildGeometry(e);
                  },
                },
                {
                  key: 'getTypeCode',
                  value: function () {
                    return X.TYPECODE_GEOMETRYCOLLECTION;
                  },
                },
                {
                  key: 'getDimension',
                  value: function () {
                    for (var t = Nt.FALSE, e = 0; e < this._geometries.length; e++)
                      t = Math.max(t, this._geometries[e].getDimension());
                    return t;
                  },
                },
                {
                  key: 'getLength',
                  value: function () {
                    for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getLength();
                    return t;
                  },
                },
                {
                  key: 'getNumPoints',
                  value: function () {
                    for (var t = 0, e = 0; e < this._geometries.length; e++) t += this._geometries[e].getNumPoints();
                    return t;
                  },
                },
                {
                  key: 'getNumGeometries',
                  value: function () {
                    return this._geometries.length;
                  },
                },
                {
                  key: 'compareToSameClass',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0],
                        e = new Bt(At.asList(this._geometries)),
                        n = new Bt(At.asList(t._geometries));
                      return this.compare(e, n);
                    }
                    if (2 === arguments.length) {
                      for (
                        var r = arguments[1],
                          i = arguments[0],
                          o = this.getNumGeometries(),
                          a = i.getNumGeometries(),
                          s = 0;
                        s < o && s < a;

                      ) {
                        var u = this.getGeometryN(s),
                          l = i.getGeometryN(s),
                          c = u.compareToSameClass(l, r);
                        if (0 !== c) return c;
                        s++;
                      }
                      return s < o ? 1 : s < a ? -1 : 0;
                    }
                  },
                },
                {
                  key: 'apply',
                  value: function () {
                    if (ot(arguments[0], kt))
                      for (var t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t);
                    else if (ot(arguments[0], Ot)) {
                      var n = arguments[0];
                      if (0 === this._geometries.length) return null;
                      for (var r = 0; r < this._geometries.length && (this._geometries[r].apply(n), !n.isDone()); r++);
                      n.isGeometryChanged() && this.geometryChanged();
                    } else if (ot(arguments[0], Mt)) {
                      var i = arguments[0];
                      i.filter(this);
                      for (var o = 0; o < this._geometries.length; o++) this._geometries[o].apply(i);
                    } else if (ot(arguments[0], x)) {
                      var a = arguments[0];
                      a.filter(this);
                      for (var s = 0; s < this._geometries.length; s++) this._geometries[s].apply(a);
                    }
                  },
                },
                {
                  key: 'getBoundary',
                  value: function () {
                    return X.checkNotGeometryCollection(this), B.shouldNeverReachHere(), null;
                  },
                },
                {
                  key: 'getGeometryType',
                  value: function () {
                    return X.TYPENAME_GEOMETRYCOLLECTION;
                  },
                },
                {
                  key: 'isEmpty',
                  value: function () {
                    for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1;
                    return !0;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._geometries = null), 0 === arguments.length));
                    else if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1];
                      if ((X.constructor_.call(this, e), null === t && (t = []), X.hasNullElements(t)))
                        throw new b('geometries must not contain null elements');
                      this._geometries = t;
                    }
                  },
                },
              ],
            ),
            a
          );
        })(X),
        Gt = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'copyInternal',
                  value: function () {
                    for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++)
                      t[e] = this._geometries[e].copy();
                    return new a(t, this._factory);
                  },
                },
                {
                  key: 'isValid',
                  value: function () {
                    return !0;
                  },
                },
                {
                  key: 'equalsExact',
                  value: function () {
                    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof X) {
                      var t = arguments[0],
                        e = arguments[1];
                      return !!this.isEquivalentClass(t) && p(o(a.prototype), 'equalsExact', this).call(this, t, e);
                    }
                    return p(o(a.prototype), 'equalsExact', this).apply(this, arguments);
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    if (1 === arguments.length && Number.isInteger(arguments[0])) {
                      var t = arguments[0];
                      return this._geometries[t].getCoordinate();
                    }
                    return p(o(a.prototype), 'getCoordinate', this).apply(this, arguments);
                  },
                },
                {
                  key: 'getBoundaryDimension',
                  value: function () {
                    return Nt.FALSE;
                  },
                },
                {
                  key: 'getTypeCode',
                  value: function () {
                    return X.TYPECODE_MULTIPOINT;
                  },
                },
                {
                  key: 'getDimension',
                  value: function () {
                    return 0;
                  },
                },
                {
                  key: 'getBoundary',
                  value: function () {
                    return this.getFactory().createGeometryCollection();
                  },
                },
                {
                  key: 'getGeometryType',
                  value: function () {
                    return X.TYPENAME_MULTIPOINT;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Rt];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    var t = arguments[0],
                      e = arguments[1];
                    Vt.constructor_.call(this, t, e);
                  },
                },
              ],
            ),
            a
          );
        })(Vt),
        Yt = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'copyInternal',
                  value: function () {
                    return new a(this._points.copy(), this._factory);
                  },
                },
                {
                  key: 'getBoundaryDimension',
                  value: function () {
                    return Nt.FALSE;
                  },
                },
                {
                  key: 'isClosed',
                  value: function () {
                    return !!this.isEmpty() || p(o(a.prototype), 'isClosed', this).call(this);
                  },
                },
                {
                  key: 'reverseInternal',
                  value: function () {
                    var t = this._points.copy();
                    return Pt.reverse(t), this.getFactory().createLinearRing(t);
                  },
                },
                {
                  key: 'getTypeCode',
                  value: function () {
                    return X.TYPECODE_LINEARRING;
                  },
                },
                {
                  key: 'validateConstruction',
                  value: function () {
                    if (!this.isEmpty() && !p(o(a.prototype), 'isClosed', this).call(this))
                      throw new b('Points of LinearRing do not form a closed linestring');
                    if (
                      this.getCoordinateSequence().size() >= 1 &&
                      this.getCoordinateSequence().size() < a.MINIMUM_VALID_SIZE
                    )
                      throw new b(
                        'Invalid number of points in LinearRing (found ' +
                          this.getCoordinateSequence().size() +
                          ' - must be 0 or >= 4)',
                      );
                  },
                },
                {
                  key: 'getGeometryType',
                  value: function () {
                    return X.TYPENAME_LINEARRING;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    var t = arguments[0],
                      e = arguments[1];
                    Lt.constructor_.call(this, t, e), this.validateConstruction();
                  },
                },
              ],
            ),
            a
          );
        })(Lt);
      Yt.MINIMUM_VALID_SIZE = 4;
      var zt = (function (e) {
        i(o, e);
        var n = f(o);
        function o() {
          var e;
          return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
        }
        return (
          r(
            o,
            [
              {
                key: 'setOrdinate',
                value: function (t, e) {
                  switch (t) {
                    case o.X:
                      this.x = e;
                      break;
                    case o.Y:
                      this.y = e;
                      break;
                    default:
                      throw new b('Invalid ordinate index: ' + t);
                  }
                },
              },
              {
                key: 'getZ',
                value: function () {
                  return Y.NULL_ORDINATE;
                },
              },
              {
                key: 'getOrdinate',
                value: function (t) {
                  switch (t) {
                    case o.X:
                      return this.x;
                    case o.Y:
                      return this.y;
                  }
                  throw new b('Invalid ordinate index: ' + t);
                },
              },
              {
                key: 'setZ',
                value: function (t) {
                  throw new b('CoordinateXY dimension 2 does not support z-ordinate');
                },
              },
              {
                key: 'copy',
                value: function () {
                  return new o(this);
                },
              },
              {
                key: 'toString',
                value: function () {
                  return '(' + this.x + ', ' + this.y + ')';
                },
              },
              {
                key: 'setCoordinate',
                value: function (t) {
                  (this.x = t.x), (this.y = t.y), (this.z = t.getZ());
                },
              },
            ],
            [
              {
                key: 'constructor_',
                value: function () {
                  if (0 === arguments.length) Y.constructor_.call(this);
                  else if (1 === arguments.length) {
                    if (arguments[0] instanceof o) {
                      var t = arguments[0];
                      Y.constructor_.call(this, t.x, t.y);
                    } else if (arguments[0] instanceof Y) {
                      var e = arguments[0];
                      Y.constructor_.call(this, e.x, e.y);
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      r = arguments[1];
                    Y.constructor_.call(this, n, r, Y.NULL_ORDINATE);
                  }
                },
              },
            ],
          ),
          o
        );
      })(Y);
      (zt.X = 0), (zt.Y = 1), (zt.Z = -1), (zt.M = -1);
      var Ut = (function (e) {
        i(o, e);
        var n = f(o);
        function o() {
          var e;
          return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
        }
        return (
          r(
            o,
            [
              {
                key: 'getM',
                value: function () {
                  return this._m;
                },
              },
              {
                key: 'setOrdinate',
                value: function (t, e) {
                  switch (t) {
                    case o.X:
                      this.x = e;
                      break;
                    case o.Y:
                      this.y = e;
                      break;
                    case o.M:
                      this._m = e;
                      break;
                    default:
                      throw new b('Invalid ordinate index: ' + t);
                  }
                },
              },
              {
                key: 'setM',
                value: function (t) {
                  this._m = t;
                },
              },
              {
                key: 'getZ',
                value: function () {
                  return Y.NULL_ORDINATE;
                },
              },
              {
                key: 'getOrdinate',
                value: function (t) {
                  switch (t) {
                    case o.X:
                      return this.x;
                    case o.Y:
                      return this.y;
                    case o.M:
                      return this._m;
                  }
                  throw new b('Invalid ordinate index: ' + t);
                },
              },
              {
                key: 'setZ',
                value: function (t) {
                  throw new b('CoordinateXY dimension 2 does not support z-ordinate');
                },
              },
              {
                key: 'copy',
                value: function () {
                  return new o(this);
                },
              },
              {
                key: 'toString',
                value: function () {
                  return '(' + this.x + ', ' + this.y + ' m=' + this.getM() + ')';
                },
              },
              {
                key: 'setCoordinate',
                value: function (t) {
                  (this.x = t.x), (this.y = t.y), (this.z = t.getZ()), (this._m = t.getM());
                },
              },
            ],
            [
              {
                key: 'constructor_',
                value: function () {
                  if (((this._m = null), 0 === arguments.length)) Y.constructor_.call(this), (this._m = 0);
                  else if (1 === arguments.length) {
                    if (arguments[0] instanceof o) {
                      var t = arguments[0];
                      Y.constructor_.call(this, t.x, t.y), (this._m = t._m);
                    } else if (arguments[0] instanceof Y) {
                      var e = arguments[0];
                      Y.constructor_.call(this, e.x, e.y), (this._m = this.getM());
                    }
                  } else if (3 === arguments.length) {
                    var n = arguments[0],
                      r = arguments[1],
                      i = arguments[2];
                    Y.constructor_.call(this, n, r, Y.NULL_ORDINATE), (this._m = i);
                  }
                },
              },
            ],
          ),
          o
        );
      })(Y);
      (Ut.X = 0), (Ut.Y = 1), (Ut.Z = -1), (Ut.M = 2);
      var Xt = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              o,
              [
                {
                  key: 'getM',
                  value: function () {
                    return this._m;
                  },
                },
                {
                  key: 'setOrdinate',
                  value: function (t, e) {
                    switch (t) {
                      case Y.X:
                        this.x = e;
                        break;
                      case Y.Y:
                        this.y = e;
                        break;
                      case Y.Z:
                        this.z = e;
                        break;
                      case Y.M:
                        this._m = e;
                        break;
                      default:
                        throw new b('Invalid ordinate index: ' + t);
                    }
                  },
                },
                {
                  key: 'setM',
                  value: function (t) {
                    this._m = t;
                  },
                },
                {
                  key: 'getOrdinate',
                  value: function (t) {
                    switch (t) {
                      case Y.X:
                        return this.x;
                      case Y.Y:
                        return this.y;
                      case Y.Z:
                        return this.getZ();
                      case Y.M:
                        return this.getM();
                    }
                    throw new b('Invalid ordinate index: ' + t);
                  },
                },
                {
                  key: 'copy',
                  value: function () {
                    return new o(this);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ' m=' + this.getM() + ')';
                  },
                },
                {
                  key: 'setCoordinate',
                  value: function (t) {
                    (this.x = t.x), (this.y = t.y), (this.z = t.getZ()), (this._m = t.getM());
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._m = null), 0 === arguments.length)) Y.constructor_.call(this), (this._m = 0);
                    else if (1 === arguments.length) {
                      if (arguments[0] instanceof o) {
                        var t = arguments[0];
                        Y.constructor_.call(this, t), (this._m = t._m);
                      } else if (arguments[0] instanceof Y) {
                        var e = arguments[0];
                        Y.constructor_.call(this, e), (this._m = this.getM());
                      }
                    } else if (4 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1],
                        i = arguments[2],
                        a = arguments[3];
                      Y.constructor_.call(this, n, r, i), (this._m = a);
                    }
                  },
                },
              ],
            ),
            o
          );
        })(Y),
        Wt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'measures',
                value: function (t) {
                  return t instanceof zt ? 0 : t instanceof Ut || t instanceof Xt ? 1 : 0;
                },
              },
              {
                key: 'dimension',
                value: function (t) {
                  return t instanceof zt ? 2 : t instanceof Ut ? 3 : t instanceof Xt ? 4 : 3;
                },
              },
              {
                key: 'create',
                value: function () {
                  if (1 === arguments.length) {
                    var t = arguments[0];
                    return e.create(t, 0);
                  }
                  if (2 === arguments.length) {
                    var n = arguments[0],
                      r = arguments[1];
                    return 2 === n
                      ? new zt()
                      : 3 === n && 0 === r
                      ? new Y()
                      : 3 === n && 1 === r
                      ? new Ut()
                      : 4 === n && 1 === r
                      ? new Xt()
                      : new Y();
                  }
                },
              },
            ]),
            e
          );
        })(),
        Ht = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'getCoordinate',
                  value: function (t) {
                    return this.get(t);
                  },
                },
                {
                  key: 'addAll',
                  value: function () {
                    if (2 === arguments.length && 'boolean' == typeof arguments[1] && ot(arguments[0], H)) {
                      for (var t = arguments[1], e = !1, n = arguments[0].iterator(); n.hasNext(); )
                        this.add(n.next(), t), (e = !0);
                      return e;
                    }
                    return p(o(a.prototype), 'addAll', this).apply(this, arguments);
                  },
                },
                {
                  key: 'clone',
                  value: function () {
                    for (var t = p(o(a.prototype), 'clone', this).call(this), e = 0; e < this.size(); e++)
                      t.add(e, this.get(e).clone());
                    return t;
                  },
                },
                {
                  key: 'toCoordinateArray',
                  value: function () {
                    if (0 === arguments.length) return this.toArray(a.coordArrayType);
                    if (1 === arguments.length) {
                      if (arguments[0]) return this.toArray(a.coordArrayType);
                      for (var t = this.size(), e = new Array(t).fill(null), n = 0; n < t; n++)
                        e[n] = this.get(t - n - 1);
                      return e;
                    }
                  },
                },
                {
                  key: 'add',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      return p(o(a.prototype), 'add', this).call(this, t);
                    }
                    if (2 === arguments.length) {
                      if (arguments[0] instanceof Array && 'boolean' == typeof arguments[1]) {
                        var e = arguments[0],
                          n = arguments[1];
                        return this.add(e, n, !0), !0;
                      }
                      if (arguments[0] instanceof Y && 'boolean' == typeof arguments[1]) {
                        var r = arguments[0];
                        if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(r)) return null;
                        p(o(a.prototype), 'add', this).call(this, r);
                      } else if (arguments[0] instanceof Object && 'boolean' == typeof arguments[1]) {
                        var i = arguments[0],
                          s = arguments[1];
                        return this.add(i, s), !0;
                      }
                    } else if (3 === arguments.length) {
                      if (
                        'boolean' == typeof arguments[2] &&
                        arguments[0] instanceof Array &&
                        'boolean' == typeof arguments[1]
                      ) {
                        var u = arguments[0],
                          l = arguments[1];
                        if (arguments[2]) for (var c = 0; c < u.length; c++) this.add(u[c], l);
                        else for (var h = u.length - 1; h >= 0; h--) this.add(u[h], l);
                        return !0;
                      }
                      if (
                        'boolean' == typeof arguments[2] &&
                        Number.isInteger(arguments[0]) &&
                        arguments[1] instanceof Y
                      ) {
                        var f = arguments[0],
                          g = arguments[1];
                        if (!arguments[2]) {
                          var y = this.size();
                          if (y > 0) {
                            if (f > 0 && this.get(f - 1).equals2D(g)) return null;
                            if (f < y && this.get(f).equals2D(g)) return null;
                          }
                        }
                        p(o(a.prototype), 'add', this).call(this, f, g);
                      }
                    } else if (4 === arguments.length) {
                      var v = arguments[0],
                        d = arguments[1],
                        m = arguments[2],
                        _ = arguments[3],
                        b = 1;
                      m > _ && (b = -1);
                      for (var x = m; x !== _; x += b) this.add(v[x], d);
                      return !0;
                    }
                  },
                },
                {
                  key: 'closeRing',
                  value: function () {
                    if (this.size() > 0) {
                      var t = this.get(0).copy();
                      this.add(t, !1);
                    }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (0 === arguments.length);
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      this.ensureCapacity(t.length), this.add(t, !0);
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      this.ensureCapacity(e.length), this.add(e, n);
                    }
                  },
                },
              ],
            ),
            a
          );
        })(vt);
      Ht.coordArrayType = new Array(0).fill(null);
      var Zt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'isRing',
                value: function (t) {
                  return !(t.length < 4 || !t[0].equals2D(t[t.length - 1]));
                },
              },
              {
                key: 'ptNotInList',
                value: function (t, n) {
                  for (var r = 0; r < t.length; r++) {
                    var i = t[r];
                    if (e.indexOf(i, n) < 0) return i;
                  }
                  return null;
                },
              },
              {
                key: 'scroll',
                value: function (t, n) {
                  var r = e.indexOf(n, t);
                  if (r < 0) return null;
                  var i = new Array(t.length).fill(null);
                  bt.arraycopy(t, r, i, 0, t.length - r),
                    bt.arraycopy(t, 0, i, t.length - r, r),
                    bt.arraycopy(i, 0, t, 0, t.length);
                },
              },
              {
                key: 'equals',
                value: function () {
                  if (2 === arguments.length) {
                    var t = arguments[0],
                      e = arguments[1];
                    if (t === e) return !0;
                    if (null === t || null === e) return !1;
                    if (t.length !== e.length) return !1;
                    for (var n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1;
                    return !0;
                  }
                  if (3 === arguments.length) {
                    var r = arguments[0],
                      i = arguments[1],
                      o = arguments[2];
                    if (r === i) return !0;
                    if (null === r || null === i) return !1;
                    if (r.length !== i.length) return !1;
                    for (var a = 0; a < r.length; a++) if (0 !== o.compare(r[a], i[a])) return !1;
                    return !0;
                  }
                },
              },
              {
                key: 'intersection',
                value: function (t, e) {
                  for (var n = new Ht(), r = 0; r < t.length; r++) e.intersects(t[r]) && n.add(t[r], !0);
                  return n.toCoordinateArray();
                },
              },
              {
                key: 'measures',
                value: function (t) {
                  if (null === t || 0 === t.length) return 0;
                  var e,
                    n = 0,
                    r = d(t);
                  try {
                    for (r.s(); !(e = r.n()).done; ) {
                      var i = e.value;
                      n = Math.max(n, Wt.measures(i));
                    }
                  } catch (t) {
                    r.e(t);
                  } finally {
                    r.f();
                  }
                  return n;
                },
              },
              {
                key: 'hasRepeatedPoints',
                value: function (t) {
                  for (var e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0;
                  return !1;
                },
              },
              {
                key: 'removeRepeatedPoints',
                value: function (t) {
                  return e.hasRepeatedPoints(t) ? new Ht(t, !1).toCoordinateArray() : t;
                },
              },
              {
                key: 'reverse',
                value: function (t) {
                  for (var e = t.length - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) {
                    var i = t[r];
                    (t[r] = t[e - r]), (t[e - r] = i);
                  }
                },
              },
              {
                key: 'removeNull',
                value: function (t) {
                  for (var e = 0, n = 0; n < t.length; n++) null !== t[n] && e++;
                  var r = new Array(e).fill(null);
                  if (0 === e) return r;
                  for (var i = 0, o = 0; o < t.length; o++) null !== t[o] && (r[i++] = t[o]);
                  return r;
                },
              },
              {
                key: 'copyDeep',
                value: function () {
                  if (1 === arguments.length) {
                    for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++)
                      e[n] = t[n].copy();
                    return e;
                  }
                  if (5 === arguments.length)
                    for (
                      var r = arguments[0],
                        i = arguments[1],
                        o = arguments[2],
                        a = arguments[3],
                        s = arguments[4],
                        u = 0;
                      u < s;
                      u++
                    )
                      o[a + u] = r[i + u].copy();
                },
              },
              {
                key: 'isEqualReversed',
                value: function (t, e) {
                  for (var n = 0; n < t.length; n++) {
                    var r = t[n],
                      i = e[t.length - n - 1];
                    if (0 !== r.compareTo(i)) return !1;
                  }
                  return !0;
                },
              },
              {
                key: 'envelope',
                value: function (t) {
                  for (var e = new U(), n = 0; n < t.length; n++) e.expandToInclude(t[n]);
                  return e;
                },
              },
              {
                key: 'toCoordinateArray',
                value: function (t) {
                  return t.toArray(e.coordArrayType);
                },
              },
              {
                key: 'dimension',
                value: function (t) {
                  if (null === t || 0 === t.length) return 3;
                  var e,
                    n = 0,
                    r = d(t);
                  try {
                    for (r.s(); !(e = r.n()).done; ) {
                      var i = e.value;
                      n = Math.max(n, Wt.dimension(i));
                    }
                  } catch (t) {
                    r.e(t);
                  } finally {
                    r.f();
                  }
                  return n;
                },
              },
              {
                key: 'atLeastNCoordinatesOrNothing',
                value: function (t, e) {
                  return e.length >= t ? e : [];
                },
              },
              {
                key: 'indexOf',
                value: function (t, e) {
                  for (var n = 0; n < e.length; n++) if (t.equals(e[n])) return n;
                  return -1;
                },
              },
              {
                key: 'increasingDirection',
                value: function (t) {
                  for (var e = 0; e < Math.trunc(t.length / 2); e++) {
                    var n = t.length - 1 - e,
                      r = t[e].compareTo(t[n]);
                    if (0 !== r) return r;
                  }
                  return 1;
                },
              },
              {
                key: 'compare',
                value: function (t, e) {
                  for (var n = 0; n < t.length && n < e.length; ) {
                    var r = t[n].compareTo(e[n]);
                    if (0 !== r) return r;
                    n++;
                  }
                  return n < e.length ? -1 : n < t.length ? 1 : 0;
                },
              },
              {
                key: 'minCoordinate',
                value: function (t) {
                  for (var e = null, n = 0; n < t.length; n++) (null === e || e.compareTo(t[n]) > 0) && (e = t[n]);
                  return e;
                },
              },
              {
                key: 'extract',
                value: function (t, e, n) {
                  e = xt.clamp(e, 0, t.length);
                  var r = (n = xt.clamp(n, -1, t.length)) - e + 1;
                  n < 0 && (r = 0), e >= t.length && (r = 0), n < e && (r = 0);
                  var i = new Array(r).fill(null);
                  if (0 === r) return i;
                  for (var o = 0, a = e; a <= n; a++) i[o++] = t[a];
                  return i;
                },
              },
            ]),
            e
          );
        })(),
        Jt = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              {
                key: 'compare',
                value: function (t, e) {
                  var n = t,
                    r = e;
                  return Zt.compare(n, r);
                },
              },
              {
                key: 'interfaces_',
                get: function () {
                  return [D];
                },
              },
            ]),
            e
          );
        })(),
        $t = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              {
                key: 'compare',
                value: function (t, e) {
                  var n = t,
                    r = e;
                  if (n.length < r.length) return -1;
                  if (n.length > r.length) return 1;
                  if (0 === n.length) return 0;
                  var i = Zt.compare(n, r);
                  return Zt.isEqualReversed(n, r) ? 0 : i;
                },
              },
              {
                key: 'OLDcompare',
                value: function (t, e) {
                  var n = t,
                    r = e;
                  if (n.length < r.length) return -1;
                  if (n.length > r.length) return 1;
                  if (0 === n.length) return 0;
                  for (
                    var i = Zt.increasingDirection(n),
                      o = Zt.increasingDirection(r),
                      a = i > 0 ? 0 : n.length - 1,
                      s = o > 0 ? 0 : n.length - 1,
                      u = 0;
                    u < n.length;
                    u++
                  ) {
                    var l = n[a].compareTo(r[s]);
                    if (0 !== l) return l;
                    (a += i), (s += o);
                  }
                  return 0;
                },
              },
              {
                key: 'interfaces_',
                get: function () {
                  return [D];
                },
              },
            ]),
            e
          );
        })();
      (Zt.ForwardComparator = Jt), (Zt.BidirectionalComparator = $t), (Zt.coordArrayType = new Array(0).fill(null));
      var Qt = (function () {
          function e(n) {
            t(this, e), (this.str = n);
          }
          return (
            r(e, [
              {
                key: 'append',
                value: function (t) {
                  this.str += t;
                },
              },
              {
                key: 'setCharAt',
                value: function (t, e) {
                  this.str = this.str.substr(0, t) + e + this.str.substr(t + 1);
                },
              },
              {
                key: 'toString',
                value: function () {
                  return this.str;
                },
              },
            ]),
            e
          );
        })(),
        Kt = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getM',
                  value: function (t) {
                    return this.hasM() ? this._coordinates[t].getM() : A.NaN;
                  },
                },
                {
                  key: 'setOrdinate',
                  value: function (t, e, n) {
                    switch (e) {
                      case ht.X:
                        this._coordinates[t].x = n;
                        break;
                      case ht.Y:
                        this._coordinates[t].y = n;
                        break;
                      default:
                        this._coordinates[t].setOrdinate(e, n);
                    }
                  },
                },
                {
                  key: 'getZ',
                  value: function (t) {
                    return this.hasZ() ? this._coordinates[t].getZ() : A.NaN;
                  },
                },
                {
                  key: 'size',
                  value: function () {
                    return this._coordinates.length;
                  },
                },
                {
                  key: 'getOrdinate',
                  value: function (t, e) {
                    switch (e) {
                      case ht.X:
                        return this._coordinates[t].x;
                      case ht.Y:
                        return this._coordinates[t].y;
                      default:
                        return this._coordinates[t].getOrdinate(e);
                    }
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      return this._coordinates[t];
                    }
                    if (2 === arguments.length) {
                      var e = arguments[0];
                      arguments[1].setCoordinate(this._coordinates[e]);
                    }
                  },
                },
                {
                  key: 'getCoordinateCopy',
                  value: function (t) {
                    var e = this.createCoordinate();
                    return e.setCoordinate(this._coordinates[t]), e;
                  },
                },
                {
                  key: 'createCoordinate',
                  value: function () {
                    return Wt.create(this.getDimension(), this.getMeasures());
                  },
                },
                {
                  key: 'getDimension',
                  value: function () {
                    return this._dimension;
                  },
                },
                {
                  key: 'getX',
                  value: function (t) {
                    return this._coordinates[t].x;
                  },
                },
                {
                  key: 'getMeasures',
                  value: function () {
                    return this._measures;
                  },
                },
                {
                  key: 'expandEnvelope',
                  value: function (t) {
                    for (var e = 0; e < this._coordinates.length; e++) t.expandToInclude(this._coordinates[e]);
                    return t;
                  },
                },
                {
                  key: 'copy',
                  value: function () {
                    for (var t = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++) {
                      var r = this.createCoordinate();
                      r.setCoordinate(this._coordinates[n]), (t[n] = r);
                    }
                    return new e(t, this._dimension, this._measures);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    if (this._coordinates.length > 0) {
                      var t = new Qt(17 * this._coordinates.length);
                      t.append('('), t.append(this._coordinates[0]);
                      for (var e = 1; e < this._coordinates.length; e++) t.append(', '), t.append(this._coordinates[e]);
                      return t.append(')'), t.toString();
                    }
                    return '()';
                  },
                },
                {
                  key: 'getY',
                  value: function (t) {
                    return this._coordinates[t].y;
                  },
                },
                {
                  key: 'toCoordinateArray',
                  value: function () {
                    return this._coordinates;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [ht, k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._dimension = 3), (this._measures = 0), (this._coordinates = null), 1 === arguments.length)
                    ) {
                      if (arguments[0] instanceof Array) {
                        var t = arguments[0];
                        e.constructor_.call(this, t, Zt.dimension(t), Zt.measures(t));
                      } else if (Number.isInteger(arguments[0])) {
                        var n = arguments[0];
                        this._coordinates = new Array(n).fill(null);
                        for (var r = 0; r < n; r++) this._coordinates[r] = new Y();
                      } else if (ot(arguments[0], ht)) {
                        var i = arguments[0];
                        if (null === i) return (this._coordinates = new Array(0).fill(null)), null;
                        (this._dimension = i.getDimension()),
                          (this._measures = i.getMeasures()),
                          (this._coordinates = new Array(i.size()).fill(null));
                        for (var o = 0; o < this._coordinates.length; o++)
                          this._coordinates[o] = i.getCoordinateCopy(o);
                      }
                    } else if (2 === arguments.length) {
                      if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                        var a = arguments[0],
                          s = arguments[1];
                        e.constructor_.call(this, a, s, Zt.measures(a));
                      } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                        var u = arguments[0],
                          l = arguments[1];
                        (this._coordinates = new Array(u).fill(null)), (this._dimension = l);
                        for (var c = 0; c < u; c++) this._coordinates[c] = Wt.create(l);
                      }
                    } else if (3 === arguments.length)
                      if (
                        Number.isInteger(arguments[2]) &&
                        arguments[0] instanceof Array &&
                        Number.isInteger(arguments[1])
                      ) {
                        var h = arguments[0],
                          f = arguments[1],
                          p = arguments[2];
                        (this._dimension = f),
                          (this._measures = p),
                          (this._coordinates = null === h ? new Array(0).fill(null) : h);
                      } else if (
                        Number.isInteger(arguments[2]) &&
                        Number.isInteger(arguments[0]) &&
                        Number.isInteger(arguments[1])
                      ) {
                        var g = arguments[0],
                          y = arguments[1],
                          v = arguments[2];
                        (this._coordinates = new Array(g).fill(null)), (this._dimension = y), (this._measures = v);
                        for (var d = 0; d < g; d++) this._coordinates[d] = this.createCoordinate();
                      }
                  },
                },
              ],
            ),
            e
          );
        })(),
        te = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(
              e,
              [
                {
                  key: 'readResolve',
                  value: function () {
                    return e.instance();
                  },
                },
                {
                  key: 'create',
                  value: function () {
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof Array) return new Kt(arguments[0]);
                      if (ot(arguments[0], ht)) return new Kt(arguments[0]);
                    } else {
                      if (2 === arguments.length) {
                        var t = arguments[1];
                        return t > 3 && (t = 3), t < 2 && (t = 2), new Kt(arguments[0], t);
                      }
                      if (3 === arguments.length) {
                        var e = arguments[2],
                          n = arguments[1] - e;
                        return e > 1 && (e = 1), n > 3 && (n = 3), n < 2 && (n = 2), new Kt(arguments[0], n + e, e);
                      }
                    }
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [wt, k];
                  },
                },
              ],
              [
                {
                  key: 'instance',
                  value: function () {
                    return e.instanceObject;
                  },
                },
              ],
            ),
            e
          );
        })();
      te.instanceObject = new te();
      var ee = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'copyInternal',
                  value: function () {
                    for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++)
                      t[e] = this._geometries[e].copy();
                    return new a(t, this._factory);
                  },
                },
                {
                  key: 'equalsExact',
                  value: function () {
                    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof X) {
                      var t = arguments[0],
                        e = arguments[1];
                      return !!this.isEquivalentClass(t) && p(o(a.prototype), 'equalsExact', this).call(this, t, e);
                    }
                    return p(o(a.prototype), 'equalsExact', this).apply(this, arguments);
                  },
                },
                {
                  key: 'getBoundaryDimension',
                  value: function () {
                    return 1;
                  },
                },
                {
                  key: 'getTypeCode',
                  value: function () {
                    return X.TYPECODE_MULTIPOLYGON;
                  },
                },
                {
                  key: 'getDimension',
                  value: function () {
                    return 2;
                  },
                },
                {
                  key: 'getBoundary',
                  value: function () {
                    if (this.isEmpty()) return this.getFactory().createMultiLineString();
                    for (var t = new vt(), e = 0; e < this._geometries.length; e++)
                      for (var n = this._geometries[e].getBoundary(), r = 0; r < n.getNumGeometries(); r++)
                        t.add(n.getGeometryN(r));
                    var i = new Array(t.size()).fill(null);
                    return this.getFactory().createMultiLineString(t.toArray(i));
                  },
                },
                {
                  key: 'getGeometryType',
                  value: function () {
                    return X.TYPENAME_MULTIPOLYGON;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Dt];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    var t = arguments[0],
                      e = arguments[1];
                    Vt.constructor_.call(this, t, e);
                  },
                },
              ],
            ),
            a
          );
        })(Vt),
        ne = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'get', value: function () {} },
              { key: 'put', value: function () {} },
              { key: 'size', value: function () {} },
              { key: 'values', value: function () {} },
              { key: 'entrySet', value: function () {} },
            ]),
            e
          );
        })(),
        re = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), ((e = n.call(this)).map = new Map()), e;
          }
          return (
            r(o, [
              {
                key: 'get',
                value: function (t) {
                  return this.map.get(t) || null;
                },
              },
              {
                key: 'put',
                value: function (t, e) {
                  return this.map.set(t, e), e;
                },
              },
              {
                key: 'values',
                value: function () {
                  for (var t = new vt(), e = this.map.values(), n = e.next(); !n.done; ) t.add(n.value), (n = e.next());
                  return t;
                },
              },
              {
                key: 'entrySet',
                value: function () {
                  var t = new Q();
                  return (
                    this.map.entries().forEach(function (e) {
                      return t.add(e);
                    }),
                    t
                  );
                },
              },
              {
                key: 'size',
                value: function () {
                  return this.map.size();
                },
              },
            ]),
            o
          );
        })(ne),
        ie = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'equals',
                  value: function (t) {
                    if (!(t instanceof e)) return !1;
                    var n = t;
                    return this._modelType === n._modelType && this._scale === n._scale;
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t,
                      n = this.getMaximumSignificantDigits(),
                      r = e.getMaximumSignificantDigits();
                    return st.compare(n, r);
                  },
                },
                {
                  key: 'getScale',
                  value: function () {
                    return this._scale;
                  },
                },
                {
                  key: 'isFloating',
                  value: function () {
                    return this._modelType === e.FLOATING || this._modelType === e.FLOATING_SINGLE;
                  },
                },
                {
                  key: 'getType',
                  value: function () {
                    return this._modelType;
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    var t = 'UNKNOWN';
                    return (
                      this._modelType === e.FLOATING
                        ? (t = 'Floating')
                        : this._modelType === e.FLOATING_SINGLE
                        ? (t = 'Floating-Single')
                        : this._modelType === e.FIXED && (t = 'Fixed (Scale=' + this.getScale() + ')'),
                      t
                    );
                  },
                },
                {
                  key: 'makePrecise',
                  value: function () {
                    if ('number' == typeof arguments[0]) {
                      var t = arguments[0];
                      return A.isNaN(t) || this._modelType === e.FLOATING_SINGLE
                        ? t
                        : this._modelType === e.FIXED
                        ? Math.round(t * this._scale) / this._scale
                        : t;
                    }
                    if (arguments[0] instanceof Y) {
                      var n = arguments[0];
                      if (this._modelType === e.FLOATING) return null;
                      (n.x = this.makePrecise(n.x)), (n.y = this.makePrecise(n.y));
                    }
                  },
                },
                {
                  key: 'getMaximumSignificantDigits',
                  value: function () {
                    var t = 16;
                    return (
                      this._modelType === e.FLOATING
                        ? (t = 16)
                        : this._modelType === e.FLOATING_SINGLE
                        ? (t = 6)
                        : this._modelType === e.FIXED &&
                          (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))),
                      t
                    );
                  },
                },
                {
                  key: 'setScale',
                  value: function (t) {
                    this._scale = Math.abs(t);
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [k, E];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._modelType = null), (this._scale = null), 0 === arguments.length))
                      this._modelType = e.FLOATING;
                    else if (1 === arguments.length)
                      if (arguments[0] instanceof oe) {
                        var t = arguments[0];
                        (this._modelType = t), t === e.FIXED && this.setScale(1);
                      } else if ('number' == typeof arguments[0]) {
                        var n = arguments[0];
                        (this._modelType = e.FIXED), this.setScale(n);
                      } else if (arguments[0] instanceof e) {
                        var r = arguments[0];
                        (this._modelType = r._modelType), (this._scale = r._scale);
                      }
                  },
                },
                {
                  key: 'mostPrecise',
                  value: function (t, e) {
                    return t.compareTo(e) >= 0 ? t : e;
                  },
                },
              ],
            ),
            e
          );
        })(),
        oe = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'readResolve',
                  value: function () {
                    return e.nameToTypeMap.get(this._name);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return this._name;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    this._name = null;
                    var t = arguments[0];
                    (this._name = t), e.nameToTypeMap.put(t, this);
                  },
                },
              ],
            ),
            e
          );
        })();
      (oe.nameToTypeMap = new re()),
        (ie.Type = oe),
        (ie.FIXED = new oe('FIXED')),
        (ie.FLOATING = new oe('FLOATING')),
        (ie.FLOATING_SINGLE = new oe('FLOATING SINGLE')),
        (ie.maximumPreciseValue = 9007199254740992);
      var ae = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'copyInternal',
                  value: function () {
                    for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++)
                      t[e] = this._geometries[e].copy();
                    return new a(t, this._factory);
                  },
                },
                {
                  key: 'equalsExact',
                  value: function () {
                    if (2 === arguments.length && 'number' == typeof arguments[1] && arguments[0] instanceof X) {
                      var t = arguments[0],
                        e = arguments[1];
                      return !!this.isEquivalentClass(t) && p(o(a.prototype), 'equalsExact', this).call(this, t, e);
                    }
                    return p(o(a.prototype), 'equalsExact', this).apply(this, arguments);
                  },
                },
                {
                  key: 'getBoundaryDimension',
                  value: function () {
                    return this.isClosed() ? Nt.FALSE : 0;
                  },
                },
                {
                  key: 'isClosed',
                  value: function () {
                    if (this.isEmpty()) return !1;
                    for (var t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1;
                    return !0;
                  },
                },
                {
                  key: 'getTypeCode',
                  value: function () {
                    return X.TYPECODE_MULTILINESTRING;
                  },
                },
                {
                  key: 'getDimension',
                  value: function () {
                    return 1;
                  },
                },
                {
                  key: 'getBoundary',
                  value: function () {
                    throw new J();
                  },
                },
                {
                  key: 'getGeometryType',
                  value: function () {
                    return X.TYPENAME_MULTILINESTRING;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [It];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    var t = arguments[0],
                      e = arguments[1];
                    Vt.constructor_.call(this, t, e);
                  },
                },
              ],
            ),
            a
          );
        })(Vt),
        se = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'createEmpty',
                  value: function (t) {
                    switch (t) {
                      case -1:
                        return this.createGeometryCollection();
                      case 0:
                        return this.createPoint();
                      case 1:
                        return this.createLineString();
                      case 2:
                        return this.createPolygon();
                      default:
                        throw new b('Invalid dimension: ' + t);
                    }
                  },
                },
                {
                  key: 'toGeometry',
                  value: function (t) {
                    return t.isNull()
                      ? this.createPoint()
                      : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY()
                      ? this.createPoint(new Y(t.getMinX(), t.getMinY()))
                      : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY()
                      ? this.createLineString([new Y(t.getMinX(), t.getMinY()), new Y(t.getMaxX(), t.getMaxY())])
                      : this.createPolygon(
                          this.createLinearRing([
                            new Y(t.getMinX(), t.getMinY()),
                            new Y(t.getMinX(), t.getMaxY()),
                            new Y(t.getMaxX(), t.getMaxY()),
                            new Y(t.getMaxX(), t.getMinY()),
                            new Y(t.getMinX(), t.getMinY()),
                          ]),
                          null,
                        );
                  },
                },
                {
                  key: 'createLineString',
                  value: function () {
                    if (0 === arguments.length)
                      return this.createLineString(this.getCoordinateSequenceFactory().create([]));
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof Array) {
                        var t = arguments[0];
                        return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
                      }
                      if (ot(arguments[0], ht)) return new Lt(arguments[0], this);
                    }
                  },
                },
                {
                  key: 'createMultiLineString',
                  value: function () {
                    return 0 === arguments.length
                      ? new ae(null, this)
                      : 1 === arguments.length
                      ? new ae(arguments[0], this)
                      : void 0;
                  },
                },
                {
                  key: 'buildGeometry',
                  value: function (t) {
                    for (var n = null, r = !1, i = !1, o = t.iterator(); o.hasNext(); ) {
                      var a = o.next(),
                        s = a.getTypeCode();
                      null === n && (n = s), s !== n && (r = !0), a instanceof Vt && (i = !0);
                    }
                    if (null === n) return this.createGeometryCollection();
                    if (r || i) return this.createGeometryCollection(e.toGeometryArray(t));
                    var u = t.iterator().next();
                    if (t.size() > 1) {
                      if (u instanceof jt) return this.createMultiPolygon(e.toPolygonArray(t));
                      if (u instanceof Lt) return this.createMultiLineString(e.toLineStringArray(t));
                      if (u instanceof Ct) return this.createMultiPoint(e.toPointArray(t));
                      B.shouldNeverReachHere('Unhandled geometry type: ' + u.getGeometryType());
                    }
                    return u;
                  },
                },
                {
                  key: 'createMultiPointFromCoords',
                  value: function (t) {
                    return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
                  },
                },
                {
                  key: 'createPoint',
                  value: function () {
                    if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof Y) {
                        var t = arguments[0];
                        return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null);
                      }
                      if (ot(arguments[0], ht)) return new Ct(arguments[0], this);
                    }
                  },
                },
                {
                  key: 'getCoordinateSequenceFactory',
                  value: function () {
                    return this._coordinateSequenceFactory;
                  },
                },
                {
                  key: 'createPolygon',
                  value: function () {
                    if (0 === arguments.length) return this.createPolygon(null, null);
                    if (1 === arguments.length) {
                      if (ot(arguments[0], ht)) {
                        var t = arguments[0];
                        return this.createPolygon(this.createLinearRing(t));
                      }
                      if (arguments[0] instanceof Array) {
                        var e = arguments[0];
                        return this.createPolygon(this.createLinearRing(e));
                      }
                      if (arguments[0] instanceof Yt) {
                        var n = arguments[0];
                        return this.createPolygon(n, null);
                      }
                    } else if (2 === arguments.length) return new jt(arguments[0], arguments[1], this);
                  },
                },
                {
                  key: 'getSRID',
                  value: function () {
                    return this._SRID;
                  },
                },
                {
                  key: 'createGeometryCollection',
                  value: function () {
                    return 0 === arguments.length
                      ? new Vt(null, this)
                      : 1 === arguments.length
                      ? new Vt(arguments[0], this)
                      : void 0;
                  },
                },
                {
                  key: 'getPrecisionModel',
                  value: function () {
                    return this._precisionModel;
                  },
                },
                {
                  key: 'createLinearRing',
                  value: function () {
                    if (0 === arguments.length)
                      return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof Array) {
                        var t = arguments[0];
                        return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null);
                      }
                      if (ot(arguments[0], ht)) return new Yt(arguments[0], this);
                    }
                  },
                },
                {
                  key: 'createMultiPolygon',
                  value: function () {
                    return 0 === arguments.length
                      ? new ee(null, this)
                      : 1 === arguments.length
                      ? new ee(arguments[0], this)
                      : void 0;
                  },
                },
                {
                  key: 'createMultiPoint',
                  value: function () {
                    if (0 === arguments.length) return new Gt(null, this);
                    if (1 === arguments.length) {
                      if (arguments[0] instanceof Array) return new Gt(arguments[0], this);
                      if (ot(arguments[0], ht)) {
                        var t = arguments[0];
                        if (null === t) return this.createMultiPoint(new Array(0).fill(null));
                        for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) {
                          var r = this.getCoordinateSequenceFactory().create(1, t.getDimension(), t.getMeasures());
                          Pt.copy(t, n, r, 0, 1), (e[n] = this.createPoint(r));
                        }
                        return this.createMultiPoint(e);
                      }
                    }
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._precisionModel = null),
                      (this._coordinateSequenceFactory = null),
                      (this._SRID = null),
                      0 === arguments.length)
                    )
                      e.constructor_.call(this, new ie(), 0);
                    else if (1 === arguments.length) {
                      if (ot(arguments[0], wt)) {
                        var t = arguments[0];
                        e.constructor_.call(this, new ie(), 0, t);
                      } else if (arguments[0] instanceof ie) {
                        var n = arguments[0];
                        e.constructor_.call(this, n, 0, e.getDefaultCoordinateSequenceFactory());
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      e.constructor_.call(this, r, i, e.getDefaultCoordinateSequenceFactory());
                    } else if (3 === arguments.length) {
                      var o = arguments[0],
                        a = arguments[1],
                        s = arguments[2];
                      (this._precisionModel = o), (this._coordinateSequenceFactory = s), (this._SRID = a);
                    }
                  },
                },
                {
                  key: 'toMultiPolygonArray',
                  value: function (t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e);
                  },
                },
                {
                  key: 'toGeometryArray',
                  value: function (t) {
                    if (null === t) return null;
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e);
                  },
                },
                {
                  key: 'getDefaultCoordinateSequenceFactory',
                  value: function () {
                    return te.instance();
                  },
                },
                {
                  key: 'toMultiLineStringArray',
                  value: function (t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e);
                  },
                },
                {
                  key: 'toLineStringArray',
                  value: function (t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e);
                  },
                },
                {
                  key: 'toMultiPointArray',
                  value: function (t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e);
                  },
                },
                {
                  key: 'toLinearRingArray',
                  value: function (t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e);
                  },
                },
                {
                  key: 'toPointArray',
                  value: function (t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e);
                  },
                },
                {
                  key: 'toPolygonArray',
                  value: function (t) {
                    var e = new Array(t.size()).fill(null);
                    return t.toArray(e);
                  },
                },
                {
                  key: 'createPointFromInternalCoord',
                  value: function (t, e) {
                    return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t);
                  },
                },
              ],
            ),
            e
          );
        })(),
        ue = 'XY',
        le = 'XYZ',
        ce = 'XYM',
        he = 'XYZM',
        fe = {
          POINT: 'Point',
          LINE_STRING: 'LineString',
          LINEAR_RING: 'LinearRing',
          POLYGON: 'Polygon',
          MULTI_POINT: 'MultiPoint',
          MULTI_LINE_STRING: 'MultiLineString',
          MULTI_POLYGON: 'MultiPolygon',
          GEOMETRY_COLLECTION: 'GeometryCollection',
          CIRCLE: 'Circle',
        },
        pe = 'EMPTY',
        ge = 1,
        ye = 2,
        ve = 3,
        de = 4,
        me = 5,
        _e = 6;
      for (var be in fe) fe[be].toUpperCase();
      var xe = (function () {
          function e(n) {
            t(this, e), (this.wkt = n), (this.index_ = -1);
          }
          return (
            r(e, [
              {
                key: 'isAlpha_',
                value: function (t) {
                  return (t >= 'a' && t <= 'z') || (t >= 'A' && t <= 'Z');
                },
              },
              {
                key: 'isNumeric_',
                value: function (t, e) {
                  return (t >= '0' && t <= '9') || ('.' == t && !(void 0 !== e && e));
                },
              },
              {
                key: 'isWhiteSpace_',
                value: function (t) {
                  return ' ' == t || '\t' == t || '\r' == t || '\n' == t;
                },
              },
              {
                key: 'nextChar_',
                value: function () {
                  return this.wkt.charAt(++this.index_);
                },
              },
              {
                key: 'nextToken',
                value: function () {
                  var t,
                    e = this.nextChar_(),
                    n = this.index_,
                    r = e;
                  if ('(' == e) t = ye;
                  else if (',' == e) t = me;
                  else if (')' == e) t = ve;
                  else if (this.isNumeric_(e) || '-' == e) (t = de), (r = this.readNumber_());
                  else if (this.isAlpha_(e)) (t = ge), (r = this.readText_());
                  else {
                    if (this.isWhiteSpace_(e)) return this.nextToken();
                    if ('' !== e) throw new Error('Unexpected character: ' + e);
                    t = _e;
                  }
                  return { position: n, value: r, type: t };
                },
              },
              {
                key: 'readNumber_',
                value: function () {
                  var t,
                    e = this.index_,
                    n = !1,
                    r = !1;
                  do {
                    '.' == t ? (n = !0) : ('e' != t && 'E' != t) || (r = !0), (t = this.nextChar_());
                  } while (this.isNumeric_(t, n) || (!r && ('e' == t || 'E' == t)) || (r && ('-' == t || '+' == t)));
                  return parseFloat(this.wkt.substring(e, this.index_--));
                },
              },
              {
                key: 'readText_',
                value: function () {
                  var t,
                    e = this.index_;
                  do {
                    t = this.nextChar_();
                  } while (this.isAlpha_(t));
                  return this.wkt.substring(e, this.index_--).toUpperCase();
                },
              },
            ]),
            e
          );
        })(),
        Ee = (function () {
          function e(n, r) {
            t(this, e), (this.lexer_ = n), this.token_, (this.layout_ = ue), (this.factory = r);
          }
          return (
            r(e, [
              {
                key: 'consume_',
                value: function () {
                  this.token_ = this.lexer_.nextToken();
                },
              },
              {
                key: 'isTokenType',
                value: function (t) {
                  return this.token_.type == t;
                },
              },
              {
                key: 'match',
                value: function (t) {
                  var e = this.isTokenType(t);
                  return e && this.consume_(), e;
                },
              },
              {
                key: 'parse',
                value: function () {
                  return this.consume_(), this.parseGeometry_();
                },
              },
              {
                key: 'parseGeometryLayout_',
                value: function () {
                  var t = ue,
                    e = this.token_;
                  if (this.isTokenType(ge)) {
                    var n = e.value;
                    'Z' === n ? (t = le) : 'M' === n ? (t = ce) : 'ZM' === n && (t = he), t !== ue && this.consume_();
                  }
                  return t;
                },
              },
              {
                key: 'parseGeometryCollectionText_',
                value: function () {
                  if (this.match(ye)) {
                    var t = [];
                    do {
                      t.push(this.parseGeometry_());
                    } while (this.match(me));
                    if (this.match(ve)) return t;
                  } else if (this.isEmptyGeometry_()) return [];
                  throw new Error(this.formatErrorMessage_());
                },
              },
              {
                key: 'parsePointText_',
                value: function () {
                  if (this.match(ye)) {
                    var t = this.parsePoint_();
                    if (this.match(ve)) return t;
                  } else if (this.isEmptyGeometry_()) return null;
                  throw new Error(this.formatErrorMessage_());
                },
              },
              {
                key: 'parseLineStringText_',
                value: function () {
                  if (this.match(ye)) {
                    var t = this.parsePointList_();
                    if (this.match(ve)) return t;
                  } else if (this.isEmptyGeometry_()) return [];
                  throw new Error(this.formatErrorMessage_());
                },
              },
              {
                key: 'parsePolygonText_',
                value: function () {
                  if (this.match(ye)) {
                    var t = this.parseLineStringTextList_();
                    if (this.match(ve)) return t;
                  } else if (this.isEmptyGeometry_()) return [];
                  throw new Error(this.formatErrorMessage_());
                },
              },
              {
                key: 'parseMultiPointText_',
                value: function () {
                  var t;
                  if (this.match(ye)) {
                    if (
                      ((t = this.token_.type == ye ? this.parsePointTextList_() : this.parsePointList_()),
                      this.match(ve))
                    )
                      return t;
                  } else if (this.isEmptyGeometry_()) return [];
                  throw new Error(this.formatErrorMessage_());
                },
              },
              {
                key: 'parseMultiLineStringText_',
                value: function () {
                  if (this.match(ye)) {
                    var t = this.parseLineStringTextList_();
                    if (this.match(ve)) return t;
                  } else if (this.isEmptyGeometry_()) return [];
                  throw new Error(this.formatErrorMessage_());
                },
              },
              {
                key: 'parseMultiPolygonText_',
                value: function () {
                  if (this.match(ye)) {
                    var t = this.parsePolygonTextList_();
                    if (this.match(ve)) return t;
                  } else if (this.isEmptyGeometry_()) return [];
                  throw new Error(this.formatErrorMessage_());
                },
              },
              {
                key: 'parsePoint_',
                value: function () {
                  for (var t = [], e = this.layout_.length, n = 0; n < e; ++n) {
                    var r = this.token_;
                    if (!this.match(de)) break;
                    t.push(r.value);
                  }
                  if (t.length == e) return t;
                  throw new Error(this.formatErrorMessage_());
                },
              },
              {
                key: 'parsePointList_',
                value: function () {
                  for (var t = [this.parsePoint_()]; this.match(me); ) t.push(this.parsePoint_());
                  return t;
                },
              },
              {
                key: 'parsePointTextList_',
                value: function () {
                  for (var t = [this.parsePointText_()]; this.match(me); ) t.push(this.parsePointText_());
                  return t;
                },
              },
              {
                key: 'parseLineStringTextList_',
                value: function () {
                  for (var t = [this.parseLineStringText_()]; this.match(me); ) t.push(this.parseLineStringText_());
                  return t;
                },
              },
              {
                key: 'parsePolygonTextList_',
                value: function () {
                  for (var t = [this.parsePolygonText_()]; this.match(me); ) t.push(this.parsePolygonText_());
                  return t;
                },
              },
              {
                key: 'isEmptyGeometry_',
                value: function () {
                  var t = this.isTokenType(ge) && this.token_.value == pe;
                  return t && this.consume_(), t;
                },
              },
              {
                key: 'formatErrorMessage_',
                value: function () {
                  return (
                    'Unexpected `' +
                    this.token_.value +
                    '` at position ' +
                    this.token_.position +
                    ' in `' +
                    this.lexer_.wkt +
                    '`'
                  );
                },
              },
              {
                key: 'parseGeometry_',
                value: function () {
                  var t = this.factory,
                    e = function (t) {
                      return u(Y, g(t));
                    },
                    n = function (n) {
                      var r = n.map(function (n) {
                        return t.createLinearRing(n.map(e));
                      });
                      return r.length > 1 ? t.createPolygon(r[0], r.slice(1)) : t.createPolygon(r[0]);
                    },
                    r = this.token_;
                  if (this.match(ge)) {
                    var i = r.value;
                    if (((this.layout_ = this.parseGeometryLayout_()), 'GEOMETRYCOLLECTION' == i)) {
                      var o = this.parseGeometryCollectionText_();
                      return t.createGeometryCollection(o);
                    }
                    switch (i) {
                      case 'POINT':
                        var a = this.parsePointText_();
                        return a ? t.createPoint(u(Y, g(a))) : t.createPoint();
                      case 'LINESTRING':
                        var s = this.parseLineStringText_().map(e);
                        return t.createLineString(s);
                      case 'LINEARRING':
                        var l = this.parseLineStringText_().map(e);
                        return t.createLinearRing(l);
                      case 'POLYGON':
                        var c = this.parsePolygonText_();
                        return c && 0 !== c.length ? n(c) : t.createPolygon();
                      case 'MULTIPOINT':
                        var h = this.parseMultiPointText_();
                        if (!h || 0 === h.length) return t.createMultiPoint();
                        var f = h.map(e).map(function (e) {
                          return t.createPoint(e);
                        });
                        return t.createMultiPoint(f);
                      case 'MULTILINESTRING':
                        var p = this.parseMultiLineStringText_().map(function (n) {
                          return t.createLineString(n.map(e));
                        });
                        return t.createMultiLineString(p);
                      case 'MULTIPOLYGON':
                        var y = this.parseMultiPolygonText_();
                        if (!y || 0 === y.length) return t.createMultiPolygon();
                        var v = y.map(n);
                        return t.createMultiPolygon(v);
                      default:
                        throw new Error('Invalid geometry type: ' + i);
                    }
                  }
                  throw new Error(this.formatErrorMessage_());
                },
              },
            ]),
            e
          );
        })();
      function we(t) {
        if (t.isEmpty()) return '';
        var e = t.getCoordinate(),
          n = [e.x, e.y];
        return (
          void 0 === e.z || Number.isNaN(e.z) || n.push(e.z),
          void 0 === e.m || Number.isNaN(e.m) || n.push(e.m),
          n.join(' ')
        );
      }
      function ke(t) {
        for (
          var e = t.getCoordinates().map(function (t) {
              var e = [t.x, t.y];
              return (
                void 0 === t.z || Number.isNaN(t.z) || e.push(t.z),
                void 0 === t.m || Number.isNaN(t.m) || e.push(t.m),
                e
              );
            }),
            n = [],
            r = 0,
            i = e.length;
          r < i;
          ++r
        )
          n.push(e[r].join(' '));
        return n.join(', ');
      }
      function Se(t) {
        var e = [];
        e.push('(' + ke(t.getExteriorRing()) + ')');
        for (var n = 0, r = t.getNumInteriorRing(); n < r; ++n) e.push('(' + ke(t.getInteriorRingN(n)) + ')');
        return e.join(', ');
      }
      var Ie = {
        Point: we,
        LineString: ke,
        LinearRing: ke,
        Polygon: Se,
        MultiPoint: function (t) {
          for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n) e.push('(' + we(t.getGeometryN(n)) + ')');
          return e.join(', ');
        },
        MultiLineString: function (t) {
          for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n) e.push('(' + ke(t.getGeometryN(n)) + ')');
          return e.join(', ');
        },
        MultiPolygon: function (t) {
          for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n) e.push('(' + Se(t.getGeometryN(n)) + ')');
          return e.join(', ');
        },
        GeometryCollection: function (t) {
          for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n) e.push(Pe(t.getGeometryN(n)));
          return e.join(', ');
        },
      };
      function Pe(t) {
        var e = t.getGeometryType(),
          n = Ie[e];
        e = e.toUpperCase();
        var r = (function (t) {
          var e = '';
          if (t.isEmpty()) return e;
          var n = t.getCoordinate();
          return (
            void 0 === n.z || Number.isNaN(n.z) || (e += 'Z'), void 0 === n.m || Number.isNaN(n.m) || (e += 'M'), e
          );
        })(t);
        return r.length > 0 && (e += ' ' + r), t.isEmpty() ? e + ' ' + pe : e + ' (' + n(t) + ')';
      }
      var Ne = (function () {
          function e(n) {
            t(this, e),
              (this.geometryFactory = n || new se()),
              (this.precisionModel = this.geometryFactory.getPrecisionModel());
          }
          return (
            r(e, [
              {
                key: 'read',
                value: function (t) {
                  var e = new xe(t);
                  return new Ee(e, this.geometryFactory).parse();
                },
              },
              {
                key: 'write',
                value: function (t) {
                  return Pe(t);
                },
              },
            ]),
            e
          );
        })(),
        Me = (function () {
          function e(n) {
            t(this, e), (this.parser = new Ne(n));
          }
          return (
            r(
              e,
              [
                {
                  key: 'write',
                  value: function (t) {
                    return this.parser.write(t);
                  },
                },
              ],
              [
                {
                  key: 'toLineString',
                  value: function (t, e) {
                    if (2 !== arguments.length) throw new Error('Not implemented');
                    return 'LINESTRING ( ' + t.x + ' ' + t.y + ', ' + e.x + ' ' + e.y + ' )';
                  },
                },
              ],
            ),
            e
          );
        })(),
        Oe = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getIndexAlongSegment',
                  value: function (t, e) {
                    return this.computeIntLineIndex(), this._intLineIndex[t][e];
                  },
                },
                {
                  key: 'getTopologySummary',
                  value: function () {
                    var t = new Qt();
                    return (
                      this.isEndPoint() && t.append(' endpoint'),
                      this._isProper && t.append(' proper'),
                      this.isCollinear() && t.append(' collinear'),
                      t.toString()
                    );
                  },
                },
                {
                  key: 'computeIntersection',
                  value: function (t, e, n, r) {
                    (this._inputLines[0][0] = t),
                      (this._inputLines[0][1] = e),
                      (this._inputLines[1][0] = n),
                      (this._inputLines[1][1] = r),
                      (this._result = this.computeIntersect(t, e, n, r));
                  },
                },
                {
                  key: 'getIntersectionNum',
                  value: function () {
                    return this._result;
                  },
                },
                {
                  key: 'computeIntLineIndex',
                  value: function () {
                    if (0 === arguments.length)
                      null === this._intLineIndex &&
                        ((this._intLineIndex = Array(2)
                          .fill()
                          .map(function () {
                            return Array(2);
                          })),
                        this.computeIntLineIndex(0),
                        this.computeIntLineIndex(1));
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1)
                        ? ((this._intLineIndex[t][0] = 0), (this._intLineIndex[t][1] = 1))
                        : ((this._intLineIndex[t][0] = 1), (this._intLineIndex[t][1] = 0));
                    }
                  },
                },
                {
                  key: 'isProper',
                  value: function () {
                    return this.hasIntersection() && this._isProper;
                  },
                },
                {
                  key: 'setPrecisionModel',
                  value: function (t) {
                    this._precisionModel = t;
                  },
                },
                {
                  key: 'isInteriorIntersection',
                  value: function () {
                    if (0 === arguments.length)
                      return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
                    if (1 === arguments.length) {
                      for (var t = arguments[0], e = 0; e < this._result; e++)
                        if (
                          !this._intPt[e].equals2D(this._inputLines[t][0]) &&
                          !this._intPt[e].equals2D(this._inputLines[t][1])
                        )
                          return !0;
                      return !1;
                    }
                  },
                },
                {
                  key: 'getIntersection',
                  value: function (t) {
                    return this._intPt[t];
                  },
                },
                {
                  key: 'isEndPoint',
                  value: function () {
                    return this.hasIntersection() && !this._isProper;
                  },
                },
                {
                  key: 'hasIntersection',
                  value: function () {
                    return this._result !== e.NO_INTERSECTION;
                  },
                },
                {
                  key: 'getEdgeDistance',
                  value: function (t, n) {
                    return e.computeEdgeDistance(this._intPt[n], this._inputLines[t][0], this._inputLines[t][1]);
                  },
                },
                {
                  key: 'isCollinear',
                  value: function () {
                    return this._result === e.COLLINEAR_INTERSECTION;
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return (
                      Me.toLineString(this._inputLines[0][0], this._inputLines[0][1]) +
                      ' - ' +
                      Me.toLineString(this._inputLines[1][0], this._inputLines[1][1]) +
                      this.getTopologySummary()
                    );
                  },
                },
                {
                  key: 'getEndpoint',
                  value: function (t, e) {
                    return this._inputLines[t][e];
                  },
                },
                {
                  key: 'isIntersection',
                  value: function (t) {
                    for (var e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0;
                    return !1;
                  },
                },
                {
                  key: 'getIntersectionAlongSegment',
                  value: function (t, e) {
                    return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._result = null),
                      (this._inputLines = Array(2)
                        .fill()
                        .map(function () {
                          return Array(2);
                        })),
                      (this._intPt = new Array(2).fill(null)),
                      (this._intLineIndex = null),
                      (this._isProper = null),
                      (this._pa = null),
                      (this._pb = null),
                      (this._precisionModel = null),
                      (this._intPt[0] = new Y()),
                      (this._intPt[1] = new Y()),
                      (this._pa = this._intPt[0]),
                      (this._pb = this._intPt[1]),
                      (this._result = 0);
                  },
                },
                {
                  key: 'computeEdgeDistance',
                  value: function (t, e, n) {
                    var r = Math.abs(n.x - e.x),
                      i = Math.abs(n.y - e.y),
                      o = -1;
                    if (t.equals(e)) o = 0;
                    else if (t.equals(n)) o = r > i ? r : i;
                    else {
                      var a = Math.abs(t.x - e.x),
                        s = Math.abs(t.y - e.y);
                      0 !== (o = r > i ? a : s) || t.equals(e) || (o = Math.max(a, s));
                    }
                    return B.isTrue(!(0 === o && !t.equals(e)), 'Bad distance calculation'), o;
                  },
                },
                {
                  key: 'nonRobustComputeEdgeDistance',
                  value: function (t, e, n) {
                    var r = t.x - e.x,
                      i = t.y - e.y,
                      o = Math.sqrt(r * r + i * i);
                    return B.isTrue(!(0 === o && !t.equals(e)), 'Invalid distance calculation'), o;
                  },
                },
              ],
            ),
            e
          );
        })();
      (Oe.DONT_INTERSECT = 0),
        (Oe.DO_INTERSECT = 1),
        (Oe.COLLINEAR = 2),
        (Oe.NO_INTERSECTION = 0),
        (Oe.POINT_INTERSECTION = 1),
        (Oe.COLLINEAR_INTERSECTION = 2);
      var Le = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            return t(this, a), n.call(this);
          }
          return (
            r(
              a,
              [
                {
                  key: 'isInSegmentEnvelopes',
                  value: function (t) {
                    var e = new U(this._inputLines[0][0], this._inputLines[0][1]),
                      n = new U(this._inputLines[1][0], this._inputLines[1][1]);
                    return e.contains(t) && n.contains(t);
                  },
                },
                {
                  key: 'computeIntersection',
                  value: function () {
                    if (3 !== arguments.length)
                      return p(o(a.prototype), 'computeIntersection', this).apply(this, arguments);
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2];
                    if (
                      ((this._isProper = !1),
                      U.intersects(e, n, t) && 0 === ft.index(e, n, t) && 0 === ft.index(n, e, t))
                    )
                      return (
                        (this._isProper = !0),
                        (t.equals(e) || t.equals(n)) && (this._isProper = !1),
                        (this._result = Oe.POINT_INTERSECTION),
                        null
                      );
                    this._result = Oe.NO_INTERSECTION;
                  },
                },
                {
                  key: 'intersection',
                  value: function (t, e, n, r) {
                    var i = this.intersectionSafe(t, e, n, r);
                    return (
                      this.isInSegmentEnvelopes(i) || (i = new Y(a.nearestEndpoint(t, e, n, r))),
                      null !== this._precisionModel && this._precisionModel.makePrecise(i),
                      i
                    );
                  },
                },
                {
                  key: 'checkDD',
                  value: function (t, e, n, r, i) {
                    var o = ct.intersection(t, e, n, r),
                      a = this.isInSegmentEnvelopes(o);
                    bt.out.println('DD in env = ' + a + '  --------------------- ' + o),
                      i.distance(o) > 1e-4 && bt.out.println('Distance = ' + i.distance(o));
                  },
                },
                {
                  key: 'intersectionSafe',
                  value: function (t, e, n, r) {
                    var i = _t.intersection(t, e, n, r);
                    return null === i && (i = a.nearestEndpoint(t, e, n, r)), i;
                  },
                },
                {
                  key: 'computeCollinearIntersection',
                  value: function (t, e, n, r) {
                    var i = U.intersects(t, e, n),
                      o = U.intersects(t, e, r),
                      a = U.intersects(n, r, t),
                      s = U.intersects(n, r, e);
                    return i && o
                      ? ((this._intPt[0] = n), (this._intPt[1] = r), Oe.COLLINEAR_INTERSECTION)
                      : a && s
                      ? ((this._intPt[0] = t), (this._intPt[1] = e), Oe.COLLINEAR_INTERSECTION)
                      : i && a
                      ? ((this._intPt[0] = n),
                        (this._intPt[1] = t),
                        !n.equals(t) || o || s ? Oe.COLLINEAR_INTERSECTION : Oe.POINT_INTERSECTION)
                      : i && s
                      ? ((this._intPt[0] = n),
                        (this._intPt[1] = e),
                        !n.equals(e) || o || a ? Oe.COLLINEAR_INTERSECTION : Oe.POINT_INTERSECTION)
                      : o && a
                      ? ((this._intPt[0] = r),
                        (this._intPt[1] = t),
                        !r.equals(t) || i || s ? Oe.COLLINEAR_INTERSECTION : Oe.POINT_INTERSECTION)
                      : o && s
                      ? ((this._intPt[0] = r),
                        (this._intPt[1] = e),
                        !r.equals(e) || i || a ? Oe.COLLINEAR_INTERSECTION : Oe.POINT_INTERSECTION)
                      : Oe.NO_INTERSECTION;
                  },
                },
                {
                  key: 'computeIntersect',
                  value: function (t, e, n, r) {
                    if (((this._isProper = !1), !U.intersects(t, e, n, r))) return Oe.NO_INTERSECTION;
                    var i = ft.index(t, e, n),
                      o = ft.index(t, e, r);
                    if ((i > 0 && o > 0) || (i < 0 && o < 0)) return Oe.NO_INTERSECTION;
                    var a = ft.index(n, r, t),
                      s = ft.index(n, r, e);
                    return (a > 0 && s > 0) || (a < 0 && s < 0)
                      ? Oe.NO_INTERSECTION
                      : 0 === i && 0 === o && 0 === a && 0 === s
                      ? this.computeCollinearIntersection(t, e, n, r)
                      : (0 === i || 0 === o || 0 === a || 0 === s
                          ? ((this._isProper = !1),
                            t.equals2D(n) || t.equals2D(r)
                              ? (this._intPt[0] = t)
                              : e.equals2D(n) || e.equals2D(r)
                              ? (this._intPt[0] = e)
                              : 0 === i
                              ? (this._intPt[0] = new Y(n))
                              : 0 === o
                              ? (this._intPt[0] = new Y(r))
                              : 0 === a
                              ? (this._intPt[0] = new Y(t))
                              : 0 === s && (this._intPt[0] = new Y(e)))
                          : ((this._isProper = !0), (this._intPt[0] = this.intersection(t, e, n, r))),
                        Oe.POINT_INTERSECTION);
                  },
                },
              ],
              [
                {
                  key: 'nearestEndpoint',
                  value: function (t, e, n, r) {
                    var i = t,
                      o = Et.pointToSegment(t, n, r),
                      a = Et.pointToSegment(e, n, r);
                    return (
                      a < o && ((o = a), (i = e)),
                      (a = Et.pointToSegment(n, t, e)) < o && ((o = a), (i = n)),
                      (a = Et.pointToSegment(r, t, e)) < o && ((o = a), (i = r)),
                      i
                    );
                  },
                },
              ],
            ),
            a
          );
        })(Oe),
        Re = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'countSegment',
                  value: function (t, e) {
                    if (t.x < this._p.x && e.x < this._p.x) return null;
                    if (this._p.x === e.x && this._p.y === e.y) return (this._isPointOnSegment = !0), null;
                    if (t.y === this._p.y && e.y === this._p.y) {
                      var n = t.x,
                        r = e.x;
                      return (
                        n > r && ((n = e.x), (r = t.x)),
                        this._p.x >= n && this._p.x <= r && (this._isPointOnSegment = !0),
                        null
                      );
                    }
                    if ((t.y > this._p.y && e.y <= this._p.y) || (e.y > this._p.y && t.y <= this._p.y)) {
                      var i = ft.index(t, e, this._p);
                      if (i === ft.COLLINEAR) return (this._isPointOnSegment = !0), null;
                      e.y < t.y && (i = -i), i === ft.LEFT && this._crossingCount++;
                    }
                  },
                },
                {
                  key: 'isPointInPolygon',
                  value: function () {
                    return this.getLocation() !== W.EXTERIOR;
                  },
                },
                {
                  key: 'getLocation',
                  value: function () {
                    return this._isPointOnSegment ? W.BOUNDARY : this._crossingCount % 2 == 1 ? W.INTERIOR : W.EXTERIOR;
                  },
                },
                {
                  key: 'isOnSegment',
                  value: function () {
                    return this._isPointOnSegment;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._p = null), (this._crossingCount = 0), (this._isPointOnSegment = !1);
                    var t = arguments[0];
                    this._p = t;
                  },
                },
                {
                  key: 'locatePointInRing',
                  value: function () {
                    if (arguments[0] instanceof Y && ot(arguments[1], ht)) {
                      for (
                        var t = arguments[1], n = new e(arguments[0]), r = new Y(), i = new Y(), o = 1;
                        o < t.size();
                        o++
                      )
                        if ((t.getCoordinate(o, r), t.getCoordinate(o - 1, i), n.countSegment(r, i), n.isOnSegment()))
                          return n.getLocation();
                      return n.getLocation();
                    }
                    if (arguments[0] instanceof Y && arguments[1] instanceof Array) {
                      for (var a = arguments[1], s = new e(arguments[0]), u = 1; u < a.length; u++) {
                        var l = a[u],
                          c = a[u - 1];
                        if ((s.countSegment(l, c), s.isOnSegment())) return s.getLocation();
                      }
                      return s.getLocation();
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        Ce = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'isOnLine',
                value: function () {
                  if (arguments[0] instanceof Y && ot(arguments[1], ht)) {
                    for (
                      var t = arguments[0],
                        e = arguments[1],
                        n = new Le(),
                        r = new Y(),
                        i = new Y(),
                        o = e.size(),
                        a = 1;
                      a < o;
                      a++
                    )
                      if (
                        (e.getCoordinate(a - 1, r),
                        e.getCoordinate(a, i),
                        n.computeIntersection(t, r, i),
                        n.hasIntersection())
                      )
                        return !0;
                    return !1;
                  }
                  if (arguments[0] instanceof Y && arguments[1] instanceof Array) {
                    for (var s = arguments[0], u = arguments[1], l = new Le(), c = 1; c < u.length; c++) {
                      var h = u[c - 1],
                        f = u[c];
                      if ((l.computeIntersection(s, h, f), l.hasIntersection())) return !0;
                    }
                    return !1;
                  }
                },
              },
              {
                key: 'locateInRing',
                value: function (t, e) {
                  return Re.locatePointInRing(t, e);
                },
              },
              {
                key: 'isInRing',
                value: function (t, n) {
                  return e.locateInRing(t, n) !== W.EXTERIOR;
                },
              },
            ]),
            e
          );
        })(),
        Te = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'setAllLocations',
                  value: function (t) {
                    for (var e = 0; e < this.location.length; e++) this.location[e] = t;
                  },
                },
                {
                  key: 'isNull',
                  value: function () {
                    for (var t = 0; t < this.location.length; t++) if (this.location[t] !== W.NONE) return !1;
                    return !0;
                  },
                },
                {
                  key: 'setAllLocationsIfNull',
                  value: function (t) {
                    for (var e = 0; e < this.location.length; e++)
                      this.location[e] === W.NONE && (this.location[e] = t);
                  },
                },
                {
                  key: 'isLine',
                  value: function () {
                    return 1 === this.location.length;
                  },
                },
                {
                  key: 'merge',
                  value: function (t) {
                    if (t.location.length > this.location.length) {
                      var e = new Array(3).fill(null);
                      (e[tt.ON] = this.location[tt.ON]),
                        (e[tt.LEFT] = W.NONE),
                        (e[tt.RIGHT] = W.NONE),
                        (this.location = e);
                    }
                    for (var n = 0; n < this.location.length; n++)
                      this.location[n] === W.NONE && n < t.location.length && (this.location[n] = t.location[n]);
                  },
                },
                {
                  key: 'getLocations',
                  value: function () {
                    return this.location;
                  },
                },
                {
                  key: 'flip',
                  value: function () {
                    if (this.location.length <= 1) return null;
                    var t = this.location[tt.LEFT];
                    (this.location[tt.LEFT] = this.location[tt.RIGHT]), (this.location[tt.RIGHT] = t);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    var t = new at();
                    return (
                      this.location.length > 1 && t.append(W.toLocationSymbol(this.location[tt.LEFT])),
                      t.append(W.toLocationSymbol(this.location[tt.ON])),
                      this.location.length > 1 && t.append(W.toLocationSymbol(this.location[tt.RIGHT])),
                      t.toString()
                    );
                  },
                },
                {
                  key: 'setLocations',
                  value: function (t, e, n) {
                    (this.location[tt.ON] = t), (this.location[tt.LEFT] = e), (this.location[tt.RIGHT] = n);
                  },
                },
                {
                  key: 'get',
                  value: function (t) {
                    return t < this.location.length ? this.location[t] : W.NONE;
                  },
                },
                {
                  key: 'isArea',
                  value: function () {
                    return this.location.length > 1;
                  },
                },
                {
                  key: 'isAnyNull',
                  value: function () {
                    for (var t = 0; t < this.location.length; t++) if (this.location[t] === W.NONE) return !0;
                    return !1;
                  },
                },
                {
                  key: 'setLocation',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      this.setLocation(tt.ON, t);
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      this.location[e] = n;
                    }
                  },
                },
                {
                  key: 'init',
                  value: function (t) {
                    (this.location = new Array(t).fill(null)), this.setAllLocations(W.NONE);
                  },
                },
                {
                  key: 'isEqualOnSide',
                  value: function (t, e) {
                    return this.location[e] === t.location[e];
                  },
                },
                {
                  key: 'allPositionsEqual',
                  value: function (t) {
                    for (var e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1;
                    return !0;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this.location = null), 1 === arguments.length)) {
                      if (arguments[0] instanceof Array) {
                        var t = arguments[0];
                        this.init(t.length);
                      } else if (Number.isInteger(arguments[0])) {
                        var n = arguments[0];
                        this.init(1), (this.location[tt.ON] = n);
                      } else if (arguments[0] instanceof e) {
                        var r = arguments[0];
                        if ((this.init(r.location.length), null !== r))
                          for (var i = 0; i < this.location.length; i++) this.location[i] = r.location[i];
                      }
                    } else if (3 === arguments.length) {
                      var o = arguments[0],
                        a = arguments[1],
                        s = arguments[2];
                      this.init(3),
                        (this.location[tt.ON] = o),
                        (this.location[tt.LEFT] = a),
                        (this.location[tt.RIGHT] = s);
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        Ae = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getGeometryCount',
                  value: function () {
                    var t = 0;
                    return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t;
                  },
                },
                {
                  key: 'setAllLocations',
                  value: function (t, e) {
                    this.elt[t].setAllLocations(e);
                  },
                },
                {
                  key: 'isNull',
                  value: function (t) {
                    return this.elt[t].isNull();
                  },
                },
                {
                  key: 'setAllLocationsIfNull',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t);
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      this.elt[e].setAllLocationsIfNull(n);
                    }
                  },
                },
                {
                  key: 'isLine',
                  value: function (t) {
                    return this.elt[t].isLine();
                  },
                },
                {
                  key: 'merge',
                  value: function (t) {
                    for (var e = 0; e < 2; e++)
                      null === this.elt[e] && null !== t.elt[e]
                        ? (this.elt[e] = new Te(t.elt[e]))
                        : this.elt[e].merge(t.elt[e]);
                  },
                },
                {
                  key: 'flip',
                  value: function () {
                    this.elt[0].flip(), this.elt[1].flip();
                  },
                },
                {
                  key: 'getLocation',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      return this.elt[t].get(tt.ON);
                    }
                    if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      return this.elt[e].get(n);
                    }
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    var t = new at();
                    return (
                      null !== this.elt[0] && (t.append('A:'), t.append(this.elt[0].toString())),
                      null !== this.elt[1] && (t.append(' B:'), t.append(this.elt[1].toString())),
                      t.toString()
                    );
                  },
                },
                {
                  key: 'isArea',
                  value: function () {
                    if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      return this.elt[t].isArea();
                    }
                  },
                },
                {
                  key: 'isAnyNull',
                  value: function (t) {
                    return this.elt[t].isAnyNull();
                  },
                },
                {
                  key: 'setLocation',
                  value: function () {
                    if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1];
                      this.elt[t].setLocation(tt.ON, e);
                    } else if (3 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1],
                        i = arguments[2];
                      this.elt[n].setLocation(r, i);
                    }
                  },
                },
                {
                  key: 'isEqualOnSide',
                  value: function (t, e) {
                    return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e);
                  },
                },
                {
                  key: 'allPositionsEqual',
                  value: function (t, e) {
                    return this.elt[t].allPositionsEqual(e);
                  },
                },
                {
                  key: 'toLine',
                  value: function (t) {
                    this.elt[t].isArea() && (this.elt[t] = new Te(this.elt[t].location[0]));
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this.elt = new Array(2).fill(null)), 1 === arguments.length)) {
                      if (Number.isInteger(arguments[0])) {
                        var t = arguments[0];
                        (this.elt[0] = new Te(t)), (this.elt[1] = new Te(t));
                      } else if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        (this.elt[0] = new Te(n.elt[0])), (this.elt[1] = new Te(n.elt[1]));
                      }
                    } else if (2 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      (this.elt[0] = new Te(W.NONE)), (this.elt[1] = new Te(W.NONE)), this.elt[r].setLocation(i);
                    } else if (3 === arguments.length) {
                      var o = arguments[0],
                        a = arguments[1],
                        s = arguments[2];
                      (this.elt[0] = new Te(o, a, s)), (this.elt[1] = new Te(o, a, s));
                    } else if (4 === arguments.length) {
                      var u = arguments[0],
                        l = arguments[1],
                        c = arguments[2],
                        h = arguments[3];
                      (this.elt[0] = new Te(W.NONE, W.NONE, W.NONE)),
                        (this.elt[1] = new Te(W.NONE, W.NONE, W.NONE)),
                        this.elt[u].setLocations(l, c, h);
                    }
                  },
                },
                {
                  key: 'toLineLabel',
                  value: function (t) {
                    for (var n = new e(W.NONE), r = 0; r < 2; r++) n.setLocation(r, t.getLocation(r));
                    return n;
                  },
                },
              ],
            ),
            e
          );
        })(),
        De = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'computeRing',
                  value: function () {
                    if (null !== this._ring) return null;
                    for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++)
                      t[e] = this._pts.get(e);
                    (this._ring = this._geometryFactory.createLinearRing(t)),
                      (this._isHole = ft.isCCW(this._ring.getCoordinates()));
                  },
                },
                {
                  key: 'isIsolated',
                  value: function () {
                    return 1 === this._label.getGeometryCount();
                  },
                },
                {
                  key: 'computePoints',
                  value: function (t) {
                    this._startDe = t;
                    var e = t,
                      n = !0;
                    do {
                      if (null === e) throw new gt('Found null DirectedEdge');
                      if (e.getEdgeRing() === this)
                        throw new gt('Directed Edge visited twice during ring-building at ' + e.getCoordinate());
                      this._edges.add(e);
                      var r = e.getLabel();
                      B.isTrue(r.isArea()),
                        this.mergeLabel(r),
                        this.addPoints(e.getEdge(), e.isForward(), n),
                        (n = !1),
                        this.setEdgeRing(e, this),
                        (e = this.getNext(e));
                    } while (e !== this._startDe);
                  },
                },
                {
                  key: 'getLinearRing',
                  value: function () {
                    return this._ring;
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function (t) {
                    return this._pts.get(t);
                  },
                },
                {
                  key: 'computeMaxNodeDegree',
                  value: function () {
                    this._maxNodeDegree = 0;
                    var t = this._startDe;
                    do {
                      var e = t.getNode().getEdges().getOutgoingDegree(this);
                      e > this._maxNodeDegree && (this._maxNodeDegree = e), (t = this.getNext(t));
                    } while (t !== this._startDe);
                    this._maxNodeDegree *= 2;
                  },
                },
                {
                  key: 'addPoints',
                  value: function (t, e, n) {
                    var r = t.getCoordinates();
                    if (e) {
                      var i = 1;
                      n && (i = 0);
                      for (var o = i; o < r.length; o++) this._pts.add(r[o]);
                    } else {
                      var a = r.length - 2;
                      n && (a = r.length - 1);
                      for (var s = a; s >= 0; s--) this._pts.add(r[s]);
                    }
                  },
                },
                {
                  key: 'isHole',
                  value: function () {
                    return this._isHole;
                  },
                },
                {
                  key: 'setInResult',
                  value: function () {
                    var t = this._startDe;
                    do {
                      t.getEdge().setInResult(!0), (t = t.getNext());
                    } while (t !== this._startDe);
                  },
                },
                {
                  key: 'containsPoint',
                  value: function (t) {
                    var e = this.getLinearRing();
                    if (!e.getEnvelopeInternal().contains(t)) return !1;
                    if (!Ce.isInRing(t, e.getCoordinates())) return !1;
                    for (var n = this._holes.iterator(); n.hasNext(); ) if (n.next().containsPoint(t)) return !1;
                    return !0;
                  },
                },
                {
                  key: 'addHole',
                  value: function (t) {
                    this._holes.add(t);
                  },
                },
                {
                  key: 'isShell',
                  value: function () {
                    return null === this._shell;
                  },
                },
                {
                  key: 'getLabel',
                  value: function () {
                    return this._label;
                  },
                },
                {
                  key: 'getEdges',
                  value: function () {
                    return this._edges;
                  },
                },
                {
                  key: 'getMaxNodeDegree',
                  value: function () {
                    return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
                  },
                },
                {
                  key: 'getShell',
                  value: function () {
                    return this._shell;
                  },
                },
                {
                  key: 'mergeLabel',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      this.mergeLabel(t, 0), this.mergeLabel(t, 1);
                    } else if (2 === arguments.length) {
                      var e = arguments[1],
                        n = arguments[0].getLocation(e, tt.RIGHT);
                      if (n === W.NONE) return null;
                      if (this._label.getLocation(e) === W.NONE) return this._label.setLocation(e, n), null;
                    }
                  },
                },
                {
                  key: 'setShell',
                  value: function (t) {
                    (this._shell = t), null !== t && t.addHole(this);
                  },
                },
                {
                  key: 'toPolygon',
                  value: function (t) {
                    for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++)
                      e[n] = this._holes.get(n).getLinearRing();
                    return t.createPolygon(this.getLinearRing(), e);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._startDe = null),
                      (this._maxNodeDegree = -1),
                      (this._edges = new vt()),
                      (this._pts = new vt()),
                      (this._label = new Ae(W.NONE)),
                      (this._ring = null),
                      (this._isHole = null),
                      (this._shell = null),
                      (this._holes = new vt()),
                      (this._geometryFactory = null),
                      0 === arguments.length)
                    );
                    else if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1];
                      (this._geometryFactory = e), this.computePoints(t), this.computeRing();
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        je = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              o,
              [
                {
                  key: 'setEdgeRing',
                  value: function (t, e) {
                    t.setMinEdgeRing(e);
                  },
                },
                {
                  key: 'getNext',
                  value: function (t) {
                    return t.getNextMin();
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    var t = arguments[0],
                      e = arguments[1];
                    De.constructor_.call(this, t, e);
                  },
                },
              ],
            ),
            o
          );
        })(De),
        Fe = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              o,
              [
                {
                  key: 'buildMinimalRings',
                  value: function () {
                    var t = new vt(),
                      e = this._startDe;
                    do {
                      if (null === e.getMinEdgeRing()) {
                        var n = new je(e, this._geometryFactory);
                        t.add(n);
                      }
                      e = e.getNext();
                    } while (e !== this._startDe);
                    return t;
                  },
                },
                {
                  key: 'setEdgeRing',
                  value: function (t, e) {
                    t.setEdgeRing(e);
                  },
                },
                {
                  key: 'linkDirectedEdgesForMinimalEdgeRings',
                  value: function () {
                    var t = this._startDe;
                    do {
                      t.getNode().getEdges().linkMinimalDirectedEdges(this), (t = t.getNext());
                    } while (t !== this._startDe);
                  },
                },
                {
                  key: 'getNext',
                  value: function (t) {
                    return t.getNext();
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    var t = arguments[0],
                      e = arguments[1];
                    De.constructor_.call(this, t, e);
                  },
                },
              ],
            ),
            o
          );
        })(De),
        Be = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'setVisited',
                  value: function (t) {
                    this._isVisited = t;
                  },
                },
                {
                  key: 'setInResult',
                  value: function (t) {
                    this._isInResult = t;
                  },
                },
                {
                  key: 'isCovered',
                  value: function () {
                    return this._isCovered;
                  },
                },
                {
                  key: 'isCoveredSet',
                  value: function () {
                    return this._isCoveredSet;
                  },
                },
                {
                  key: 'setLabel',
                  value: function (t) {
                    this._label = t;
                  },
                },
                {
                  key: 'getLabel',
                  value: function () {
                    return this._label;
                  },
                },
                {
                  key: 'setCovered',
                  value: function (t) {
                    (this._isCovered = t), (this._isCoveredSet = !0);
                  },
                },
                {
                  key: 'updateIM',
                  value: function (t) {
                    B.isTrue(this._label.getGeometryCount() >= 2, 'found partial label'), this.computeIM(t);
                  },
                },
                {
                  key: 'isInResult',
                  value: function () {
                    return this._isInResult;
                  },
                },
                {
                  key: 'isVisited',
                  value: function () {
                    return this._isVisited;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._label = null),
                      (this._isInResult = !1),
                      (this._isCovered = !1),
                      (this._isCoveredSet = !1),
                      (this._isVisited = !1),
                      0 === arguments.length)
                    );
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      this._label = t;
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        qe = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'isIncidentEdgeInResult',
                  value: function () {
                    for (var t = this.getEdges().getEdges().iterator(); t.hasNext(); )
                      if (t.next().getEdge().isInResult()) return !0;
                    return !1;
                  },
                },
                {
                  key: 'isIsolated',
                  value: function () {
                    return 1 === this._label.getGeometryCount();
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    return this._coord;
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    t.println('node ' + this._coord + ' lbl: ' + this._label);
                  },
                },
                { key: 'computeIM', value: function (t) {} },
                {
                  key: 'computeMergedLocation',
                  value: function (t, e) {
                    var n = W.NONE;
                    if (((n = this._label.getLocation(e)), !t.isNull(e))) {
                      var r = t.getLocation(e);
                      n !== W.BOUNDARY && (n = r);
                    }
                    return n;
                  },
                },
                {
                  key: 'setLabel',
                  value: function () {
                    if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0]))
                      return p(o(a.prototype), 'setLabel', this).apply(this, arguments);
                    var t = arguments[0],
                      e = arguments[1];
                    null === this._label ? (this._label = new Ae(t, e)) : this._label.setLocation(t, e);
                  },
                },
                {
                  key: 'getEdges',
                  value: function () {
                    return this._edges;
                  },
                },
                {
                  key: 'mergeLabel',
                  value: function () {
                    if (arguments[0] instanceof a) {
                      var t = arguments[0];
                      this.mergeLabel(t._label);
                    } else if (arguments[0] instanceof Ae)
                      for (var e = arguments[0], n = 0; n < 2; n++) {
                        var r = this.computeMergedLocation(e, n);
                        this._label.getLocation(n) === W.NONE && this._label.setLocation(n, r);
                      }
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    this._edges.insert(t), t.setNode(this);
                  },
                },
                {
                  key: 'setLabelBoundary',
                  value: function (t) {
                    if (null === this._label) return null;
                    var e = W.NONE;
                    null !== this._label && (e = this._label.getLocation(t));
                    var n = null;
                    switch (e) {
                      case W.BOUNDARY:
                        n = W.INTERIOR;
                        break;
                      case W.INTERIOR:
                      default:
                        n = W.BOUNDARY;
                    }
                    this._label.setLocation(t, n);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._coord = null), (this._edges = null);
                    var t = arguments[0],
                      e = arguments[1];
                    (this._coord = t), (this._edges = e), (this._label = new Ae(0, W.NONE));
                  },
                },
              ],
            ),
            a
          );
        })(Be),
        Ve = (function (e) {
          i(r, e);
          var n = f(r);
          function r() {
            return t(this, r), n.apply(this, arguments);
          }
          return r;
        })(ne);
      function Ge(t) {
        return null == t ? 0 : t.color;
      }
      function Ye(t) {
        return null == t ? null : t.parent;
      }
      function ze(t, e) {
        null !== t && (t.color = e);
      }
      function Ue(t) {
        return null == t ? null : t.left;
      }
      function Xe(t) {
        return null == t ? null : t.right;
      }
      var We = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), ((e = n.call(this)).root_ = null), (e.size_ = 0), e;
          }
          return (
            r(
              o,
              [
                {
                  key: 'get',
                  value: function (t) {
                    for (var e = this.root_; null !== e; ) {
                      var n = t.compareTo(e.key);
                      if (n < 0) e = e.left;
                      else {
                        if (!(n > 0)) return e.value;
                        e = e.right;
                      }
                    }
                    return null;
                  },
                },
                {
                  key: 'put',
                  value: function (t, e) {
                    if (null === this.root_)
                      return (
                        (this.root_ = {
                          key: t,
                          value: e,
                          left: null,
                          right: null,
                          parent: null,
                          color: 0,
                          getValue: function () {
                            return this.value;
                          },
                          getKey: function () {
                            return this.key;
                          },
                        }),
                        (this.size_ = 1),
                        null
                      );
                    var n,
                      r,
                      i = this.root_;
                    do {
                      if (((n = i), (r = t.compareTo(i.key)) < 0)) i = i.left;
                      else {
                        if (!(r > 0)) {
                          var o = i.value;
                          return (i.value = e), o;
                        }
                        i = i.right;
                      }
                    } while (null !== i);
                    var a = {
                      key: t,
                      left: null,
                      right: null,
                      value: e,
                      parent: n,
                      color: 0,
                      getValue: function () {
                        return this.value;
                      },
                      getKey: function () {
                        return this.key;
                      },
                    };
                    return r < 0 ? (n.left = a) : (n.right = a), this.fixAfterInsertion(a), this.size_++, null;
                  },
                },
                {
                  key: 'fixAfterInsertion',
                  value: function (t) {
                    var e;
                    for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color; )
                      Ye(t) === Ue(Ye(Ye(t)))
                        ? 1 === Ge((e = Xe(Ye(Ye(t)))))
                          ? (ze(Ye(t), 0), ze(e, 0), ze(Ye(Ye(t)), 1), (t = Ye(Ye(t))))
                          : (t === Xe(Ye(t)) && ((t = Ye(t)), this.rotateLeft(t)),
                            ze(Ye(t), 0),
                            ze(Ye(Ye(t)), 1),
                            this.rotateRight(Ye(Ye(t))))
                        : 1 === Ge((e = Ue(Ye(Ye(t)))))
                        ? (ze(Ye(t), 0), ze(e, 0), ze(Ye(Ye(t)), 1), (t = Ye(Ye(t))))
                        : (t === Ue(Ye(t)) && ((t = Ye(t)), this.rotateRight(t)),
                          ze(Ye(t), 0),
                          ze(Ye(Ye(t)), 1),
                          this.rotateLeft(Ye(Ye(t))));
                    this.root_.color = 0;
                  },
                },
                {
                  key: 'values',
                  value: function () {
                    var t = new vt(),
                      e = this.getFirstEntry();
                    if (null !== e) for (t.add(e.value); null !== (e = o.successor(e)); ) t.add(e.value);
                    return t;
                  },
                },
                {
                  key: 'entrySet',
                  value: function () {
                    var t = new Q(),
                      e = this.getFirstEntry();
                    if (null !== e) for (t.add(e); null !== (e = o.successor(e)); ) t.add(e);
                    return t;
                  },
                },
                {
                  key: 'rotateLeft',
                  value: function (t) {
                    if (null != t) {
                      var e = t.right;
                      (t.right = e.left),
                        null != e.left && (e.left.parent = t),
                        (e.parent = t.parent),
                        null == t.parent
                          ? (this.root_ = e)
                          : t.parent.left === t
                          ? (t.parent.left = e)
                          : (t.parent.right = e),
                        (e.left = t),
                        (t.parent = e);
                    }
                  },
                },
                {
                  key: 'rotateRight',
                  value: function (t) {
                    if (null != t) {
                      var e = t.left;
                      (t.left = e.right),
                        null != e.right && (e.right.parent = t),
                        (e.parent = t.parent),
                        null == t.parent
                          ? (this.root_ = e)
                          : t.parent.right === t
                          ? (t.parent.right = e)
                          : (t.parent.left = e),
                        (e.right = t),
                        (t.parent = e);
                    }
                  },
                },
                {
                  key: 'getFirstEntry',
                  value: function () {
                    var t = this.root_;
                    if (null != t) for (; null != t.left; ) t = t.left;
                    return t;
                  },
                },
                {
                  key: 'size',
                  value: function () {
                    return this.size_;
                  },
                },
                {
                  key: 'containsKey',
                  value: function (t) {
                    for (var e = this.root_; null !== e; ) {
                      var n = t.compareTo(e.key);
                      if (n < 0) e = e.left;
                      else {
                        if (!(n > 0)) return !0;
                        e = e.right;
                      }
                    }
                    return !1;
                  },
                },
              ],
              [
                {
                  key: 'successor',
                  value: function (t) {
                    var e;
                    if (null === t) return null;
                    if (null !== t.right) {
                      for (e = t.right; null !== e.left; ) e = e.left;
                      return e;
                    }
                    e = t.parent;
                    for (var n = t; null !== e && n === e.right; ) (n = e), (e = e.parent);
                    return e;
                  },
                },
              ],
            ),
            o
          );
        })(Ve),
        He = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'find',
                  value: function (t) {
                    return this.nodeMap.get(t);
                  },
                },
                {
                  key: 'addNode',
                  value: function () {
                    if (arguments[0] instanceof Y) {
                      var t = arguments[0],
                        e = this.nodeMap.get(t);
                      return null === e && ((e = this.nodeFact.createNode(t)), this.nodeMap.put(t, e)), e;
                    }
                    if (arguments[0] instanceof qe) {
                      var n = arguments[0],
                        r = this.nodeMap.get(n.getCoordinate());
                      return null === r ? (this.nodeMap.put(n.getCoordinate(), n), n) : (r.mergeLabel(n), r);
                    }
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    for (var e = this.iterator(); e.hasNext(); ) e.next().print(t);
                  },
                },
                {
                  key: 'iterator',
                  value: function () {
                    return this.nodeMap.values().iterator();
                  },
                },
                {
                  key: 'values',
                  value: function () {
                    return this.nodeMap.values();
                  },
                },
                {
                  key: 'getBoundaryNodes',
                  value: function (t) {
                    for (var e = new vt(), n = this.iterator(); n.hasNext(); ) {
                      var r = n.next();
                      r.getLabel().getLocation(t) === W.BOUNDARY && e.add(r);
                    }
                    return e;
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    var e = t.getCoordinate();
                    this.addNode(e).add(t);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this.nodeMap = new We()), (this.nodeFact = null);
                    var t = arguments[0];
                    this.nodeFact = t;
                  },
                },
              ],
            ),
            e
          );
        })(),
        Ze = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'isNorthern',
                value: function (t) {
                  return t === e.NE || t === e.NW;
                },
              },
              {
                key: 'isOpposite',
                value: function (t, e) {
                  return t !== e && 2 == (t - e + 4) % 4;
                },
              },
              {
                key: 'commonHalfPlane',
                value: function (t, e) {
                  if (t === e) return t;
                  if (2 == (t - e + 4) % 4) return -1;
                  var n = t < e ? t : e;
                  return 0 === n && 3 === (t > e ? t : e) ? 3 : n;
                },
              },
              {
                key: 'isInHalfPlane',
                value: function (t, n) {
                  return n === e.SE ? t === e.SE || t === e.SW : t === n || t === n + 1;
                },
              },
              {
                key: 'quadrant',
                value: function () {
                  if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
                    var t = arguments[0],
                      n = arguments[1];
                    if (0 === t && 0 === n)
                      throw new b('Cannot compute the quadrant for point ( ' + t + ', ' + n + ' )');
                    return t >= 0 ? (n >= 0 ? e.NE : e.SE) : n >= 0 ? e.NW : e.SW;
                  }
                  if (arguments[0] instanceof Y && arguments[1] instanceof Y) {
                    var r = arguments[0],
                      i = arguments[1];
                    if (i.x === r.x && i.y === r.y)
                      throw new b('Cannot compute the quadrant for two identical points ' + r);
                    return i.x >= r.x ? (i.y >= r.y ? e.NE : e.SE) : i.y >= r.y ? e.NW : e.SW;
                  }
                },
              },
            ]),
            e
          );
        })();
      (Ze.NE = 0), (Ze.NW = 1), (Ze.SW = 2), (Ze.SE = 3);
      var Je = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'compareDirection',
                  value: function (t) {
                    return this._dx === t._dx && this._dy === t._dy
                      ? 0
                      : this._quadrant > t._quadrant
                      ? 1
                      : this._quadrant < t._quadrant
                      ? -1
                      : ft.index(t._p0, t._p1, this._p1);
                  },
                },
                {
                  key: 'getDy',
                  value: function () {
                    return this._dy;
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    return this._p0;
                  },
                },
                {
                  key: 'setNode',
                  value: function (t) {
                    this._node = t;
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    var e = Math.atan2(this._dy, this._dx),
                      n = this.getClass().getName(),
                      r = n.lastIndexOf('.'),
                      i = n.substring(r + 1);
                    t.print(
                      '  ' +
                        i +
                        ': ' +
                        this._p0 +
                        ' - ' +
                        this._p1 +
                        ' ' +
                        this._quadrant +
                        ':' +
                        e +
                        '   ' +
                        this._label,
                    );
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    return this.compareDirection(e);
                  },
                },
                {
                  key: 'getDirectedCoordinate',
                  value: function () {
                    return this._p1;
                  },
                },
                {
                  key: 'getDx',
                  value: function () {
                    return this._dx;
                  },
                },
                {
                  key: 'getLabel',
                  value: function () {
                    return this._label;
                  },
                },
                {
                  key: 'getEdge',
                  value: function () {
                    return this._edge;
                  },
                },
                {
                  key: 'getQuadrant',
                  value: function () {
                    return this._quadrant;
                  },
                },
                {
                  key: 'getNode',
                  value: function () {
                    return this._node;
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    var t = Math.atan2(this._dy, this._dx),
                      e = this.getClass().getName(),
                      n = e.lastIndexOf('.');
                    return (
                      '  ' +
                      e.substring(n + 1) +
                      ': ' +
                      this._p0 +
                      ' - ' +
                      this._p1 +
                      ' ' +
                      this._quadrant +
                      ':' +
                      t +
                      '   ' +
                      this._label
                    );
                  },
                },
                { key: 'computeLabel', value: function (t) {} },
                {
                  key: 'init',
                  value: function (t, e) {
                    (this._p0 = t),
                      (this._p1 = e),
                      (this._dx = e.x - t.x),
                      (this._dy = e.y - t.y),
                      (this._quadrant = Ze.quadrant(this._dx, this._dy)),
                      B.isTrue(!(0 === this._dx && 0 === this._dy), 'EdgeEnd with identical endpoints found');
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._edge = null),
                      (this._label = null),
                      (this._node = null),
                      (this._p0 = null),
                      (this._p1 = null),
                      (this._dx = null),
                      (this._dy = null),
                      (this._quadrant = null),
                      1 === arguments.length)
                    ) {
                      var t = arguments[0];
                      this._edge = t;
                    } else if (3 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1],
                        i = arguments[2];
                      e.constructor_.call(this, n, r, i, null);
                    } else if (4 === arguments.length) {
                      var o = arguments[0],
                        a = arguments[1],
                        s = arguments[2],
                        u = arguments[3];
                      e.constructor_.call(this, o), this.init(a, s), (this._label = u);
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        $e = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'getNextMin',
                  value: function () {
                    return this._nextMin;
                  },
                },
                {
                  key: 'getDepth',
                  value: function (t) {
                    return this._depth[t];
                  },
                },
                {
                  key: 'setVisited',
                  value: function (t) {
                    this._isVisited = t;
                  },
                },
                {
                  key: 'computeDirectedLabel',
                  value: function () {
                    (this._label = new Ae(this._edge.getLabel())), this._isForward || this._label.flip();
                  },
                },
                {
                  key: 'getNext',
                  value: function () {
                    return this._next;
                  },
                },
                {
                  key: 'setDepth',
                  value: function (t, e) {
                    if (-999 !== this._depth[t] && this._depth[t] !== e)
                      throw new gt('assigned depths do not match', this.getCoordinate());
                    this._depth[t] = e;
                  },
                },
                {
                  key: 'isInteriorAreaEdge',
                  value: function () {
                    for (var t = !0, e = 0; e < 2; e++)
                      (this._label.isArea(e) &&
                        this._label.getLocation(e, tt.LEFT) === W.INTERIOR &&
                        this._label.getLocation(e, tt.RIGHT) === W.INTERIOR) ||
                        (t = !1);
                    return t;
                  },
                },
                {
                  key: 'setNextMin',
                  value: function (t) {
                    this._nextMin = t;
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    p(o(a.prototype), 'print', this).call(this, t),
                      t.print(' ' + this._depth[tt.LEFT] + '/' + this._depth[tt.RIGHT]),
                      t.print(' (' + this.getDepthDelta() + ')'),
                      this._isInResult && t.print(' inResult');
                  },
                },
                {
                  key: 'setMinEdgeRing',
                  value: function (t) {
                    this._minEdgeRing = t;
                  },
                },
                {
                  key: 'isLineEdge',
                  value: function () {
                    var t = this._label.isLine(0) || this._label.isLine(1),
                      e = !this._label.isArea(0) || this._label.allPositionsEqual(0, W.EXTERIOR),
                      n = !this._label.isArea(1) || this._label.allPositionsEqual(1, W.EXTERIOR);
                    return t && e && n;
                  },
                },
                {
                  key: 'setEdgeRing',
                  value: function (t) {
                    this._edgeRing = t;
                  },
                },
                {
                  key: 'getMinEdgeRing',
                  value: function () {
                    return this._minEdgeRing;
                  },
                },
                {
                  key: 'getDepthDelta',
                  value: function () {
                    var t = this._edge.getDepthDelta();
                    return this._isForward || (t = -t), t;
                  },
                },
                {
                  key: 'setInResult',
                  value: function (t) {
                    this._isInResult = t;
                  },
                },
                {
                  key: 'getSym',
                  value: function () {
                    return this._sym;
                  },
                },
                {
                  key: 'isForward',
                  value: function () {
                    return this._isForward;
                  },
                },
                {
                  key: 'getEdge',
                  value: function () {
                    return this._edge;
                  },
                },
                {
                  key: 'printEdge',
                  value: function (t) {
                    this.print(t), t.print(' '), this._isForward ? this._edge.print(t) : this._edge.printReverse(t);
                  },
                },
                {
                  key: 'setSym',
                  value: function (t) {
                    this._sym = t;
                  },
                },
                {
                  key: 'setVisitedEdge',
                  value: function (t) {
                    this.setVisited(t), this._sym.setVisited(t);
                  },
                },
                {
                  key: 'setEdgeDepths',
                  value: function (t, e) {
                    var n = this.getEdge().getDepthDelta();
                    this._isForward || (n = -n);
                    var r = 1;
                    t === tt.LEFT && (r = -1);
                    var i = tt.opposite(t),
                      o = e + n * r;
                    this.setDepth(t, e), this.setDepth(i, o);
                  },
                },
                {
                  key: 'getEdgeRing',
                  value: function () {
                    return this._edgeRing;
                  },
                },
                {
                  key: 'isInResult',
                  value: function () {
                    return this._isInResult;
                  },
                },
                {
                  key: 'setNext',
                  value: function (t) {
                    this._next = t;
                  },
                },
                {
                  key: 'isVisited',
                  value: function () {
                    return this._isVisited;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._isForward = null),
                      (this._isInResult = !1),
                      (this._isVisited = !1),
                      (this._sym = null),
                      (this._next = null),
                      (this._nextMin = null),
                      (this._edgeRing = null),
                      (this._minEdgeRing = null),
                      (this._depth = [0, -999, -999]);
                    var t = arguments[0],
                      e = arguments[1];
                    if ((Je.constructor_.call(this, t), (this._isForward = e), e))
                      this.init(t.getCoordinate(0), t.getCoordinate(1));
                    else {
                      var n = t.getNumPoints() - 1;
                      this.init(t.getCoordinate(n), t.getCoordinate(n - 1));
                    }
                    this.computeDirectedLabel();
                  },
                },
                {
                  key: 'depthFactor',
                  value: function (t, e) {
                    return t === W.EXTERIOR && e === W.INTERIOR ? 1 : t === W.INTERIOR && e === W.EXTERIOR ? -1 : 0;
                  },
                },
              ],
            ),
            a
          );
        })(Je),
        Qe = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              {
                key: 'createNode',
                value: function (t) {
                  return new qe(t, null);
                },
              },
            ]),
            e
          );
        })(),
        Ke = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'printEdges',
                  value: function (t) {
                    t.println('Edges:');
                    for (var e = 0; e < this._edges.size(); e++) {
                      t.println('edge ' + e + ':');
                      var n = this._edges.get(e);
                      n.print(t), n.eiList.print(t);
                    }
                  },
                },
                {
                  key: 'find',
                  value: function (t) {
                    return this._nodes.find(t);
                  },
                },
                {
                  key: 'addNode',
                  value: function () {
                    if (arguments[0] instanceof qe) {
                      var t = arguments[0];
                      return this._nodes.addNode(t);
                    }
                    if (arguments[0] instanceof Y) {
                      var e = arguments[0];
                      return this._nodes.addNode(e);
                    }
                  },
                },
                {
                  key: 'getNodeIterator',
                  value: function () {
                    return this._nodes.iterator();
                  },
                },
                {
                  key: 'linkResultDirectedEdges',
                  value: function () {
                    for (var t = this._nodes.iterator(); t.hasNext(); ) t.next().getEdges().linkResultDirectedEdges();
                  },
                },
                {
                  key: 'debugPrintln',
                  value: function (t) {
                    bt.out.println(t);
                  },
                },
                {
                  key: 'isBoundaryNode',
                  value: function (t, e) {
                    var n = this._nodes.find(e);
                    if (null === n) return !1;
                    var r = n.getLabel();
                    return null !== r && r.getLocation(t) === W.BOUNDARY;
                  },
                },
                {
                  key: 'linkAllDirectedEdges',
                  value: function () {
                    for (var t = this._nodes.iterator(); t.hasNext(); ) t.next().getEdges().linkAllDirectedEdges();
                  },
                },
                {
                  key: 'matchInSameDirection',
                  value: function (t, e, n, r) {
                    return (
                      !!t.equals(n) && ft.index(t, e, r) === ft.COLLINEAR && Ze.quadrant(t, e) === Ze.quadrant(n, r)
                    );
                  },
                },
                {
                  key: 'getEdgeEnds',
                  value: function () {
                    return this._edgeEndList;
                  },
                },
                {
                  key: 'debugPrint',
                  value: function (t) {
                    bt.out.print(t);
                  },
                },
                {
                  key: 'getEdgeIterator',
                  value: function () {
                    return this._edges.iterator();
                  },
                },
                {
                  key: 'findEdgeInSameDirection',
                  value: function (t, e) {
                    for (var n = 0; n < this._edges.size(); n++) {
                      var r = this._edges.get(n),
                        i = r.getCoordinates();
                      if (this.matchInSameDirection(t, e, i[0], i[1])) return r;
                      if (this.matchInSameDirection(t, e, i[i.length - 1], i[i.length - 2])) return r;
                    }
                    return null;
                  },
                },
                {
                  key: 'insertEdge',
                  value: function (t) {
                    this._edges.add(t);
                  },
                },
                {
                  key: 'findEdgeEnd',
                  value: function (t) {
                    for (var e = this.getEdgeEnds().iterator(); e.hasNext(); ) {
                      var n = e.next();
                      if (n.getEdge() === t) return n;
                    }
                    return null;
                  },
                },
                {
                  key: 'addEdges',
                  value: function (t) {
                    for (var e = t.iterator(); e.hasNext(); ) {
                      var n = e.next();
                      this._edges.add(n);
                      var r = new $e(n, !0),
                        i = new $e(n, !1);
                      r.setSym(i), i.setSym(r), this.add(r), this.add(i);
                    }
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    this._nodes.add(t), this._edgeEndList.add(t);
                  },
                },
                {
                  key: 'getNodes',
                  value: function () {
                    return this._nodes.values();
                  },
                },
                {
                  key: 'findEdge',
                  value: function (t, e) {
                    for (var n = 0; n < this._edges.size(); n++) {
                      var r = this._edges.get(n),
                        i = r.getCoordinates();
                      if (t.equals(i[0]) && e.equals(i[1])) return r;
                    }
                    return null;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._edges = new vt()),
                      (this._nodes = null),
                      (this._edgeEndList = new vt()),
                      0 === arguments.length)
                    )
                      this._nodes = new He(new Qe());
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      this._nodes = new He(t);
                    }
                  },
                },
                {
                  key: 'linkResultDirectedEdges',
                  value: function (t) {
                    for (var e = t.iterator(); e.hasNext(); ) e.next().getEdges().linkResultDirectedEdges();
                  },
                },
              ],
            ),
            e
          );
        })(),
        tn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'sortShellsAndHoles',
                  value: function (t, e, n) {
                    for (var r = t.iterator(); r.hasNext(); ) {
                      var i = r.next();
                      i.isHole() ? n.add(i) : e.add(i);
                    }
                  },
                },
                {
                  key: 'computePolygons',
                  value: function (t) {
                    for (var e = new vt(), n = t.iterator(); n.hasNext(); ) {
                      var r = n.next().toPolygon(this._geometryFactory);
                      e.add(r);
                    }
                    return e;
                  },
                },
                {
                  key: 'placeFreeHoles',
                  value: function (t, n) {
                    for (var r = n.iterator(); r.hasNext(); ) {
                      var i = r.next();
                      if (null === i.getShell()) {
                        var o = e.findEdgeRingContaining(i, t);
                        if (null === o) throw new gt('unable to assign hole to a shell', i.getCoordinate(0));
                        i.setShell(o);
                      }
                    }
                  },
                },
                {
                  key: 'buildMinimalEdgeRings',
                  value: function (t, e, n) {
                    for (var r = new vt(), i = t.iterator(); i.hasNext(); ) {
                      var o = i.next();
                      if (o.getMaxNodeDegree() > 2) {
                        o.linkDirectedEdgesForMinimalEdgeRings();
                        var a = o.buildMinimalRings(),
                          s = this.findShell(a);
                        null !== s ? (this.placePolygonHoles(s, a), e.add(s)) : n.addAll(a);
                      } else r.add(o);
                    }
                    return r;
                  },
                },
                {
                  key: 'buildMaximalEdgeRings',
                  value: function (t) {
                    for (var e = new vt(), n = t.iterator(); n.hasNext(); ) {
                      var r = n.next();
                      if (r.isInResult() && r.getLabel().isArea() && null === r.getEdgeRing()) {
                        var i = new Fe(r, this._geometryFactory);
                        e.add(i), i.setInResult();
                      }
                    }
                    return e;
                  },
                },
                {
                  key: 'placePolygonHoles',
                  value: function (t, e) {
                    for (var n = e.iterator(); n.hasNext(); ) {
                      var r = n.next();
                      r.isHole() && r.setShell(t);
                    }
                  },
                },
                {
                  key: 'getPolygons',
                  value: function () {
                    return this.computePolygons(this._shellList);
                  },
                },
                {
                  key: 'findShell',
                  value: function (t) {
                    for (var e = 0, n = null, r = t.iterator(); r.hasNext(); ) {
                      var i = r.next();
                      i.isHole() || ((n = i), e++);
                    }
                    return B.isTrue(e <= 1, 'found two shells in MinimalEdgeRing list'), n;
                  },
                },
                {
                  key: 'add',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      this.add(t.getEdgeEnds(), t.getNodes());
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      Ke.linkResultDirectedEdges(n);
                      var r = this.buildMaximalEdgeRings(e),
                        i = new vt(),
                        o = this.buildMinimalEdgeRings(r, this._shellList, i);
                      this.sortShellsAndHoles(o, this._shellList, i), this.placeFreeHoles(this._shellList, i);
                    }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._geometryFactory = null), (this._shellList = new vt());
                    var t = arguments[0];
                    this._geometryFactory = t;
                  },
                },
                {
                  key: 'findEdgeRingContaining',
                  value: function (t, e) {
                    for (
                      var n = t.getLinearRing(),
                        r = n.getEnvelopeInternal(),
                        i = n.getCoordinateN(0),
                        o = null,
                        a = null,
                        s = e.iterator();
                      s.hasNext();

                    ) {
                      var u = s.next(),
                        l = u.getLinearRing(),
                        c = l.getEnvelopeInternal();
                      if (!c.equals(r) && c.contains(r)) {
                        i = Zt.ptNotInList(n.getCoordinates(), l.getCoordinates());
                        var h = !1;
                        Ce.isInRing(i, l.getCoordinates()) && (h = !0),
                          h && (null === o || a.contains(c)) && (a = (o = u).getLinearRing().getEnvelopeInternal());
                      }
                    }
                    return o;
                  },
                },
              ],
            ),
            e
          );
        })(),
        en = (function () {
          function e() {
            t(this, e);
          }
          return r(e, [{ key: 'getBounds', value: function () {} }]), e;
        })(),
        nn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getItem',
                  value: function () {
                    return this._item;
                  },
                },
                {
                  key: 'getBounds',
                  value: function () {
                    return this._bounds;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [en, k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._bounds = null), (this._item = null);
                    var t = arguments[0],
                      e = arguments[1];
                    (this._bounds = t), (this._item = e);
                  },
                },
              ],
            ),
            e
          );
        })(),
        rn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'poll',
                  value: function () {
                    if (this.isEmpty()) return null;
                    var t = this._items.get(1);
                    return this._items.set(1, this._items.get(this._size)), (this._size -= 1), this.reorder(1), t;
                  },
                },
                {
                  key: 'size',
                  value: function () {
                    return this._size;
                  },
                },
                {
                  key: 'reorder',
                  value: function (t) {
                    for (
                      var e = null, n = this._items.get(t);
                      2 * t <= this._size &&
                      ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++,
                      this._items.get(e).compareTo(n) < 0);
                      t = e
                    )
                      this._items.set(t, this._items.get(e));
                    this._items.set(t, n);
                  },
                },
                {
                  key: 'clear',
                  value: function () {
                    (this._size = 0), this._items.clear();
                  },
                },
                {
                  key: 'peek',
                  value: function () {
                    return this.isEmpty() ? null : this._items.get(1);
                  },
                },
                {
                  key: 'isEmpty',
                  value: function () {
                    return 0 === this._size;
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    this._items.add(null), (this._size += 1);
                    var e = this._size;
                    for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2)
                      this._items.set(e, this._items.get(Math.trunc(e / 2)));
                    this._items.set(e, t);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._size = null),
                      (this._items = null),
                      (this._size = 0),
                      (this._items = new vt()),
                      this._items.add(null);
                  },
                },
              ],
            ),
            e
          );
        })(),
        on = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'insert', value: function (t, e) {} },
              { key: 'remove', value: function (t, e) {} },
              { key: 'query', value: function () {} },
            ]),
            e
          );
        })(),
        an = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getLevel',
                  value: function () {
                    return this._level;
                  },
                },
                {
                  key: 'size',
                  value: function () {
                    return this._childBoundables.size();
                  },
                },
                {
                  key: 'getChildBoundables',
                  value: function () {
                    return this._childBoundables;
                  },
                },
                {
                  key: 'addChildBoundable',
                  value: function (t) {
                    B.isTrue(null === this._bounds), this._childBoundables.add(t);
                  },
                },
                {
                  key: 'isEmpty',
                  value: function () {
                    return this._childBoundables.isEmpty();
                  },
                },
                {
                  key: 'getBounds',
                  value: function () {
                    return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [en, k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._childBoundables = new vt()),
                      (this._bounds = null),
                      (this._level = null),
                      0 === arguments.length)
                    );
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      this._level = t;
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        sn = {
          reverseOrder: function () {
            return {
              compare: function (t, e) {
                return e.compareTo(t);
              },
            };
          },
          min: function (t) {
            return sn.sort(t), t.get(0);
          },
          sort: function (t, e) {
            var n = t.toArray();
            e ? At.sort(n, e) : At.sort(n);
            for (var r = t.iterator(), i = 0, o = n.length; i < o; i++) r.next(), r.set(n[i]);
          },
          singletonList: function (t) {
            var e = new vt();
            return e.add(t), e;
          },
        },
        un = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'maxDistance',
                value: function (t, n, r, i, o, a, s, u) {
                  var l = e.distance(t, n, o, a);
                  return (
                    (l = Math.max(l, e.distance(t, n, s, u))),
                    (l = Math.max(l, e.distance(r, i, o, a))),
                    Math.max(l, e.distance(r, i, s, u))
                  );
                },
              },
              {
                key: 'distance',
                value: function (t, e, n, r) {
                  var i = n - t,
                    o = r - e;
                  return Math.sqrt(i * i + o * o);
                },
              },
              {
                key: 'maximumDistance',
                value: function (t, n) {
                  var r = Math.min(t.getMinX(), n.getMinX()),
                    i = Math.min(t.getMinY(), n.getMinY()),
                    o = Math.max(t.getMaxX(), n.getMaxX()),
                    a = Math.max(t.getMaxY(), n.getMaxY());
                  return e.distance(r, i, o, a);
                },
              },
              {
                key: 'minMaxDistance',
                value: function (t, n) {
                  var r = t.getMinX(),
                    i = t.getMinY(),
                    o = t.getMaxX(),
                    a = t.getMaxY(),
                    s = n.getMinX(),
                    u = n.getMinY(),
                    l = n.getMaxX(),
                    c = n.getMaxY(),
                    h = e.maxDistance(r, i, r, a, s, u, s, c);
                  return (
                    (h = Math.min(h, e.maxDistance(r, i, r, a, s, u, l, u))),
                    (h = Math.min(h, e.maxDistance(r, i, r, a, l, c, s, c))),
                    (h = Math.min(h, e.maxDistance(r, i, r, a, l, c, l, u))),
                    (h = Math.min(h, e.maxDistance(r, i, o, i, s, u, s, c))),
                    (h = Math.min(h, e.maxDistance(r, i, o, i, s, u, l, u))),
                    (h = Math.min(h, e.maxDistance(r, i, o, i, l, c, s, c))),
                    (h = Math.min(h, e.maxDistance(r, i, o, i, l, c, l, u))),
                    (h = Math.min(h, e.maxDistance(o, a, r, a, s, u, s, c))),
                    (h = Math.min(h, e.maxDistance(o, a, r, a, s, u, l, u))),
                    (h = Math.min(h, e.maxDistance(o, a, r, a, l, c, s, c))),
                    (h = Math.min(h, e.maxDistance(o, a, r, a, l, c, l, u))),
                    (h = Math.min(h, e.maxDistance(o, a, o, i, s, u, s, c))),
                    (h = Math.min(h, e.maxDistance(o, a, o, i, s, u, l, u))),
                    (h = Math.min(h, e.maxDistance(o, a, o, i, l, c, s, c))),
                    Math.min(h, e.maxDistance(o, a, o, i, l, c, l, u))
                  );
                },
              },
            ]),
            e
          );
        })(),
        ln = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'maximumDistance',
                  value: function () {
                    return un.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
                  },
                },
                {
                  key: 'expandToQueue',
                  value: function (t, n) {
                    var r = e.isComposite(this._boundable1),
                      i = e.isComposite(this._boundable2);
                    if (r && i)
                      return e.area(this._boundable1) > e.area(this._boundable2)
                        ? (this.expand(this._boundable1, this._boundable2, !1, t, n), null)
                        : (this.expand(this._boundable2, this._boundable1, !0, t, n), null);
                    if (r) return this.expand(this._boundable1, this._boundable2, !1, t, n), null;
                    if (i) return this.expand(this._boundable2, this._boundable1, !0, t, n), null;
                    throw new b('neither boundable is composite');
                  },
                },
                {
                  key: 'isLeaves',
                  value: function () {
                    return !(e.isComposite(this._boundable1) || e.isComposite(this._boundable2));
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0;
                  },
                },
                {
                  key: 'expand',
                  value: function (t, n, r, i, o) {
                    for (var a = t.getChildBoundables().iterator(); a.hasNext(); ) {
                      var s = a.next(),
                        u = null;
                      (u = r ? new e(n, s, this._itemDistance) : new e(s, n, this._itemDistance)).getDistance() < o &&
                        i.add(u);
                    }
                  },
                },
                {
                  key: 'getBoundable',
                  value: function (t) {
                    return 0 === t ? this._boundable1 : this._boundable2;
                  },
                },
                {
                  key: 'getDistance',
                  value: function () {
                    return this._distance;
                  },
                },
                {
                  key: 'distance',
                  value: function () {
                    return this.isLeaves()
                      ? this._itemDistance.distance(this._boundable1, this._boundable2)
                      : this._boundable1.getBounds().distance(this._boundable2.getBounds());
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._boundable1 = null),
                      (this._boundable2 = null),
                      (this._distance = null),
                      (this._itemDistance = null);
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2];
                    (this._boundable1 = t),
                      (this._boundable2 = e),
                      (this._itemDistance = n),
                      (this._distance = this.distance());
                  },
                },
                {
                  key: 'area',
                  value: function (t) {
                    return t.getBounds().getArea();
                  },
                },
                {
                  key: 'isComposite',
                  value: function (t) {
                    return t instanceof an;
                  },
                },
              ],
            ),
            e
          );
        })(),
        cn = (function () {
          function e() {
            t(this, e);
          }
          return r(e, [{ key: 'visitItem', value: function (t) {} }]), e;
        })(),
        hn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'queryInternal',
                  value: function () {
                    if (ot(arguments[2], cn) && arguments[0] instanceof Object && arguments[1] instanceof an)
                      for (
                        var t = arguments[0], e = arguments[2], n = arguments[1].getChildBoundables(), r = 0;
                        r < n.size();
                        r++
                      ) {
                        var i = n.get(r);
                        this.getIntersectsOp().intersects(i.getBounds(), t) &&
                          (i instanceof an
                            ? this.queryInternal(t, i, e)
                            : i instanceof nn
                            ? e.visitItem(i.getItem())
                            : B.shouldNeverReachHere());
                      }
                    else if (ot(arguments[2], rt) && arguments[0] instanceof Object && arguments[1] instanceof an)
                      for (
                        var o = arguments[0], a = arguments[2], s = arguments[1].getChildBoundables(), u = 0;
                        u < s.size();
                        u++
                      ) {
                        var l = s.get(u);
                        this.getIntersectsOp().intersects(l.getBounds(), o) &&
                          (l instanceof an
                            ? this.queryInternal(o, l, a)
                            : l instanceof nn
                            ? a.add(l.getItem())
                            : B.shouldNeverReachHere());
                      }
                  },
                },
                {
                  key: 'getNodeCapacity',
                  value: function () {
                    return this._nodeCapacity;
                  },
                },
                {
                  key: 'lastNode',
                  value: function (t) {
                    return t.get(t.size() - 1);
                  },
                },
                {
                  key: 'size',
                  value: function () {
                    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
                    if (1 === arguments.length) {
                      for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext(); ) {
                        var n = e.next();
                        n instanceof an ? (t += this.size(n)) : n instanceof nn && (t += 1);
                      }
                      return t;
                    }
                  },
                },
                {
                  key: 'removeItem',
                  value: function (t, e) {
                    for (var n = null, r = t.getChildBoundables().iterator(); r.hasNext(); ) {
                      var i = r.next();
                      i instanceof nn && i.getItem() === e && (n = i);
                    }
                    return null !== n && (t.getChildBoundables().remove(n), !0);
                  },
                },
                {
                  key: 'itemsTree',
                  value: function () {
                    if (0 === arguments.length) {
                      this.build();
                      var t = this.itemsTree(this._root);
                      return null === t ? new vt() : t;
                    }
                    if (1 === arguments.length) {
                      for (var e = arguments[0], n = new vt(), r = e.getChildBoundables().iterator(); r.hasNext(); ) {
                        var i = r.next();
                        if (i instanceof an) {
                          var o = this.itemsTree(i);
                          null !== o && n.add(o);
                        } else i instanceof nn ? n.add(i.getItem()) : B.shouldNeverReachHere();
                      }
                      return n.size() <= 0 ? null : n;
                    }
                  },
                },
                {
                  key: 'insert',
                  value: function (t, e) {
                    B.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.'),
                      this._itemBoundables.add(new nn(t, e));
                  },
                },
                {
                  key: 'boundablesAtLevel',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0],
                        e = new vt();
                      return this.boundablesAtLevel(t, this._root, e), e;
                    }
                    if (3 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1],
                        i = arguments[2];
                      if ((B.isTrue(n > -2), r.getLevel() === n)) return i.add(r), null;
                      for (var o = r.getChildBoundables().iterator(); o.hasNext(); ) {
                        var a = o.next();
                        a instanceof an
                          ? this.boundablesAtLevel(n, a, i)
                          : (B.isTrue(a instanceof nn), -1 === n && i.add(a));
                      }
                      return null;
                    }
                  },
                },
                {
                  key: 'query',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      this.build();
                      var e = new vt();
                      return (
                        this.isEmpty() ||
                          (this.getIntersectsOp().intersects(this._root.getBounds(), t) &&
                            this.queryInternal(t, this._root, e)),
                        e
                      );
                    }
                    if (2 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1];
                      if ((this.build(), this.isEmpty())) return null;
                      this.getIntersectsOp().intersects(this._root.getBounds(), n) &&
                        this.queryInternal(n, this._root, r);
                    }
                  },
                },
                {
                  key: 'build',
                  value: function () {
                    if (this._built) return null;
                    (this._root = this._itemBoundables.isEmpty()
                      ? this.createNode(0)
                      : this.createHigherLevels(this._itemBoundables, -1)),
                      (this._itemBoundables = null),
                      (this._built = !0);
                  },
                },
                {
                  key: 'getRoot',
                  value: function () {
                    return this.build(), this._root;
                  },
                },
                {
                  key: 'remove',
                  value: function () {
                    if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1];
                      return (
                        this.build(),
                        !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e)
                      );
                    }
                    if (3 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1],
                        i = arguments[2],
                        o = this.removeItem(r, i);
                      if (o) return !0;
                      for (var a = null, s = r.getChildBoundables().iterator(); s.hasNext(); ) {
                        var u = s.next();
                        if (
                          this.getIntersectsOp().intersects(u.getBounds(), n) &&
                          u instanceof an &&
                          (o = this.remove(n, u, i))
                        ) {
                          a = u;
                          break;
                        }
                      }
                      return null !== a && a.getChildBoundables().isEmpty() && r.getChildBoundables().remove(a), o;
                    }
                  },
                },
                {
                  key: 'createHigherLevels',
                  value: function (t, e) {
                    B.isTrue(!t.isEmpty());
                    var n = this.createParentBoundables(t, e + 1);
                    return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1);
                  },
                },
                {
                  key: 'depth',
                  value: function () {
                    if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
                    if (1 === arguments.length) {
                      for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext(); ) {
                        var n = e.next();
                        if (n instanceof an) {
                          var r = this.depth(n);
                          r > t && (t = r);
                        }
                      }
                      return t + 1;
                    }
                  },
                },
                {
                  key: 'createParentBoundables',
                  value: function (t, e) {
                    B.isTrue(!t.isEmpty());
                    var n = new vt();
                    n.add(this.createNode(e));
                    var r = new vt(t);
                    sn.sort(r, this.getComparator());
                    for (var i = r.iterator(); i.hasNext(); ) {
                      var o = i.next();
                      this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() &&
                        n.add(this.createNode(e)),
                        this.lastNode(n).addChildBoundable(o);
                    }
                    return n;
                  },
                },
                {
                  key: 'isEmpty',
                  value: function () {
                    return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._root = null),
                      (this._built = !1),
                      (this._itemBoundables = new vt()),
                      (this._nodeCapacity = null),
                      0 === arguments.length)
                    )
                      e.constructor_.call(this, e.DEFAULT_NODE_CAPACITY);
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      B.isTrue(t > 1, 'Node capacity must be greater than 1'), (this._nodeCapacity = t);
                    }
                  },
                },
                {
                  key: 'compareDoubles',
                  value: function (t, e) {
                    return t > e ? 1 : t < e ? -1 : 0;
                  },
                },
              ],
            ),
            e
          );
        })();
      (hn.IntersectsOp = function () {}), (hn.DEFAULT_NODE_CAPACITY = 10);
      var fn = (function () {
          function e() {
            t(this, e);
          }
          return r(e, [{ key: 'distance', value: function (t, e) {} }]), e;
        })(),
        pn = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'createParentBoundablesFromVerticalSlices',
                  value: function (t, e) {
                    B.isTrue(t.length > 0);
                    for (var n = new vt(), r = 0; r < t.length; r++)
                      n.addAll(this.createParentBoundablesFromVerticalSlice(t[r], e));
                    return n;
                  },
                },
                {
                  key: 'nearestNeighbourK',
                  value: function () {
                    if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1];
                      return this.nearestNeighbourK(t, A.POSITIVE_INFINITY, e);
                    }
                    if (3 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[2],
                        i = arguments[1],
                        o = new rn();
                      o.add(n);
                      for (var s = new rn(); !o.isEmpty() && i >= 0; ) {
                        var u = o.poll(),
                          l = u.getDistance();
                        if (l >= i) break;
                        u.isLeaves()
                          ? s.size() < r
                            ? s.add(u)
                            : (s.peek().getDistance() > l && (s.poll(), s.add(u)), (i = s.peek().getDistance()))
                          : u.expandToQueue(o, i);
                      }
                      return a.getItems(s);
                    }
                  },
                },
                {
                  key: 'createNode',
                  value: function (t) {
                    return new gn(t);
                  },
                },
                {
                  key: 'size',
                  value: function () {
                    return 0 === arguments.length
                      ? p(o(a.prototype), 'size', this).call(this)
                      : p(o(a.prototype), 'size', this).apply(this, arguments);
                  },
                },
                {
                  key: 'insert',
                  value: function () {
                    if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U))
                      return p(o(a.prototype), 'insert', this).apply(this, arguments);
                    var t = arguments[0],
                      e = arguments[1];
                    if (t.isNull()) return null;
                    p(o(a.prototype), 'insert', this).call(this, t, e);
                  },
                },
                {
                  key: 'getIntersectsOp',
                  value: function () {
                    return a.intersectsOp;
                  },
                },
                {
                  key: 'verticalSlices',
                  value: function (t, e) {
                    for (
                      var n = Math.trunc(Math.ceil(t.size() / e)), r = new Array(e).fill(null), i = t.iterator(), o = 0;
                      o < e;
                      o++
                    ) {
                      r[o] = new vt();
                      for (var a = 0; i.hasNext() && a < n; ) {
                        var s = i.next();
                        r[o].add(s), a++;
                      }
                    }
                    return r;
                  },
                },
                {
                  key: 'query',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      return p(o(a.prototype), 'query', this).call(this, t);
                    }
                    if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      p(o(a.prototype), 'query', this).call(this, e, n);
                    }
                  },
                },
                {
                  key: 'getComparator',
                  value: function () {
                    return a.yComparator;
                  },
                },
                {
                  key: 'createParentBoundablesFromVerticalSlice',
                  value: function (t, e) {
                    return p(o(a.prototype), 'createParentBoundables', this).call(this, t, e);
                  },
                },
                {
                  key: 'remove',
                  value: function () {
                    if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U) {
                      var t = arguments[0],
                        e = arguments[1];
                      return p(o(a.prototype), 'remove', this).call(this, t, e);
                    }
                    return p(o(a.prototype), 'remove', this).apply(this, arguments);
                  },
                },
                {
                  key: 'depth',
                  value: function () {
                    return 0 === arguments.length
                      ? p(o(a.prototype), 'depth', this).call(this)
                      : p(o(a.prototype), 'depth', this).apply(this, arguments);
                  },
                },
                {
                  key: 'createParentBoundables',
                  value: function (t, e) {
                    B.isTrue(!t.isEmpty());
                    var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())),
                      r = new vt(t);
                    sn.sort(r, a.xComparator);
                    var i = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(n))));
                    return this.createParentBoundablesFromVerticalSlices(i, e);
                  },
                },
                {
                  key: 'nearestNeighbour',
                  value: function () {
                    if (1 === arguments.length) {
                      if (ot(arguments[0], fn)) {
                        var t = arguments[0];
                        if (this.isEmpty()) return null;
                        var e = new ln(this.getRoot(), this.getRoot(), t);
                        return this.nearestNeighbour(e);
                      }
                      if (arguments[0] instanceof ln) {
                        var n = arguments[0],
                          r = A.POSITIVE_INFINITY,
                          i = null,
                          o = new rn();
                        for (o.add(n); !o.isEmpty() && r > 0; ) {
                          var a = o.poll(),
                            s = a.getDistance();
                          if (s >= r) break;
                          a.isLeaves() ? ((r = s), (i = a)) : a.expandToQueue(o, r);
                        }
                        return null === i ? null : [i.getBoundable(0).getItem(), i.getBoundable(1).getItem()];
                      }
                    } else {
                      if (2 === arguments.length) {
                        var u = arguments[0],
                          l = arguments[1];
                        if (this.isEmpty() || u.isEmpty()) return null;
                        var c = new ln(this.getRoot(), u.getRoot(), l);
                        return this.nearestNeighbour(c);
                      }
                      if (3 === arguments.length) {
                        var h = arguments[2],
                          f = new nn(arguments[0], arguments[1]),
                          p = new ln(this.getRoot(), f, h);
                        return this.nearestNeighbour(p)[0];
                      }
                      if (4 === arguments.length) {
                        var g = arguments[2],
                          y = arguments[3],
                          v = new nn(arguments[0], arguments[1]),
                          d = new ln(this.getRoot(), v, g);
                        return this.nearestNeighbourK(d, y);
                      }
                    }
                  },
                },
                {
                  key: 'isWithinDistance',
                  value: function () {
                    if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1],
                        n = A.POSITIVE_INFINITY,
                        r = new rn();
                      for (r.add(t); !r.isEmpty(); ) {
                        var i = r.poll(),
                          o = i.getDistance();
                        if (o > e) return !1;
                        if (i.maximumDistance() <= e) return !0;
                        if (i.isLeaves()) {
                          if ((n = o) <= e) return !0;
                        } else i.expandToQueue(r, n);
                      }
                      return !1;
                    }
                    if (3 === arguments.length) {
                      var a = arguments[0],
                        s = arguments[1],
                        u = arguments[2],
                        l = new ln(this.getRoot(), a.getRoot(), s);
                      return this.isWithinDistance(l, u);
                    }
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [on, k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (0 === arguments.length) a.constructor_.call(this, a.DEFAULT_NODE_CAPACITY);
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      hn.constructor_.call(this, t);
                    }
                  },
                },
                {
                  key: 'centreX',
                  value: function (t) {
                    return a.avg(t.getMinX(), t.getMaxX());
                  },
                },
                {
                  key: 'avg',
                  value: function (t, e) {
                    return (t + e) / 2;
                  },
                },
                {
                  key: 'getItems',
                  value: function (t) {
                    for (var e = new Array(t.size()).fill(null), n = 0; !t.isEmpty(); ) {
                      var r = t.poll();
                      (e[n] = r.getBoundable(0).getItem()), n++;
                    }
                    return e;
                  },
                },
                {
                  key: 'centreY',
                  value: function (t) {
                    return a.avg(t.getMinY(), t.getMaxY());
                  },
                },
              ],
            ),
            a
          );
        })(hn),
        gn = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              o,
              [
                {
                  key: 'computeBounds',
                  value: function () {
                    for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext(); ) {
                      var n = e.next();
                      null === t ? (t = new U(n.getBounds())) : t.expandToInclude(n.getBounds());
                    }
                    return t;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    var t = arguments[0];
                    an.constructor_.call(this, t);
                  },
                },
              ],
            ),
            o
          );
        })(an);
      (pn.STRtreeNode = gn),
        (pn.xComparator = new ((function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              {
                key: 'interfaces_',
                get: function () {
                  return [D];
                },
              },
              {
                key: 'compare',
                value: function (t, e) {
                  return hn.compareDoubles(pn.centreX(t.getBounds()), pn.centreX(e.getBounds()));
                },
              },
            ]),
            e
          );
        })())()),
        (pn.yComparator = new ((function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              {
                key: 'interfaces_',
                get: function () {
                  return [D];
                },
              },
              {
                key: 'compare',
                value: function (t, e) {
                  return hn.compareDoubles(pn.centreY(t.getBounds()), pn.centreY(e.getBounds()));
                },
              },
            ]),
            e
          );
        })())()),
        (pn.intersectsOp = new ((function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              {
                key: 'interfaces_',
                get: function () {
                  return [IntersectsOp];
                },
              },
              {
                key: 'intersects',
                value: function (t, e) {
                  return t.intersects(e);
                },
              },
            ]),
            e
          );
        })())()),
        (pn.DEFAULT_NODE_CAPACITY = 10);
      var yn = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'relativeSign',
                value: function (t, e) {
                  return t < e ? -1 : t > e ? 1 : 0;
                },
              },
              {
                key: 'compare',
                value: function (t, n, r) {
                  if (n.equals2D(r)) return 0;
                  var i = e.relativeSign(n.x, r.x),
                    o = e.relativeSign(n.y, r.y);
                  switch (t) {
                    case 0:
                      return e.compareValue(i, o);
                    case 1:
                      return e.compareValue(o, i);
                    case 2:
                      return e.compareValue(o, -i);
                    case 3:
                      return e.compareValue(-i, o);
                    case 4:
                      return e.compareValue(-i, -o);
                    case 5:
                      return e.compareValue(-o, -i);
                    case 6:
                      return e.compareValue(-o, i);
                    case 7:
                      return e.compareValue(i, -o);
                  }
                  return B.shouldNeverReachHere('invalid octant value'), 0;
                },
              },
              {
                key: 'compareValue',
                value: function (t, e) {
                  return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0;
                },
              },
            ]),
            e
          );
        })(),
        vn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getCoordinate',
                  value: function () {
                    return this.coord;
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    t.print(this.coord), t.print(' seg # = ' + this.segmentIndex);
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    return this.segmentIndex < e.segmentIndex
                      ? -1
                      : this.segmentIndex > e.segmentIndex
                      ? 1
                      : this.coord.equals2D(e.coord)
                      ? 0
                      : this._isInterior
                      ? e._isInterior
                        ? yn.compare(this._segmentOctant, this.coord, e.coord)
                        : 1
                      : -1;
                  },
                },
                {
                  key: 'isEndPoint',
                  value: function (t) {
                    return (0 === this.segmentIndex && !this._isInterior) || this.segmentIndex === t;
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return this.segmentIndex + ':' + this.coord.toString();
                  },
                },
                {
                  key: 'isInterior',
                  value: function () {
                    return this._isInterior;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._segString = null),
                      (this.coord = null),
                      (this.segmentIndex = null),
                      (this._segmentOctant = null),
                      (this._isInterior = null);
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2],
                      r = arguments[3];
                    (this._segString = t),
                      (this.coord = new Y(e)),
                      (this.segmentIndex = n),
                      (this._segmentOctant = r),
                      (this._isInterior = !e.equals2D(t.getCoordinate(n)));
                  },
                },
              ],
            ),
            e
          );
        })(),
        dn = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'hasNext', value: function () {} },
              { key: 'next', value: function () {} },
              { key: 'remove', value: function () {} },
            ]),
            e
          );
        })(),
        mn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getSplitCoordinates',
                  value: function () {
                    var t = new Ht();
                    this.addEndpoints();
                    for (var e = this.iterator(), n = e.next(); e.hasNext(); ) {
                      var r = e.next();
                      this.addEdgeCoordinates(n, r, t), (n = r);
                    }
                    return t.toCoordinateArray();
                  },
                },
                {
                  key: 'addCollapsedNodes',
                  value: function () {
                    var t = new vt();
                    this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
                    for (var e = t.iterator(); e.hasNext(); ) {
                      var n = e.next().intValue();
                      this.add(this._edge.getCoordinate(n), n);
                    }
                  },
                },
                {
                  key: 'createSplitEdgePts',
                  value: function (t, e) {
                    var n = e.segmentIndex - t.segmentIndex + 2;
                    if (2 === n) return [new Y(t.coord), new Y(e.coord)];
                    var r = this._edge.getCoordinate(e.segmentIndex),
                      i = e.isInterior() || !e.coord.equals2D(r);
                    i || n--;
                    var o = new Array(n).fill(null),
                      a = 0;
                    o[a++] = new Y(t.coord);
                    for (var s = t.segmentIndex + 1; s <= e.segmentIndex; s++) o[a++] = this._edge.getCoordinate(s);
                    return i && (o[a] = new Y(e.coord)), o;
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    t.println('Intersections:');
                    for (var e = this.iterator(); e.hasNext(); ) e.next().print(t);
                  },
                },
                {
                  key: 'findCollapsesFromExistingVertices',
                  value: function (t) {
                    for (var e = 0; e < this._edge.size() - 2; e++) {
                      var n = this._edge.getCoordinate(e);
                      this._edge.getCoordinate(e + 1);
                      var r = this._edge.getCoordinate(e + 2);
                      n.equals2D(r) && t.add(st.valueOf(e + 1));
                    }
                  },
                },
                {
                  key: 'addEdgeCoordinates',
                  value: function (t, e, n) {
                    var r = this.createSplitEdgePts(t, e);
                    n.add(r, !1);
                  },
                },
                {
                  key: 'iterator',
                  value: function () {
                    return this._nodeMap.values().iterator();
                  },
                },
                {
                  key: 'addSplitEdges',
                  value: function (t) {
                    this.addEndpoints(), this.addCollapsedNodes();
                    for (var e = this.iterator(), n = e.next(); e.hasNext(); ) {
                      var r = e.next(),
                        i = this.createSplitEdge(n, r);
                      t.add(i), (n = r);
                    }
                  },
                },
                {
                  key: 'findCollapseIndex',
                  value: function (t, e, n) {
                    if (!t.coord.equals2D(e.coord)) return !1;
                    var r = e.segmentIndex - t.segmentIndex;
                    return e.isInterior() || r--, 1 === r && ((n[0] = t.segmentIndex + 1), !0);
                  },
                },
                {
                  key: 'findCollapsesFromInsertedNodes',
                  value: function (t) {
                    for (var e = new Array(1).fill(null), n = this.iterator(), r = n.next(); n.hasNext(); ) {
                      var i = n.next();
                      this.findCollapseIndex(r, i, e) && t.add(st.valueOf(e[0])), (r = i);
                    }
                  },
                },
                {
                  key: 'getEdge',
                  value: function () {
                    return this._edge;
                  },
                },
                {
                  key: 'addEndpoints',
                  value: function () {
                    var t = this._edge.size() - 1;
                    this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t);
                  },
                },
                {
                  key: 'createSplitEdge',
                  value: function (t, e) {
                    var n = this.createSplitEdgePts(t, e);
                    return new En(n, this._edge.getData());
                  },
                },
                {
                  key: 'add',
                  value: function (t, e) {
                    var n = new vn(this._edge, t, e, this._edge.getSegmentOctant(e)),
                      r = this._nodeMap.get(n);
                    return null !== r
                      ? (B.isTrue(r.coord.equals2D(t), 'Found equal nodes with different coordinates'), r)
                      : (this._nodeMap.put(n, n), n);
                  },
                },
                {
                  key: 'checkSplitEdgesCorrectness',
                  value: function (t) {
                    var e = this._edge.getCoordinates(),
                      n = t.get(0).getCoordinate(0);
                    if (!n.equals2D(e[0])) throw new j('bad split edge start point at ' + n);
                    var r = t.get(t.size() - 1).getCoordinates(),
                      i = r[r.length - 1];
                    if (!i.equals2D(e[e.length - 1])) throw new j('bad split edge end point at ' + i);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._nodeMap = new We()), (this._edge = null);
                    var t = arguments[0];
                    this._edge = t;
                  },
                },
              ],
            ),
            e
          );
        })(),
        _n = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'octant',
                value: function () {
                  if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
                    var t = arguments[0],
                      n = arguments[1];
                    if (0 === t && 0 === n) throw new b('Cannot compute the octant for point ( ' + t + ', ' + n + ' )');
                    var r = Math.abs(t),
                      i = Math.abs(n);
                    return t >= 0
                      ? n >= 0
                        ? r >= i
                          ? 0
                          : 1
                        : r >= i
                        ? 7
                        : 6
                      : n >= 0
                      ? r >= i
                        ? 3
                        : 2
                      : r >= i
                      ? 4
                      : 5;
                  }
                  if (arguments[0] instanceof Y && arguments[1] instanceof Y) {
                    var o = arguments[0],
                      a = arguments[1],
                      s = a.x - o.x,
                      u = a.y - o.y;
                    if (0 === s && 0 === u) throw new b('Cannot compute the octant for two identical points ' + o);
                    return e.octant(s, u);
                  }
                },
              },
            ]),
            e
          );
        })(),
        bn = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'getCoordinates', value: function () {} },
              { key: 'size', value: function () {} },
              { key: 'getCoordinate', value: function (t) {} },
              { key: 'isClosed', value: function () {} },
              { key: 'setData', value: function (t) {} },
              { key: 'getData', value: function () {} },
            ]),
            e
          );
        })(),
        xn = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'addIntersection', value: function (t, e) {} },
              {
                key: 'interfaces_',
                get: function () {
                  return [bn];
                },
              },
            ]),
            e
          );
        })(),
        En = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getCoordinates',
                  value: function () {
                    return this._pts;
                  },
                },
                {
                  key: 'size',
                  value: function () {
                    return this._pts.length;
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function (t) {
                    return this._pts[t];
                  },
                },
                {
                  key: 'isClosed',
                  value: function () {
                    return this._pts[0].equals(this._pts[this._pts.length - 1]);
                  },
                },
                {
                  key: 'getSegmentOctant',
                  value: function (t) {
                    return t === this._pts.length - 1
                      ? -1
                      : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1));
                  },
                },
                {
                  key: 'setData',
                  value: function (t) {
                    this._data = t;
                  },
                },
                {
                  key: 'safeOctant',
                  value: function (t, e) {
                    return t.equals2D(e) ? 0 : _n.octant(t, e);
                  },
                },
                {
                  key: 'getData',
                  value: function () {
                    return this._data;
                  },
                },
                {
                  key: 'addIntersection',
                  value: function () {
                    if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1];
                      this.addIntersectionNode(t, e);
                    } else if (4 === arguments.length) {
                      var n = arguments[1],
                        r = arguments[3],
                        i = new Y(arguments[0].getIntersection(r));
                      this.addIntersection(i, n);
                    }
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return Me.toLineString(new Kt(this._pts));
                  },
                },
                {
                  key: 'getNodeList',
                  value: function () {
                    return this._nodeList;
                  },
                },
                {
                  key: 'addIntersectionNode',
                  value: function (t, e) {
                    var n = e,
                      r = n + 1;
                    if (r < this._pts.length) {
                      var i = this._pts[r];
                      t.equals2D(i) && (n = r);
                    }
                    return this._nodeList.add(t, n);
                  },
                },
                {
                  key: 'addIntersections',
                  value: function (t, e, n) {
                    for (var r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r);
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [xn];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._nodeList = new mn(this)), (this._pts = null), (this._data = null);
                    var t = arguments[0],
                      e = arguments[1];
                    (this._pts = t), (this._data = e);
                  },
                },
                {
                  key: 'getNodedSubstrings',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0],
                        n = new vt();
                      return e.getNodedSubstrings(t, n), n;
                    }
                    if (2 === arguments.length)
                      for (var r = arguments[1], i = arguments[0].iterator(); i.hasNext(); )
                        i.next().getNodeList().addSplitEdges(r);
                  },
                },
              ],
            ),
            e
          );
        })(),
        wn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'minX',
                  value: function () {
                    return Math.min(this.p0.x, this.p1.x);
                  },
                },
                {
                  key: 'orientationIndex',
                  value: function () {
                    if (arguments[0] instanceof e) {
                      var t = arguments[0],
                        n = ft.index(this.p0, this.p1, t.p0),
                        r = ft.index(this.p0, this.p1, t.p1);
                      return (n >= 0 && r >= 0) || (n <= 0 && r <= 0) ? Math.max(n, r) : 0;
                    }
                    if (arguments[0] instanceof Y) {
                      var i = arguments[0];
                      return ft.index(this.p0, this.p1, i);
                    }
                  },
                },
                {
                  key: 'toGeometry',
                  value: function (t) {
                    return t.createLineString([this.p0, this.p1]);
                  },
                },
                {
                  key: 'isVertical',
                  value: function () {
                    return this.p0.x === this.p1.x;
                  },
                },
                {
                  key: 'equals',
                  value: function (t) {
                    if (!(t instanceof e)) return !1;
                    var n = t;
                    return this.p0.equals(n.p0) && this.p1.equals(n.p1);
                  },
                },
                {
                  key: 'intersection',
                  value: function (t) {
                    var e = new Le();
                    return (
                      e.computeIntersection(this.p0, this.p1, t.p0, t.p1),
                      e.hasIntersection() ? e.getIntersection(0) : null
                    );
                  },
                },
                {
                  key: 'project',
                  value: function () {
                    if (arguments[0] instanceof Y) {
                      var t = arguments[0];
                      if (t.equals(this.p0) || t.equals(this.p1)) return new Y(t);
                      var n = this.projectionFactor(t),
                        r = new Y();
                      return (
                        (r.x = this.p0.x + n * (this.p1.x - this.p0.x)),
                        (r.y = this.p0.y + n * (this.p1.y - this.p0.y)),
                        r
                      );
                    }
                    if (arguments[0] instanceof e) {
                      var i = arguments[0],
                        o = this.projectionFactor(i.p0),
                        a = this.projectionFactor(i.p1);
                      if (o >= 1 && a >= 1) return null;
                      if (o <= 0 && a <= 0) return null;
                      var s = this.project(i.p0);
                      o < 0 && (s = this.p0), o > 1 && (s = this.p1);
                      var u = this.project(i.p1);
                      return a < 0 && (u = this.p0), a > 1 && (u = this.p1), new e(s, u);
                    }
                  },
                },
                {
                  key: 'normalize',
                  value: function () {
                    this.p1.compareTo(this.p0) < 0 && this.reverse();
                  },
                },
                {
                  key: 'angle',
                  value: function () {
                    return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function (t) {
                    return 0 === t ? this.p0 : this.p1;
                  },
                },
                {
                  key: 'distancePerpendicular',
                  value: function (t) {
                    return Et.pointToLinePerpendicular(t, this.p0, this.p1);
                  },
                },
                {
                  key: 'minY',
                  value: function () {
                    return Math.min(this.p0.y, this.p1.y);
                  },
                },
                {
                  key: 'midPoint',
                  value: function () {
                    return e.midPoint(this.p0, this.p1);
                  },
                },
                {
                  key: 'projectionFactor',
                  value: function (t) {
                    if (t.equals(this.p0)) return 0;
                    if (t.equals(this.p1)) return 1;
                    var e = this.p1.x - this.p0.x,
                      n = this.p1.y - this.p0.y,
                      r = e * e + n * n;
                    return r <= 0 ? A.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / r;
                  },
                },
                {
                  key: 'closestPoints',
                  value: function (t) {
                    var e = this.intersection(t);
                    if (null !== e) return [e, e];
                    var n = new Array(2).fill(null),
                      r = A.MAX_VALUE,
                      i = null,
                      o = this.closestPoint(t.p0);
                    (r = o.distance(t.p0)), (n[0] = o), (n[1] = t.p0);
                    var a = this.closestPoint(t.p1);
                    (i = a.distance(t.p1)) < r && ((r = i), (n[0] = a), (n[1] = t.p1));
                    var s = t.closestPoint(this.p0);
                    (i = s.distance(this.p0)) < r && ((r = i), (n[0] = this.p0), (n[1] = s));
                    var u = t.closestPoint(this.p1);
                    return (i = u.distance(this.p1)) < r && ((r = i), (n[0] = this.p1), (n[1] = u)), n;
                  },
                },
                {
                  key: 'closestPoint',
                  value: function (t) {
                    var e = this.projectionFactor(t);
                    return e > 0 && e < 1
                      ? this.project(t)
                      : this.p0.distance(t) < this.p1.distance(t)
                      ? this.p0
                      : this.p1;
                  },
                },
                {
                  key: 'maxX',
                  value: function () {
                    return Math.max(this.p0.x, this.p1.x);
                  },
                },
                {
                  key: 'getLength',
                  value: function () {
                    return this.p0.distance(this.p1);
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t,
                      n = this.p0.compareTo(e.p0);
                    return 0 !== n ? n : this.p1.compareTo(e.p1);
                  },
                },
                {
                  key: 'reverse',
                  value: function () {
                    var t = this.p0;
                    (this.p0 = this.p1), (this.p1 = t);
                  },
                },
                {
                  key: 'equalsTopo',
                  value: function (t) {
                    return (
                      (this.p0.equals(t.p0) && this.p1.equals(t.p1)) || (this.p0.equals(t.p1) && this.p1.equals(t.p0))
                    );
                  },
                },
                {
                  key: 'lineIntersection',
                  value: function (t) {
                    return _t.intersection(this.p0, this.p1, t.p0, t.p1);
                  },
                },
                {
                  key: 'maxY',
                  value: function () {
                    return Math.max(this.p0.y, this.p1.y);
                  },
                },
                {
                  key: 'pointAlongOffset',
                  value: function (t, e) {
                    var n = this.p0.x + t * (this.p1.x - this.p0.x),
                      r = this.p0.y + t * (this.p1.y - this.p0.y),
                      i = this.p1.x - this.p0.x,
                      o = this.p1.y - this.p0.y,
                      a = Math.sqrt(i * i + o * o),
                      s = 0,
                      u = 0;
                    if (0 !== e) {
                      if (a <= 0)
                        throw new IllegalStateException('Cannot compute offset from zero-length line segment');
                      (s = (e * i) / a), (u = (e * o) / a);
                    }
                    return new Y(n - u, r + s);
                  },
                },
                {
                  key: 'setCoordinates',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      this.setCoordinates(t.p0, t.p1);
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      (this.p0.x = e.x), (this.p0.y = e.y), (this.p1.x = n.x), (this.p1.y = n.y);
                    }
                  },
                },
                {
                  key: 'segmentFraction',
                  value: function (t) {
                    var e = this.projectionFactor(t);
                    return e < 0 ? (e = 0) : (e > 1 || A.isNaN(e)) && (e = 1), e;
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')';
                  },
                },
                {
                  key: 'isHorizontal',
                  value: function () {
                    return this.p0.y === this.p1.y;
                  },
                },
                {
                  key: 'reflect',
                  value: function (t) {
                    var e = this.p1.getY() - this.p0.getY(),
                      n = this.p0.getX() - this.p1.getX(),
                      r =
                        this.p0.getY() * (this.p1.getX() - this.p0.getX()) -
                        this.p0.getX() * (this.p1.getY() - this.p0.getY()),
                      i = e * e + n * n,
                      o = e * e - n * n,
                      a = t.getX(),
                      s = t.getY();
                    return new Y((-o * a - 2 * e * n * s - 2 * e * r) / i, (o * s - 2 * e * n * a - 2 * n * r) / i);
                  },
                },
                {
                  key: 'distance',
                  value: function () {
                    if (arguments[0] instanceof e) {
                      var t = arguments[0];
                      return Et.segmentToSegment(this.p0, this.p1, t.p0, t.p1);
                    }
                    if (arguments[0] instanceof Y) {
                      var n = arguments[0];
                      return Et.pointToSegment(n, this.p0, this.p1);
                    }
                  },
                },
                {
                  key: 'pointAlong',
                  value: function (t) {
                    var e = new Y();
                    return (
                      (e.x = this.p0.x + t * (this.p1.x - this.p0.x)),
                      (e.y = this.p0.y + t * (this.p1.y - this.p0.y)),
                      e
                    );
                  },
                },
                {
                  key: 'hashCode',
                  value: function () {
                    var t = A.doubleToLongBits(this.p0.x);
                    t ^= 31 * A.doubleToLongBits(this.p0.y);
                    var e = Math.trunc(t) ^ Math.trunc(t >> 32),
                      n = A.doubleToLongBits(this.p1.x);
                    return (n ^= 31 * A.doubleToLongBits(this.p1.y)), e ^ Math.trunc(n) ^ Math.trunc(n >> 32);
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E, k];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this.p0 = null), (this.p1 = null), 0 === arguments.length))
                      e.constructor_.call(this, new Y(), new Y());
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      e.constructor_.call(this, t.p0, t.p1);
                    } else if (2 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1];
                      (this.p0 = n), (this.p1 = r);
                    } else if (4 === arguments.length) {
                      var i = arguments[0],
                        o = arguments[1],
                        a = arguments[2],
                        s = arguments[3];
                      e.constructor_.call(this, new Y(i, o), new Y(a, s));
                    }
                  },
                },
                {
                  key: 'midPoint',
                  value: function (t, e) {
                    return new Y((t.x + e.x) / 2, (t.y + e.y) / 2);
                  },
                },
              ],
            ),
            e
          );
        })(),
        kn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'overlap',
                  value: function () {
                    if (2 === arguments.length);
                    else if (4 === arguments.length) {
                      var t = arguments[1],
                        e = arguments[2],
                        n = arguments[3];
                      arguments[0].getLineSegment(t, this._overlapSeg1),
                        e.getLineSegment(n, this._overlapSeg2),
                        this.overlap(this._overlapSeg1, this._overlapSeg2);
                    }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._overlapSeg1 = new wn()), (this._overlapSeg2 = new wn());
                  },
                },
              ],
            ),
            e
          );
        })(),
        Sn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getLineSegment',
                  value: function (t, e) {
                    (e.p0 = this._pts[t]), (e.p1 = this._pts[t + 1]);
                  },
                },
                {
                  key: 'computeSelect',
                  value: function (t, e, n, r) {
                    var i = this._pts[e],
                      o = this._pts[n];
                    if (n - e == 1) return r.select(this, e), null;
                    if (!t.intersects(i, o)) return null;
                    var a = Math.trunc((e + n) / 2);
                    e < a && this.computeSelect(t, e, a, r), a < n && this.computeSelect(t, a, n, r);
                  },
                },
                {
                  key: 'getCoordinates',
                  value: function () {
                    for (
                      var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start;
                      n <= this._end;
                      n++
                    )
                      t[e++] = this._pts[n];
                    return t;
                  },
                },
                {
                  key: 'computeOverlaps',
                  value: function () {
                    if (2 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1];
                      this.computeOverlaps(this._start, this._end, t, t._start, t._end, e);
                    } else if (6 === arguments.length) {
                      var n = arguments[0],
                        r = arguments[1],
                        i = arguments[2],
                        o = arguments[3],
                        a = arguments[4],
                        s = arguments[5];
                      if (r - n == 1 && a - o == 1) return s.overlap(this, n, i, o), null;
                      if (!this.overlaps(n, r, i, o, a)) return null;
                      var u = Math.trunc((n + r) / 2),
                        l = Math.trunc((o + a) / 2);
                      n < u &&
                        (o < l && this.computeOverlaps(n, u, i, o, l, s),
                        l < a && this.computeOverlaps(n, u, i, l, a, s)),
                        u < r &&
                          (o < l && this.computeOverlaps(u, r, i, o, l, s),
                          l < a && this.computeOverlaps(u, r, i, l, a, s));
                    }
                  },
                },
                {
                  key: 'setId',
                  value: function (t) {
                    this._id = t;
                  },
                },
                {
                  key: 'select',
                  value: function (t, e) {
                    this.computeSelect(t, this._start, this._end, e);
                  },
                },
                {
                  key: 'getEnvelope',
                  value: function () {
                    if (null === this._env) {
                      var t = this._pts[this._start],
                        e = this._pts[this._end];
                      this._env = new U(t, e);
                    }
                    return this._env;
                  },
                },
                {
                  key: 'overlaps',
                  value: function (t, e, n, r, i) {
                    return U.intersects(this._pts[t], this._pts[e], n._pts[r], n._pts[i]);
                  },
                },
                {
                  key: 'getEndIndex',
                  value: function () {
                    return this._end;
                  },
                },
                {
                  key: 'getStartIndex',
                  value: function () {
                    return this._start;
                  },
                },
                {
                  key: 'getContext',
                  value: function () {
                    return this._context;
                  },
                },
                {
                  key: 'getId',
                  value: function () {
                    return this._id;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._pts = null),
                      (this._start = null),
                      (this._end = null),
                      (this._env = null),
                      (this._context = null),
                      (this._id = null);
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2],
                      r = arguments[3];
                    (this._pts = t), (this._start = e), (this._end = n), (this._context = r);
                  },
                },
              ],
            ),
            e
          );
        })(),
        In = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, null, [
              {
                key: 'findChainEnd',
                value: function (t, e) {
                  for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]); ) n++;
                  if (n >= t.length - 1) return t.length - 1;
                  for (
                    var r = Ze.quadrant(t[n], t[n + 1]), i = e + 1;
                    i < t.length && (t[i - 1].equals2D(t[i]) || Ze.quadrant(t[i - 1], t[i]) === r);

                  )
                    i++;
                  return i - 1;
                },
              },
              {
                key: 'getChains',
                value: function () {
                  if (1 === arguments.length) {
                    var t = arguments[0];
                    return e.getChains(t, null);
                  }
                  if (2 === arguments.length) {
                    var n = arguments[0],
                      r = arguments[1],
                      i = new vt(),
                      o = 0;
                    do {
                      var a = e.findChainEnd(n, o),
                        s = new Sn(n, o, a, r);
                      i.add(s), (o = a);
                    } while (o < n.length - 1);
                    return i;
                  }
                },
              },
            ]),
            e
          );
        })(),
        Pn = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'computeNodes', value: function (t) {} },
              { key: 'getNodedSubstrings', value: function () {} },
            ]),
            e
          );
        })(),
        Nn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'setSegmentIntersector',
                  value: function (t) {
                    this._segInt = t;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Pn];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._segInt = null), 0 === arguments.length));
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      this.setSegmentIntersector(t);
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        Mn = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              o,
              [
                {
                  key: 'getMonotoneChains',
                  value: function () {
                    return this._monoChains;
                  },
                },
                {
                  key: 'getNodedSubstrings',
                  value: function () {
                    return En.getNodedSubstrings(this._nodedSegStrings);
                  },
                },
                {
                  key: 'getIndex',
                  value: function () {
                    return this._index;
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    for (var e = In.getChains(t.getCoordinates(), t).iterator(); e.hasNext(); ) {
                      var n = e.next();
                      n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n);
                    }
                  },
                },
                {
                  key: 'computeNodes',
                  value: function (t) {
                    this._nodedSegStrings = t;
                    for (var e = t.iterator(); e.hasNext(); ) this.add(e.next());
                    this.intersectChains();
                  },
                },
                {
                  key: 'intersectChains',
                  value: function () {
                    for (var t = new On(this._segInt), e = this._monoChains.iterator(); e.hasNext(); )
                      for (var n = e.next(), r = this._index.query(n.getEnvelope()).iterator(); r.hasNext(); ) {
                        var i = r.next();
                        if (
                          (i.getId() > n.getId() && (n.computeOverlaps(i, t), this._nOverlaps++), this._segInt.isDone())
                        )
                          return null;
                      }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._monoChains = new vt()),
                      (this._index = new pn()),
                      (this._idCounter = 0),
                      (this._nodedSegStrings = null),
                      (this._nOverlaps = 0),
                      0 === arguments.length)
                    );
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      Nn.constructor_.call(this, t);
                    }
                  },
                },
              ],
            ),
            o
          );
        })(Nn),
        On = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'overlap',
                  value: function () {
                    if (4 !== arguments.length) return p(o(a.prototype), 'overlap', this).apply(this, arguments);
                    var t = arguments[1],
                      e = arguments[2],
                      n = arguments[3],
                      r = arguments[0].getContext(),
                      i = e.getContext();
                    this._si.processIntersections(r, t, i, n);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    this._si = null;
                    var t = arguments[0];
                    this._si = t;
                  },
                },
              ],
            ),
            a
          );
        })(kn);
      Mn.SegmentOverlapAction = On;
      var Ln = (function () {
        function e() {
          t(this, e), e.constructor_.apply(this, arguments);
        }
        return (
          r(
            e,
            [
              {
                key: 'isDeletable',
                value: function (t, e, n, r) {
                  var i = this._inputLine[t],
                    o = this._inputLine[e],
                    a = this._inputLine[n];
                  return (
                    !!this.isConcave(i, o, a) && !!this.isShallow(i, o, a, r) && this.isShallowSampled(i, o, t, n, r)
                  );
                },
              },
              {
                key: 'deleteShallowConcavities',
                value: function () {
                  for (
                    var t = 1, n = this.findNextNonDeletedIndex(t), r = this.findNextNonDeletedIndex(n), i = !1;
                    r < this._inputLine.length;

                  ) {
                    var o = !1;
                    this.isDeletable(t, n, r, this._distanceTol) &&
                      ((this._isDeleted[n] = e.DELETE), (o = !0), (i = !0)),
                      (t = o ? r : n),
                      (n = this.findNextNonDeletedIndex(t)),
                      (r = this.findNextNonDeletedIndex(n));
                  }
                  return i;
                },
              },
              {
                key: 'isShallowConcavity',
                value: function (t, e, n, r) {
                  return ft.index(t, e, n) === this._angleOrientation && Et.pointToSegment(e, t, n) < r;
                },
              },
              {
                key: 'isShallowSampled',
                value: function (t, n, r, i, o) {
                  var a = Math.trunc((i - r) / e.NUM_PTS_TO_CHECK);
                  a <= 0 && (a = 1);
                  for (var s = r; s < i; s += a) if (!this.isShallow(t, n, this._inputLine[s], o)) return !1;
                  return !0;
                },
              },
              {
                key: 'isConcave',
                value: function (t, e, n) {
                  return ft.index(t, e, n) === this._angleOrientation;
                },
              },
              {
                key: 'simplify',
                value: function (t) {
                  (this._distanceTol = Math.abs(t)),
                    t < 0 && (this._angleOrientation = ft.CLOCKWISE),
                    (this._isDeleted = new Array(this._inputLine.length).fill(null));
                  var e = !1;
                  do {
                    e = this.deleteShallowConcavities();
                  } while (e);
                  return this.collapseLine();
                },
              },
              {
                key: 'findNextNonDeletedIndex',
                value: function (t) {
                  for (var n = t + 1; n < this._inputLine.length && this._isDeleted[n] === e.DELETE; ) n++;
                  return n;
                },
              },
              {
                key: 'isShallow',
                value: function (t, e, n, r) {
                  return Et.pointToSegment(e, t, n) < r;
                },
              },
              {
                key: 'collapseLine',
                value: function () {
                  for (var t = new Ht(), n = 0; n < this._inputLine.length; n++)
                    this._isDeleted[n] !== e.DELETE && t.add(this._inputLine[n]);
                  return t.toCoordinateArray();
                },
              },
            ],
            [
              {
                key: 'constructor_',
                value: function () {
                  (this._inputLine = null),
                    (this._distanceTol = null),
                    (this._isDeleted = null),
                    (this._angleOrientation = ft.COUNTERCLOCKWISE);
                  var t = arguments[0];
                  this._inputLine = t;
                },
              },
              {
                key: 'simplify',
                value: function (t, n) {
                  return new e(t).simplify(n);
                },
              },
            ],
          ),
          e
        );
      })();
      (Ln.INIT = 0), (Ln.DELETE = 1), (Ln.KEEP = 1), (Ln.NUM_PTS_TO_CHECK = 10);
      var Rn = (function () {
        function e() {
          t(this, e), e.constructor_.apply(this, arguments);
        }
        return (
          r(
            e,
            [
              {
                key: 'getCoordinates',
                value: function () {
                  return this._ptList.toArray(e.COORDINATE_ARRAY_TYPE);
                },
              },
              {
                key: 'setPrecisionModel',
                value: function (t) {
                  this._precisionModel = t;
                },
              },
              {
                key: 'addPt',
                value: function (t) {
                  var e = new Y(t);
                  if ((this._precisionModel.makePrecise(e), this.isRedundant(e))) return null;
                  this._ptList.add(e);
                },
              },
              { key: 'reverse', value: function () {} },
              {
                key: 'addPts',
                value: function (t, e) {
                  if (e) for (var n = 0; n < t.length; n++) this.addPt(t[n]);
                  else for (var r = t.length - 1; r >= 0; r--) this.addPt(t[r]);
                },
              },
              {
                key: 'isRedundant',
                value: function (t) {
                  if (this._ptList.size() < 1) return !1;
                  var e = this._ptList.get(this._ptList.size() - 1);
                  return t.distance(e) < this._minimimVertexDistance;
                },
              },
              {
                key: 'toString',
                value: function () {
                  return new se().createLineString(this.getCoordinates()).toString();
                },
              },
              {
                key: 'closeRing',
                value: function () {
                  if (this._ptList.size() < 1) return null;
                  var t = new Y(this._ptList.get(0)),
                    e = this._ptList.get(this._ptList.size() - 1);
                  if (t.equals(e)) return null;
                  this._ptList.add(t);
                },
              },
              {
                key: 'setMinimumVertexDistance',
                value: function (t) {
                  this._minimimVertexDistance = t;
                },
              },
            ],
            [
              {
                key: 'constructor_',
                value: function () {
                  (this._ptList = null),
                    (this._precisionModel = null),
                    (this._minimimVertexDistance = 0),
                    (this._ptList = new vt());
                },
              },
            ],
          ),
          e
        );
      })();
      Rn.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
      var Cn = (function () {
        function e() {
          t(this, e);
        }
        return (
          r(e, null, [
            {
              key: 'toDegrees',
              value: function (t) {
                return (180 * t) / Math.PI;
              },
            },
            {
              key: 'normalize',
              value: function (t) {
                for (; t > Math.PI; ) t -= e.PI_TIMES_2;
                for (; t <= -Math.PI; ) t += e.PI_TIMES_2;
                return t;
              },
            },
            {
              key: 'angle',
              value: function () {
                if (1 === arguments.length) {
                  var t = arguments[0];
                  return Math.atan2(t.y, t.x);
                }
                if (2 === arguments.length) {
                  var e = arguments[0],
                    n = arguments[1],
                    r = n.x - e.x,
                    i = n.y - e.y;
                  return Math.atan2(i, r);
                }
              },
            },
            {
              key: 'isAcute',
              value: function (t, e, n) {
                var r = t.x - e.x,
                  i = t.y - e.y;
                return r * (n.x - e.x) + i * (n.y - e.y) > 0;
              },
            },
            {
              key: 'isObtuse',
              value: function (t, e, n) {
                var r = t.x - e.x,
                  i = t.y - e.y;
                return r * (n.x - e.x) + i * (n.y - e.y) < 0;
              },
            },
            {
              key: 'interiorAngle',
              value: function (t, n, r) {
                var i = e.angle(n, t),
                  o = e.angle(n, r);
                return Math.abs(o - i);
              },
            },
            {
              key: 'normalizePositive',
              value: function (t) {
                if (t < 0) {
                  for (; t < 0; ) t += e.PI_TIMES_2;
                  t >= e.PI_TIMES_2 && (t = 0);
                } else {
                  for (; t >= e.PI_TIMES_2; ) t -= e.PI_TIMES_2;
                  t < 0 && (t = 0);
                }
                return t;
              },
            },
            {
              key: 'angleBetween',
              value: function (t, n, r) {
                var i = e.angle(n, t),
                  o = e.angle(n, r);
                return e.diff(i, o);
              },
            },
            {
              key: 'diff',
              value: function (t, e) {
                var n = null;
                return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n;
              },
            },
            {
              key: 'toRadians',
              value: function (t) {
                return (t * Math.PI) / 180;
              },
            },
            {
              key: 'getTurn',
              value: function (t, n) {
                var r = Math.sin(n - t);
                return r > 0 ? e.COUNTERCLOCKWISE : r < 0 ? e.CLOCKWISE : e.NONE;
              },
            },
            {
              key: 'angleBetweenOriented',
              value: function (t, n, r) {
                var i = e.angle(n, t),
                  o = e.angle(n, r) - i;
                return o <= -Math.PI ? o + e.PI_TIMES_2 : o > Math.PI ? o - e.PI_TIMES_2 : o;
              },
            },
          ]),
          e
        );
      })();
      (Cn.PI_TIMES_2 = 2 * Math.PI),
        (Cn.PI_OVER_2 = Math.PI / 2),
        (Cn.PI_OVER_4 = Math.PI / 4),
        (Cn.COUNTERCLOCKWISE = ft.COUNTERCLOCKWISE),
        (Cn.CLOCKWISE = ft.CLOCKWISE),
        (Cn.NONE = ft.COLLINEAR);
      var Tn = (function () {
        function e() {
          t(this, e), e.constructor_.apply(this, arguments);
        }
        return (
          r(
            e,
            [
              {
                key: 'addNextSegment',
                value: function (t, e) {
                  if (
                    ((this._s0 = this._s1),
                    (this._s1 = this._s2),
                    (this._s2 = t),
                    this._seg0.setCoordinates(this._s0, this._s1),
                    this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0),
                    this._seg1.setCoordinates(this._s1, this._s2),
                    this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1),
                    this._s1.equals(this._s2))
                  )
                    return null;
                  var n = ft.index(this._s0, this._s1, this._s2),
                    r =
                      (n === ft.CLOCKWISE && this._side === tt.LEFT) ||
                      (n === ft.COUNTERCLOCKWISE && this._side === tt.RIGHT);
                  0 === n ? this.addCollinear(e) : r ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e);
                },
              },
              {
                key: 'addLineEndCap',
                value: function (t, e) {
                  var n = new wn(t, e),
                    r = new wn();
                  this.computeOffsetSegment(n, tt.LEFT, this._distance, r);
                  var i = new wn();
                  this.computeOffsetSegment(n, tt.RIGHT, this._distance, i);
                  var o = e.x - t.x,
                    a = e.y - t.y,
                    s = Math.atan2(a, o);
                  switch (this._bufParams.getEndCapStyle()) {
                    case m.CAP_ROUND:
                      this._segList.addPt(r.p1),
                        this.addDirectedFillet(e, s + Math.PI / 2, s - Math.PI / 2, ft.CLOCKWISE, this._distance),
                        this._segList.addPt(i.p1);
                      break;
                    case m.CAP_FLAT:
                      this._segList.addPt(r.p1), this._segList.addPt(i.p1);
                      break;
                    case m.CAP_SQUARE:
                      var u = new Y();
                      (u.x = Math.abs(this._distance) * Math.cos(s)), (u.y = Math.abs(this._distance) * Math.sin(s));
                      var l = new Y(r.p1.x + u.x, r.p1.y + u.y),
                        c = new Y(i.p1.x + u.x, i.p1.y + u.y);
                      this._segList.addPt(l), this._segList.addPt(c);
                  }
                },
              },
              {
                key: 'getCoordinates',
                value: function () {
                  return this._segList.getCoordinates();
                },
              },
              {
                key: 'addMitreJoin',
                value: function (t, e, n, r) {
                  var i = _t.intersection(e.p0, e.p1, n.p0, n.p1);
                  if (null !== i && (r <= 0 ? 1 : i.distance(t) / Math.abs(r)) <= this._bufParams.getMitreLimit())
                    return this._segList.addPt(i), null;
                  this.addLimitedMitreJoin(e, n, r, this._bufParams.getMitreLimit());
                },
              },
              {
                key: 'addOutsideTurn',
                value: function (t, n) {
                  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * e.OFFSET_SEGMENT_SEPARATION_FACTOR)
                    return this._segList.addPt(this._offset0.p1), null;
                  this._bufParams.getJoinStyle() === m.JOIN_MITRE
                    ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance)
                    : this._bufParams.getJoinStyle() === m.JOIN_BEVEL
                    ? this.addBevelJoin(this._offset0, this._offset1)
                    : (n && this._segList.addPt(this._offset0.p1),
                      this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance),
                      this._segList.addPt(this._offset1.p0));
                },
              },
              {
                key: 'createSquare',
                value: function (t) {
                  this._segList.addPt(new Y(t.x + this._distance, t.y + this._distance)),
                    this._segList.addPt(new Y(t.x + this._distance, t.y - this._distance)),
                    this._segList.addPt(new Y(t.x - this._distance, t.y - this._distance)),
                    this._segList.addPt(new Y(t.x - this._distance, t.y + this._distance)),
                    this._segList.closeRing();
                },
              },
              {
                key: 'addSegments',
                value: function (t, e) {
                  this._segList.addPts(t, e);
                },
              },
              {
                key: 'addFirstSegment',
                value: function () {
                  this._segList.addPt(this._offset1.p0);
                },
              },
              {
                key: 'addCornerFillet',
                value: function (t, e, n, r, i) {
                  var o = e.x - t.x,
                    a = e.y - t.y,
                    s = Math.atan2(a, o),
                    u = n.x - t.x,
                    l = n.y - t.y,
                    c = Math.atan2(l, u);
                  r === ft.CLOCKWISE ? s <= c && (s += 2 * Math.PI) : s >= c && (s -= 2 * Math.PI),
                    this._segList.addPt(e),
                    this.addDirectedFillet(t, s, c, r, i),
                    this._segList.addPt(n);
                },
              },
              {
                key: 'addLastSegment',
                value: function () {
                  this._segList.addPt(this._offset1.p1);
                },
              },
              {
                key: 'initSideSegments',
                value: function (t, e, n) {
                  (this._s1 = t),
                    (this._s2 = e),
                    (this._side = n),
                    this._seg1.setCoordinates(t, e),
                    this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);
                },
              },
              {
                key: 'addLimitedMitreJoin',
                value: function (t, e, n, r) {
                  var i = this._seg0.p1,
                    o = Cn.angle(i, this._seg0.p0),
                    a = Cn.angleBetweenOriented(this._seg0.p0, i, this._seg1.p1) / 2,
                    s = Cn.normalize(o + a),
                    u = Cn.normalize(s + Math.PI),
                    l = r * n,
                    c = n - l * Math.abs(Math.sin(a)),
                    h = i.x + l * Math.cos(u),
                    f = i.y + l * Math.sin(u),
                    p = new Y(h, f),
                    g = new wn(i, p),
                    y = g.pointAlongOffset(1, c),
                    v = g.pointAlongOffset(1, -c);
                  this._side === tt.LEFT
                    ? (this._segList.addPt(y), this._segList.addPt(v))
                    : (this._segList.addPt(v), this._segList.addPt(y));
                },
              },
              {
                key: 'addDirectedFillet',
                value: function (t, e, n, r, i) {
                  var o = r === ft.CLOCKWISE ? -1 : 1,
                    a = Math.abs(e - n),
                    s = Math.trunc(a / this._filletAngleQuantum + 0.5);
                  if (s < 1) return null;
                  for (var u = a / s, l = new Y(), c = 0; c < s; c++) {
                    var h = e + o * c * u;
                    (l.x = t.x + i * Math.cos(h)), (l.y = t.y + i * Math.sin(h)), this._segList.addPt(l);
                  }
                },
              },
              {
                key: 'computeOffsetSegment',
                value: function (t, e, n, r) {
                  var i = e === tt.LEFT ? 1 : -1,
                    o = t.p1.x - t.p0.x,
                    a = t.p1.y - t.p0.y,
                    s = Math.sqrt(o * o + a * a),
                    u = (i * n * o) / s,
                    l = (i * n * a) / s;
                  (r.p0.x = t.p0.x - l), (r.p0.y = t.p0.y + u), (r.p1.x = t.p1.x - l), (r.p1.y = t.p1.y + u);
                },
              },
              {
                key: 'addInsideTurn',
                value: function (t, n) {
                  if (
                    (this._li.computeIntersection(
                      this._offset0.p0,
                      this._offset0.p1,
                      this._offset1.p0,
                      this._offset1.p1,
                    ),
                    this._li.hasIntersection())
                  )
                    this._segList.addPt(this._li.getIntersection(0));
                  else if (
                    ((this._hasNarrowConcaveAngle = !0),
                    this._offset0.p1.distance(this._offset1.p0) <
                      this._distance * e.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
                  )
                    this._segList.addPt(this._offset0.p1);
                  else {
                    if ((this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0)) {
                      var r = new Y(
                        (this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) /
                          (this._closingSegLengthFactor + 1),
                        (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) /
                          (this._closingSegLengthFactor + 1),
                      );
                      this._segList.addPt(r);
                      var i = new Y(
                        (this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) /
                          (this._closingSegLengthFactor + 1),
                        (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) /
                          (this._closingSegLengthFactor + 1),
                      );
                      this._segList.addPt(i);
                    } else this._segList.addPt(this._s1);
                    this._segList.addPt(this._offset1.p0);
                  }
                },
              },
              {
                key: 'createCircle',
                value: function (t) {
                  var e = new Y(t.x + this._distance, t.y);
                  this._segList.addPt(e),
                    this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance),
                    this._segList.closeRing();
                },
              },
              {
                key: 'addBevelJoin',
                value: function (t, e) {
                  this._segList.addPt(t.p1), this._segList.addPt(e.p0);
                },
              },
              {
                key: 'init',
                value: function (t) {
                  (this._distance = t),
                    (this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2))),
                    (this._segList = new Rn()),
                    this._segList.setPrecisionModel(this._precisionModel),
                    this._segList.setMinimumVertexDistance(t * e.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
                },
              },
              {
                key: 'addCollinear',
                value: function (t) {
                  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2),
                    this._li.getIntersectionNum() >= 2 &&
                      (this._bufParams.getJoinStyle() === m.JOIN_BEVEL ||
                      this._bufParams.getJoinStyle() === m.JOIN_MITRE
                        ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0))
                        : this.addCornerFillet(
                            this._s1,
                            this._offset0.p1,
                            this._offset1.p0,
                            ft.CLOCKWISE,
                            this._distance,
                          ));
                },
              },
              {
                key: 'closeRing',
                value: function () {
                  this._segList.closeRing();
                },
              },
              {
                key: 'hasNarrowConcaveAngle',
                value: function () {
                  return this._hasNarrowConcaveAngle;
                },
              },
            ],
            [
              {
                key: 'constructor_',
                value: function () {
                  (this._maxCurveSegmentError = 0),
                    (this._filletAngleQuantum = null),
                    (this._closingSegLengthFactor = 1),
                    (this._segList = null),
                    (this._distance = 0),
                    (this._precisionModel = null),
                    (this._bufParams = null),
                    (this._li = null),
                    (this._s0 = null),
                    (this._s1 = null),
                    (this._s2 = null),
                    (this._seg0 = new wn()),
                    (this._seg1 = new wn()),
                    (this._offset0 = new wn()),
                    (this._offset1 = new wn()),
                    (this._side = 0),
                    (this._hasNarrowConcaveAngle = !1);
                  var t = arguments[0],
                    n = arguments[1],
                    r = arguments[2];
                  (this._precisionModel = t),
                    (this._bufParams = n),
                    (this._li = new Le()),
                    (this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments()),
                    n.getQuadrantSegments() >= 8 &&
                      n.getJoinStyle() === m.JOIN_ROUND &&
                      (this._closingSegLengthFactor = e.MAX_CLOSING_SEG_LEN_FACTOR),
                    this.init(r);
                },
              },
            ],
          ),
          e
        );
      })();
      (Tn.OFFSET_SEGMENT_SEPARATION_FACTOR = 0.001),
        (Tn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 0.001),
        (Tn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6),
        (Tn.MAX_CLOSING_SEG_LEN_FACTOR = 80);
      var An = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getOffsetCurve',
                  value: function (t, e) {
                    if (((this._distance = e), 0 === e)) return null;
                    var n = e < 0,
                      r = Math.abs(e),
                      i = this.getSegGen(r);
                    t.length <= 1 ? this.computePointCurve(t[0], i) : this.computeOffsetCurve(t, n, i);
                    var o = i.getCoordinates();
                    return n && Zt.reverse(o), o;
                  },
                },
                {
                  key: 'computeSingleSidedBufferCurve',
                  value: function (t, e, n) {
                    var r = this.simplifyTolerance(this._distance);
                    if (e) {
                      n.addSegments(t, !0);
                      var i = Ln.simplify(t, -r),
                        o = i.length - 1;
                      n.initSideSegments(i[o], i[o - 1], tt.LEFT), n.addFirstSegment();
                      for (var a = o - 2; a >= 0; a--) n.addNextSegment(i[a], !0);
                    } else {
                      n.addSegments(t, !1);
                      var s = Ln.simplify(t, r),
                        u = s.length - 1;
                      n.initSideSegments(s[0], s[1], tt.LEFT), n.addFirstSegment();
                      for (var l = 2; l <= u; l++) n.addNextSegment(s[l], !0);
                    }
                    n.addLastSegment(), n.closeRing();
                  },
                },
                {
                  key: 'computeRingBufferCurve',
                  value: function (t, e, n) {
                    var r = this.simplifyTolerance(this._distance);
                    e === tt.RIGHT && (r = -r);
                    var i = Ln.simplify(t, r),
                      o = i.length - 1;
                    n.initSideSegments(i[o - 1], i[0], e);
                    for (var a = 1; a <= o; a++) {
                      var s = 1 !== a;
                      n.addNextSegment(i[a], s);
                    }
                    n.closeRing();
                  },
                },
                {
                  key: 'computeLineBufferCurve',
                  value: function (t, e) {
                    var n = this.simplifyTolerance(this._distance),
                      r = Ln.simplify(t, n),
                      i = r.length - 1;
                    e.initSideSegments(r[0], r[1], tt.LEFT);
                    for (var o = 2; o <= i; o++) e.addNextSegment(r[o], !0);
                    e.addLastSegment(), e.addLineEndCap(r[i - 1], r[i]);
                    var a = Ln.simplify(t, -n),
                      s = a.length - 1;
                    e.initSideSegments(a[s], a[s - 1], tt.LEFT);
                    for (var u = s - 2; u >= 0; u--) e.addNextSegment(a[u], !0);
                    e.addLastSegment(), e.addLineEndCap(a[1], a[0]), e.closeRing();
                  },
                },
                {
                  key: 'computePointCurve',
                  value: function (t, e) {
                    switch (this._bufParams.getEndCapStyle()) {
                      case m.CAP_ROUND:
                        e.createCircle(t);
                        break;
                      case m.CAP_SQUARE:
                        e.createSquare(t);
                    }
                  },
                },
                {
                  key: 'getLineCurve',
                  value: function (t, e) {
                    if (((this._distance = e), this.isLineOffsetEmpty(e))) return null;
                    var n = Math.abs(e),
                      r = this.getSegGen(n);
                    if (t.length <= 1) this.computePointCurve(t[0], r);
                    else if (this._bufParams.isSingleSided()) {
                      var i = e < 0;
                      this.computeSingleSidedBufferCurve(t, i, r);
                    } else this.computeLineBufferCurve(t, r);
                    return r.getCoordinates();
                  },
                },
                {
                  key: 'getBufferParameters',
                  value: function () {
                    return this._bufParams;
                  },
                },
                {
                  key: 'simplifyTolerance',
                  value: function (t) {
                    return t * this._bufParams.getSimplifyFactor();
                  },
                },
                {
                  key: 'getRingCurve',
                  value: function (t, n, r) {
                    if (((this._distance = r), t.length <= 2)) return this.getLineCurve(t, r);
                    if (0 === r) return e.copyCoordinates(t);
                    var i = this.getSegGen(r);
                    return this.computeRingBufferCurve(t, n, i), i.getCoordinates();
                  },
                },
                {
                  key: 'computeOffsetCurve',
                  value: function (t, e, n) {
                    var r = this.simplifyTolerance(this._distance);
                    if (e) {
                      var i = Ln.simplify(t, -r),
                        o = i.length - 1;
                      n.initSideSegments(i[o], i[o - 1], tt.LEFT), n.addFirstSegment();
                      for (var a = o - 2; a >= 0; a--) n.addNextSegment(i[a], !0);
                    } else {
                      var s = Ln.simplify(t, r),
                        u = s.length - 1;
                      n.initSideSegments(s[0], s[1], tt.LEFT), n.addFirstSegment();
                      for (var l = 2; l <= u; l++) n.addNextSegment(s[l], !0);
                    }
                    n.addLastSegment();
                  },
                },
                {
                  key: 'isLineOffsetEmpty',
                  value: function (t) {
                    return 0 === t || (t < 0 && !this._bufParams.isSingleSided());
                  },
                },
                {
                  key: 'getSegGen',
                  value: function (t) {
                    return new Tn(this._precisionModel, this._bufParams, t);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._distance = 0), (this._precisionModel = null), (this._bufParams = null);
                    var t = arguments[0],
                      e = arguments[1];
                    (this._precisionModel = t), (this._bufParams = e);
                  },
                },
                {
                  key: 'copyCoordinates',
                  value: function (t) {
                    for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++) e[n] = new Y(t[n]);
                    return e;
                  },
                },
              ],
            ),
            e
          );
        })(),
        Dn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'findStabbedSegments',
                  value: function () {
                    if (1 === arguments.length) {
                      for (var t = arguments[0], e = new vt(), n = this._subgraphs.iterator(); n.hasNext(); ) {
                        var r = n.next(),
                          i = r.getEnvelope();
                        t.y < i.getMinY() || t.y > i.getMaxY() || this.findStabbedSegments(t, r.getDirectedEdges(), e);
                      }
                      return e;
                    }
                    if (3 === arguments.length)
                      if (ot(arguments[2], rt) && arguments[0] instanceof Y && arguments[1] instanceof $e) {
                        for (
                          var o = arguments[0],
                            a = arguments[1],
                            s = arguments[2],
                            u = a.getEdge().getCoordinates(),
                            l = 0;
                          l < u.length - 1;
                          l++
                        )
                          if (
                            ((this._seg.p0 = u[l]),
                            (this._seg.p1 = u[l + 1]),
                            this._seg.p0.y > this._seg.p1.y && this._seg.reverse(),
                            !(
                              Math.max(this._seg.p0.x, this._seg.p1.x) < o.x ||
                              this._seg.isHorizontal() ||
                              o.y < this._seg.p0.y ||
                              o.y > this._seg.p1.y ||
                              ft.index(this._seg.p0, this._seg.p1, o) === ft.RIGHT
                            ))
                          ) {
                            var c = a.getDepth(tt.LEFT);
                            this._seg.p0.equals(u[l]) || (c = a.getDepth(tt.RIGHT));
                            var h = new jn(this._seg, c);
                            s.add(h);
                          }
                      } else if (ot(arguments[2], rt) && arguments[0] instanceof Y && ot(arguments[1], rt))
                        for (var f = arguments[0], p = arguments[2], g = arguments[1].iterator(); g.hasNext(); ) {
                          var y = g.next();
                          y.isForward() && this.findStabbedSegments(f, y, p);
                        }
                  },
                },
                {
                  key: 'getDepth',
                  value: function (t) {
                    var e = this.findStabbedSegments(t);
                    return 0 === e.size() ? 0 : sn.min(e)._leftDepth;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._subgraphs = null), (this._seg = new wn());
                    var t = arguments[0];
                    this._subgraphs = t;
                  },
                },
              ],
            ),
            e
          );
        })(),
        jn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1;
                    if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1;
                    var n = this._upwardSeg.orientationIndex(e._upwardSeg);
                    return 0 !== n || 0 != (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg))
                      ? n
                      : this._upwardSeg.compareTo(e._upwardSeg);
                  },
                },
                {
                  key: 'compareX',
                  value: function (t, e) {
                    var n = t.p0.compareTo(e.p0);
                    return 0 !== n ? n : t.p1.compareTo(e.p1);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return this._upwardSeg.toString();
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._upwardSeg = null), (this._leftDepth = null);
                    var t = arguments[0],
                      e = arguments[1];
                    (this._upwardSeg = new wn(t)), (this._leftDepth = e);
                  },
                },
              ],
            ),
            e
          );
        })();
      Dn.DepthSegment = jn;
      var Fn = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            var e;
            return t(this, o), (e = n.call(this)), o.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(o, null, [
              {
                key: 'constructor_',
                value: function () {
                  _.constructor_.call(this, 'Projective point not representable on the Cartesian plane.');
                },
              },
            ]),
            o
          );
        })(_),
        Bn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getY',
                  value: function () {
                    var t = this.y / this.w;
                    if (A.isNaN(t) || A.isInfinite(t)) throw new Fn();
                    return t;
                  },
                },
                {
                  key: 'getX',
                  value: function () {
                    var t = this.x / this.w;
                    if (A.isNaN(t) || A.isInfinite(t)) throw new Fn();
                    return t;
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    var t = new Y();
                    return (t.x = this.getX()), (t.y = this.getY()), t;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this.x = null), (this.y = null), (this.w = null), 0 === arguments.length))
                      (this.x = 0), (this.y = 0), (this.w = 1);
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      (this.x = t.x), (this.y = t.y), (this.w = 1);
                    } else if (2 === arguments.length) {
                      if ('number' == typeof arguments[0] && 'number' == typeof arguments[1]) {
                        var n = arguments[0],
                          r = arguments[1];
                        (this.x = n), (this.y = r), (this.w = 1);
                      } else if (arguments[0] instanceof e && arguments[1] instanceof e) {
                        var i = arguments[0],
                          o = arguments[1];
                        (this.x = i.y * o.w - o.y * i.w),
                          (this.y = o.x * i.w - i.x * o.w),
                          (this.w = i.x * o.y - o.x * i.y);
                      } else if (arguments[0] instanceof Y && arguments[1] instanceof Y) {
                        var a = arguments[0],
                          s = arguments[1];
                        (this.x = a.y - s.y), (this.y = s.x - a.x), (this.w = a.x * s.y - s.x * a.y);
                      }
                    } else if (3 === arguments.length) {
                      var u = arguments[0],
                        l = arguments[1],
                        c = arguments[2];
                      (this.x = u), (this.y = l), (this.w = c);
                    } else if (4 === arguments.length) {
                      var h = arguments[0],
                        f = arguments[1],
                        p = arguments[2],
                        g = arguments[3],
                        y = h.y - f.y,
                        v = f.x - h.x,
                        d = h.x * f.y - f.x * h.y,
                        m = p.y - g.y,
                        _ = g.x - p.x,
                        b = p.x * g.y - g.x * p.y;
                      (this.x = v * b - _ * d), (this.y = m * d - y * b), (this.w = y * _ - m * v);
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        qn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'area',
                  value: function () {
                    return e.area(this.p0, this.p1, this.p2);
                  },
                },
                {
                  key: 'signedArea',
                  value: function () {
                    return e.signedArea(this.p0, this.p1, this.p2);
                  },
                },
                {
                  key: 'interpolateZ',
                  value: function (t) {
                    if (null === t) throw new b('Supplied point is null.');
                    return e.interpolateZ(t, this.p0, this.p1, this.p2);
                  },
                },
                {
                  key: 'longestSideLength',
                  value: function () {
                    return e.longestSideLength(this.p0, this.p1, this.p2);
                  },
                },
                {
                  key: 'isAcute',
                  value: function () {
                    return e.isAcute(this.p0, this.p1, this.p2);
                  },
                },
                {
                  key: 'circumcentre',
                  value: function () {
                    return e.circumcentre(this.p0, this.p1, this.p2);
                  },
                },
                {
                  key: 'area3D',
                  value: function () {
                    return e.area3D(this.p0, this.p1, this.p2);
                  },
                },
                {
                  key: 'centroid',
                  value: function () {
                    return e.centroid(this.p0, this.p1, this.p2);
                  },
                },
                {
                  key: 'inCentre',
                  value: function () {
                    return e.inCentre(this.p0, this.p1, this.p2);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this.p0 = null), (this.p1 = null), (this.p2 = null);
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2];
                    (this.p0 = t), (this.p1 = e), (this.p2 = n);
                  },
                },
                {
                  key: 'area',
                  value: function (t, e, n) {
                    return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2);
                  },
                },
                {
                  key: 'signedArea',
                  value: function (t, e, n) {
                    return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2;
                  },
                },
                {
                  key: 'det',
                  value: function (t, e, n, r) {
                    return t * r - e * n;
                  },
                },
                {
                  key: 'interpolateZ',
                  value: function (t, e, n, r) {
                    var i = e.x,
                      o = e.y,
                      a = n.x - i,
                      s = r.x - i,
                      u = n.y - o,
                      l = r.y - o,
                      c = a * l - s * u,
                      h = t.x - i,
                      f = t.y - o,
                      p = (l * h - s * f) / c,
                      g = (-u * h + a * f) / c;
                    return e.getZ() + p * (n.getZ() - e.getZ()) + g * (r.getZ() - e.getZ());
                  },
                },
                {
                  key: 'longestSideLength',
                  value: function (t, e, n) {
                    var r = t.distance(e),
                      i = e.distance(n),
                      o = n.distance(t),
                      a = r;
                    return i > a && (a = i), o > a && (a = o), a;
                  },
                },
                {
                  key: 'circumcentreDD',
                  value: function (t, e, n) {
                    var r = lt.valueOf(t.x).subtract(n.x),
                      i = lt.valueOf(t.y).subtract(n.y),
                      o = lt.valueOf(e.x).subtract(n.x),
                      a = lt.valueOf(e.y).subtract(n.y),
                      s = lt.determinant(r, i, o, a).multiply(2),
                      u = r.sqr().add(i.sqr()),
                      l = o.sqr().add(a.sqr()),
                      c = lt.determinant(i, u, a, l),
                      h = lt.determinant(r, u, o, l),
                      f = lt.valueOf(n.x).subtract(c.divide(s)).doubleValue(),
                      p = lt.valueOf(n.y).add(h.divide(s)).doubleValue();
                    return new Y(f, p);
                  },
                },
                {
                  key: 'isAcute',
                  value: function (t, e, n) {
                    return !!Cn.isAcute(t, e, n) && !!Cn.isAcute(e, n, t) && !!Cn.isAcute(n, t, e);
                  },
                },
                {
                  key: 'circumcentre',
                  value: function (t, n, r) {
                    var i = r.x,
                      o = r.y,
                      a = t.x - i,
                      s = t.y - o,
                      u = n.x - i,
                      l = n.y - o,
                      c = 2 * e.det(a, s, u, l),
                      h = e.det(s, a * a + s * s, l, u * u + l * l),
                      f = e.det(a, a * a + s * s, u, u * u + l * l);
                    return new Y(i - h / c, o + f / c);
                  },
                },
                {
                  key: 'perpendicularBisector',
                  value: function (t, e) {
                    var n = e.x - t.x,
                      r = e.y - t.y,
                      i = new Bn(t.x + n / 2, t.y + r / 2, 1),
                      o = new Bn(t.x - r + n / 2, t.y + n + r / 2, 1);
                    return new Bn(i, o);
                  },
                },
                {
                  key: 'angleBisector',
                  value: function (t, e, n) {
                    var r = e.distance(t),
                      i = r / (r + e.distance(n)),
                      o = n.x - t.x,
                      a = n.y - t.y;
                    return new Y(t.x + i * o, t.y + i * a);
                  },
                },
                {
                  key: 'area3D',
                  value: function (t, e, n) {
                    var r = e.x - t.x,
                      i = e.y - t.y,
                      o = e.getZ() - t.getZ(),
                      a = n.x - t.x,
                      s = n.y - t.y,
                      u = n.getZ() - t.getZ(),
                      l = i * u - o * s,
                      c = o * a - r * u,
                      h = r * s - i * a,
                      f = l * l + c * c + h * h;
                    return Math.sqrt(f) / 2;
                  },
                },
                {
                  key: 'centroid',
                  value: function (t, e, n) {
                    var r = (t.x + e.x + n.x) / 3,
                      i = (t.y + e.y + n.y) / 3;
                    return new Y(r, i);
                  },
                },
                {
                  key: 'inCentre',
                  value: function (t, e, n) {
                    var r = e.distance(n),
                      i = t.distance(n),
                      o = t.distance(e),
                      a = r + i + o,
                      s = (r * t.x + i * e.x + o * n.x) / a,
                      u = (r * t.y + i * e.y + o * n.y) / a;
                    return new Y(s, u);
                  },
                },
              ],
            ),
            e
          );
        })(),
        Vn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'addRingSide',
                  value: function (t, e, n, r, i) {
                    if (0 === e && t.length < Yt.MINIMUM_VALID_SIZE) return null;
                    var o = r,
                      a = i;
                    t.length >= Yt.MINIMUM_VALID_SIZE && ft.isCCW(t) && ((o = i), (a = r), (n = tt.opposite(n)));
                    var s = this._curveBuilder.getRingCurve(t, n, e);
                    this.addCurve(s, o, a);
                  },
                },
                {
                  key: 'addRingBothSides',
                  value: function (t, e) {
                    this.addRingSide(t, e, tt.LEFT, W.EXTERIOR, W.INTERIOR),
                      this.addRingSide(t, e, tt.RIGHT, W.INTERIOR, W.EXTERIOR);
                  },
                },
                {
                  key: 'addPoint',
                  value: function (t) {
                    if (this._distance <= 0) return null;
                    var e = t.getCoordinates(),
                      n = this._curveBuilder.getLineCurve(e, this._distance);
                    this.addCurve(n, W.EXTERIOR, W.INTERIOR);
                  },
                },
                {
                  key: 'addPolygon',
                  value: function (t) {
                    var e = this._distance,
                      n = tt.LEFT;
                    this._distance < 0 && ((e = -this._distance), (n = tt.RIGHT));
                    var r = t.getExteriorRing(),
                      i = Zt.removeRepeatedPoints(r.getCoordinates());
                    if (this._distance < 0 && this.isErodedCompletely(r, this._distance)) return null;
                    if (this._distance <= 0 && i.length < 3) return null;
                    this.addRingSide(i, e, n, W.EXTERIOR, W.INTERIOR);
                    for (var o = 0; o < t.getNumInteriorRing(); o++) {
                      var a = t.getInteriorRingN(o),
                        s = Zt.removeRepeatedPoints(a.getCoordinates());
                      (this._distance > 0 && this.isErodedCompletely(a, -this._distance)) ||
                        this.addRingSide(s, e, tt.opposite(n), W.INTERIOR, W.EXTERIOR);
                    }
                  },
                },
                {
                  key: 'isTriangleErodedCompletely',
                  value: function (t, e) {
                    var n = new qn(t[0], t[1], t[2]),
                      r = n.inCentre();
                    return Et.pointToSegment(r, n.p0, n.p1) < Math.abs(e);
                  },
                },
                {
                  key: 'addLineString',
                  value: function (t) {
                    if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
                    var e = Zt.removeRepeatedPoints(t.getCoordinates());
                    if (Zt.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided())
                      this.addRingBothSides(e, this._distance);
                    else {
                      var n = this._curveBuilder.getLineCurve(e, this._distance);
                      this.addCurve(n, W.EXTERIOR, W.INTERIOR);
                    }
                  },
                },
                {
                  key: 'addCurve',
                  value: function (t, e, n) {
                    if (null === t || t.length < 2) return null;
                    var r = new En(t, new Ae(0, W.BOUNDARY, e, n));
                    this._curveList.add(r);
                  },
                },
                {
                  key: 'getCurves',
                  value: function () {
                    return this.add(this._inputGeom), this._curveList;
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    if (t.isEmpty()) return null;
                    if (t instanceof jt) this.addPolygon(t);
                    else if (t instanceof Lt) this.addLineString(t);
                    else if (t instanceof Ct) this.addPoint(t);
                    else if (t instanceof Gt) this.addCollection(t);
                    else if (t instanceof ae) this.addCollection(t);
                    else if (t instanceof ee) this.addCollection(t);
                    else {
                      if (!(t instanceof Vt)) throw new J(t.getGeometryType());
                      this.addCollection(t);
                    }
                  },
                },
                {
                  key: 'isErodedCompletely',
                  value: function (t, e) {
                    var n = t.getCoordinates();
                    if (n.length < 4) return e < 0;
                    if (4 === n.length) return this.isTriangleErodedCompletely(n, e);
                    var r = t.getEnvelopeInternal(),
                      i = Math.min(r.getHeight(), r.getWidth());
                    return e < 0 && 2 * Math.abs(e) > i;
                  },
                },
                {
                  key: 'addCollection',
                  value: function (t) {
                    for (var e = 0; e < t.getNumGeometries(); e++) {
                      var n = t.getGeometryN(e);
                      this.add(n);
                    }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._inputGeom = null),
                      (this._distance = null),
                      (this._curveBuilder = null),
                      (this._curveList = new vt());
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2];
                    (this._inputGeom = t), (this._distance = e), (this._curveBuilder = n);
                  },
                },
              ],
            ),
            e
          );
        })(),
        Gn = (function () {
          function e() {
            t(this, e);
          }
          return r(e, [{ key: 'locate', value: function (t) {} }]), e;
        })(),
        Yn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'next',
                  value: function () {
                    if (this._atStart)
                      return (this._atStart = !1), e.isAtomic(this._parent) && this._index++, this._parent;
                    if (null !== this._subcollectionIterator) {
                      if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
                      this._subcollectionIterator = null;
                    }
                    if (this._index >= this._max) throw new Z();
                    var t = this._parent.getGeometryN(this._index++);
                    return t instanceof Vt
                      ? ((this._subcollectionIterator = new e(t)), this._subcollectionIterator.next())
                      : t;
                  },
                },
                {
                  key: 'remove',
                  value: function () {
                    throw new J(this.getClass().getName());
                  },
                },
                {
                  key: 'hasNext',
                  value: function () {
                    if (this._atStart) return !0;
                    if (null !== this._subcollectionIterator) {
                      if (this._subcollectionIterator.hasNext()) return !0;
                      this._subcollectionIterator = null;
                    }
                    return !(this._index >= this._max);
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [dn];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._parent = null),
                      (this._atStart = null),
                      (this._max = null),
                      (this._index = null),
                      (this._subcollectionIterator = null);
                    var t = arguments[0];
                    (this._parent = t), (this._atStart = !0), (this._index = 0), (this._max = t.getNumGeometries());
                  },
                },
                {
                  key: 'isAtomic',
                  value: function (t) {
                    return !(t instanceof Vt);
                  },
                },
              ],
            ),
            e
          );
        })(),
        zn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'locate',
                  value: function (t) {
                    return e.locate(t, this._geom);
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Gn];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    this._geom = null;
                    var t = arguments[0];
                    this._geom = t;
                  },
                },
                {
                  key: 'locatePointInPolygon',
                  value: function (t, n) {
                    if (n.isEmpty()) return W.EXTERIOR;
                    var r = n.getExteriorRing(),
                      i = e.locatePointInRing(t, r);
                    if (i !== W.INTERIOR) return i;
                    for (var o = 0; o < n.getNumInteriorRing(); o++) {
                      var a = n.getInteriorRingN(o),
                        s = e.locatePointInRing(t, a);
                      if (s === W.BOUNDARY) return W.BOUNDARY;
                      if (s === W.INTERIOR) return W.EXTERIOR;
                    }
                    return W.INTERIOR;
                  },
                },
                {
                  key: 'locatePointInRing',
                  value: function (t, e) {
                    return e.getEnvelopeInternal().intersects(t) ? Ce.locateInRing(t, e.getCoordinates()) : W.EXTERIOR;
                  },
                },
                {
                  key: 'containsPointInPolygon',
                  value: function (t, n) {
                    return W.EXTERIOR !== e.locatePointInPolygon(t, n);
                  },
                },
                {
                  key: 'locateInGeometry',
                  value: function (t, n) {
                    if (n instanceof jt) return e.locatePointInPolygon(t, n);
                    if (n instanceof Vt)
                      for (var r = new Yn(n); r.hasNext(); ) {
                        var i = r.next();
                        if (i !== n) {
                          var o = e.locateInGeometry(t, i);
                          if (o !== W.EXTERIOR) return o;
                        }
                      }
                    return W.EXTERIOR;
                  },
                },
                {
                  key: 'isContained',
                  value: function (t, n) {
                    return W.EXTERIOR !== e.locate(t, n);
                  },
                },
                {
                  key: 'locate',
                  value: function (t, n) {
                    return n.isEmpty()
                      ? W.EXTERIOR
                      : n.getEnvelopeInternal().intersects(t)
                      ? e.locateInGeometry(t, n)
                      : W.EXTERIOR;
                  },
                },
              ],
            ),
            e
          );
        })(),
        Un = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getNextCW',
                  value: function (t) {
                    this.getEdges();
                    var e = this._edgeList.indexOf(t),
                      n = e - 1;
                    return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n);
                  },
                },
                {
                  key: 'propagateSideLabels',
                  value: function (t) {
                    for (var e = W.NONE, n = this.iterator(); n.hasNext(); ) {
                      var r = n.next().getLabel();
                      r.isArea(t) && r.getLocation(t, tt.LEFT) !== W.NONE && (e = r.getLocation(t, tt.LEFT));
                    }
                    if (e === W.NONE) return null;
                    for (var i = e, o = this.iterator(); o.hasNext(); ) {
                      var a = o.next(),
                        s = a.getLabel();
                      if ((s.getLocation(t, tt.ON) === W.NONE && s.setLocation(t, tt.ON, i), s.isArea(t))) {
                        var u = s.getLocation(t, tt.LEFT),
                          l = s.getLocation(t, tt.RIGHT);
                        if (l !== W.NONE) {
                          if (l !== i) throw new gt('side location conflict', a.getCoordinate());
                          u === W.NONE &&
                            B.shouldNeverReachHere('found single null side (at ' + a.getCoordinate() + ')'),
                            (i = u);
                        } else
                          B.isTrue(s.getLocation(t, tt.LEFT) === W.NONE, 'found single null side'),
                            s.setLocation(t, tt.RIGHT, i),
                            s.setLocation(t, tt.LEFT, i);
                      }
                    }
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    var t = this.iterator();
                    return t.hasNext() ? t.next().getCoordinate() : null;
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    bt.out.println('EdgeEndStar:   ' + this.getCoordinate());
                    for (var e = this.iterator(); e.hasNext(); ) e.next().print(t);
                  },
                },
                {
                  key: 'isAreaLabelsConsistent',
                  value: function (t) {
                    return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
                  },
                },
                {
                  key: 'checkAreaLabelsConsistent',
                  value: function (t) {
                    var e = this.getEdges();
                    if (e.size() <= 0) return !0;
                    var n = e.size() - 1,
                      r = e.get(n).getLabel().getLocation(t, tt.LEFT);
                    B.isTrue(r !== W.NONE, 'Found unlabelled area edge');
                    for (var i = r, o = this.iterator(); o.hasNext(); ) {
                      var a = o.next().getLabel();
                      B.isTrue(a.isArea(t), 'Found non-area edge');
                      var s = a.getLocation(t, tt.LEFT),
                        u = a.getLocation(t, tt.RIGHT);
                      if (s === u) return !1;
                      if (u !== i) return !1;
                      i = s;
                    }
                    return !0;
                  },
                },
                {
                  key: 'findIndex',
                  value: function (t) {
                    this.iterator();
                    for (var e = 0; e < this._edgeList.size(); e++) if (this._edgeList.get(e) === t) return e;
                    return -1;
                  },
                },
                {
                  key: 'iterator',
                  value: function () {
                    return this.getEdges().iterator();
                  },
                },
                {
                  key: 'getEdges',
                  value: function () {
                    return null === this._edgeList && (this._edgeList = new vt(this._edgeMap.values())), this._edgeList;
                  },
                },
                {
                  key: 'getLocation',
                  value: function (t, e, n) {
                    return (
                      this._ptInAreaLocation[t] === W.NONE &&
                        (this._ptInAreaLocation[t] = zn.locate(e, n[t].getGeometry())),
                      this._ptInAreaLocation[t]
                    );
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    var t = new at();
                    t.append('EdgeEndStar:   ' + this.getCoordinate()), t.append('\n');
                    for (var e = this.iterator(); e.hasNext(); ) {
                      var n = e.next();
                      t.append(n), t.append('\n');
                    }
                    return t.toString();
                  },
                },
                {
                  key: 'computeEdgeEndLabels',
                  value: function (t) {
                    for (var e = this.iterator(); e.hasNext(); ) e.next().computeLabel(t);
                  },
                },
                {
                  key: 'computeLabelling',
                  value: function (t) {
                    this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),
                      this.propagateSideLabels(0),
                      this.propagateSideLabels(1);
                    for (var e = [!1, !1], n = this.iterator(); n.hasNext(); )
                      for (var r = n.next().getLabel(), i = 0; i < 2; i++)
                        r.isLine(i) && r.getLocation(i) === W.BOUNDARY && (e[i] = !0);
                    for (var o = this.iterator(); o.hasNext(); )
                      for (var a = o.next(), s = a.getLabel(), u = 0; u < 2; u++)
                        if (s.isAnyNull(u)) {
                          var l = W.NONE;
                          if (e[u]) l = W.EXTERIOR;
                          else {
                            var c = a.getCoordinate();
                            l = this.getLocation(u, c, t);
                          }
                          s.setAllLocationsIfNull(u, l);
                        }
                  },
                },
                {
                  key: 'getDegree',
                  value: function () {
                    return this._edgeMap.size();
                  },
                },
                {
                  key: 'insertEdgeEnd',
                  value: function (t, e) {
                    this._edgeMap.put(t, e), (this._edgeList = null);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._edgeMap = new We()), (this._edgeList = null), (this._ptInAreaLocation = [W.NONE, W.NONE]);
                  },
                },
              ],
            ),
            e
          );
        })(),
        Xn = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'linkResultDirectedEdges',
                  value: function () {
                    this.getResultAreaEdges();
                    for (
                      var t = null, e = null, n = this._SCANNING_FOR_INCOMING, r = 0;
                      r < this._resultAreaEdgeList.size();
                      r++
                    ) {
                      var i = this._resultAreaEdgeList.get(r),
                        o = i.getSym();
                      if (i.getLabel().isArea())
                        switch ((null === t && i.isInResult() && (t = i), n)) {
                          case this._SCANNING_FOR_INCOMING:
                            if (!o.isInResult()) continue;
                            (e = o), (n = this._LINKING_TO_OUTGOING);
                            break;
                          case this._LINKING_TO_OUTGOING:
                            if (!i.isInResult()) continue;
                            e.setNext(i), (n = this._SCANNING_FOR_INCOMING);
                        }
                    }
                    if (n === this._LINKING_TO_OUTGOING) {
                      if (null === t) throw new gt('no outgoing dirEdge found', this.getCoordinate());
                      B.isTrue(t.isInResult(), 'unable to link last incoming dirEdge'), e.setNext(t);
                    }
                  },
                },
                {
                  key: 'insert',
                  value: function (t) {
                    var e = t;
                    this.insertEdgeEnd(e, e);
                  },
                },
                {
                  key: 'getRightmostEdge',
                  value: function () {
                    var t = this.getEdges(),
                      e = t.size();
                    if (e < 1) return null;
                    var n = t.get(0);
                    if (1 === e) return n;
                    var r = t.get(e - 1),
                      i = n.getQuadrant(),
                      o = r.getQuadrant();
                    return Ze.isNorthern(i) && Ze.isNorthern(o)
                      ? n
                      : Ze.isNorthern(i) || Ze.isNorthern(o)
                      ? 0 !== n.getDy()
                        ? n
                        : 0 !== r.getDy()
                        ? r
                        : (B.shouldNeverReachHere('found two horizontal edges incident on node'), null)
                      : r;
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    bt.out.println('DirectedEdgeStar: ' + this.getCoordinate());
                    for (var e = this.iterator(); e.hasNext(); ) {
                      var n = e.next();
                      t.print('out '), n.print(t), t.println(), t.print('in '), n.getSym().print(t), t.println();
                    }
                  },
                },
                {
                  key: 'getResultAreaEdges',
                  value: function () {
                    if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList;
                    this._resultAreaEdgeList = new vt();
                    for (var t = this.iterator(); t.hasNext(); ) {
                      var e = t.next();
                      (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e);
                    }
                    return this._resultAreaEdgeList;
                  },
                },
                {
                  key: 'updateLabelling',
                  value: function (t) {
                    for (var e = this.iterator(); e.hasNext(); ) {
                      var n = e.next().getLabel();
                      n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1));
                    }
                  },
                },
                {
                  key: 'linkAllDirectedEdges',
                  value: function () {
                    this.getEdges();
                    for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) {
                      var r = this._edgeList.get(n),
                        i = r.getSym();
                      null === e && (e = i), null !== t && i.setNext(t), (t = r);
                    }
                    e.setNext(t);
                  },
                },
                {
                  key: 'computeDepths',
                  value: function () {
                    if (1 === arguments.length) {
                      var t = arguments[0],
                        e = this.findIndex(t),
                        n = t.getDepth(tt.LEFT),
                        r = t.getDepth(tt.RIGHT),
                        i = this.computeDepths(e + 1, this._edgeList.size(), n);
                      if (this.computeDepths(0, e, i) !== r) throw new gt('depth mismatch at ' + t.getCoordinate());
                    } else if (3 === arguments.length) {
                      for (var o = arguments[1], a = arguments[2], s = arguments[0]; s < o; s++) {
                        var u = this._edgeList.get(s);
                        u.setEdgeDepths(tt.RIGHT, a), (a = u.getDepth(tt.LEFT));
                      }
                      return a;
                    }
                  },
                },
                {
                  key: 'mergeSymLabels',
                  value: function () {
                    for (var t = this.iterator(); t.hasNext(); ) {
                      var e = t.next();
                      e.getLabel().merge(e.getSym().getLabel());
                    }
                  },
                },
                {
                  key: 'linkMinimalDirectedEdges',
                  value: function (t) {
                    for (
                      var e = null, n = null, r = this._SCANNING_FOR_INCOMING, i = this._resultAreaEdgeList.size() - 1;
                      i >= 0;
                      i--
                    ) {
                      var o = this._resultAreaEdgeList.get(i),
                        a = o.getSym();
                      switch ((null === e && o.getEdgeRing() === t && (e = o), r)) {
                        case this._SCANNING_FOR_INCOMING:
                          if (a.getEdgeRing() !== t) continue;
                          (n = a), (r = this._LINKING_TO_OUTGOING);
                          break;
                        case this._LINKING_TO_OUTGOING:
                          if (o.getEdgeRing() !== t) continue;
                          n.setNextMin(o), (r = this._SCANNING_FOR_INCOMING);
                      }
                    }
                    r === this._LINKING_TO_OUTGOING &&
                      (B.isTrue(null !== e, 'found null for first outgoing dirEdge'),
                      B.isTrue(e.getEdgeRing() === t, 'unable to link last incoming dirEdge'),
                      n.setNextMin(e));
                  },
                },
                {
                  key: 'getOutgoingDegree',
                  value: function () {
                    if (0 === arguments.length) {
                      for (var t = 0, e = this.iterator(); e.hasNext(); ) e.next().isInResult() && t++;
                      return t;
                    }
                    if (1 === arguments.length) {
                      for (var n = arguments[0], r = 0, i = this.iterator(); i.hasNext(); )
                        i.next().getEdgeRing() === n && r++;
                      return r;
                    }
                  },
                },
                {
                  key: 'getLabel',
                  value: function () {
                    return this._label;
                  },
                },
                {
                  key: 'findCoveredLineEdges',
                  value: function () {
                    for (var t = W.NONE, e = this.iterator(); e.hasNext(); ) {
                      var n = e.next(),
                        r = n.getSym();
                      if (!n.isLineEdge()) {
                        if (n.isInResult()) {
                          t = W.INTERIOR;
                          break;
                        }
                        if (r.isInResult()) {
                          t = W.EXTERIOR;
                          break;
                        }
                      }
                    }
                    if (t === W.NONE) return null;
                    for (var i = t, o = this.iterator(); o.hasNext(); ) {
                      var a = o.next(),
                        s = a.getSym();
                      a.isLineEdge()
                        ? a.getEdge().setCovered(i === W.INTERIOR)
                        : (a.isInResult() && (i = W.EXTERIOR), s.isInResult() && (i = W.INTERIOR));
                    }
                  },
                },
                {
                  key: 'computeLabelling',
                  value: function (t) {
                    p(o(a.prototype), 'computeLabelling', this).call(this, t), (this._label = new Ae(W.NONE));
                    for (var e = this.iterator(); e.hasNext(); )
                      for (var n = e.next().getEdge().getLabel(), r = 0; r < 2; r++) {
                        var i = n.getLocation(r);
                        (i !== W.INTERIOR && i !== W.BOUNDARY) || this._label.setLocation(r, W.INTERIOR);
                      }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._resultAreaEdgeList = null),
                      (this._label = null),
                      (this._SCANNING_FOR_INCOMING = 1),
                      (this._LINKING_TO_OUTGOING = 2);
                  },
                },
              ],
            ),
            a
          );
        })(Un),
        Wn = (function (e) {
          i(o, e);
          var n = f(o);
          function o() {
            return t(this, o), n.call(this);
          }
          return (
            r(o, [
              {
                key: 'createNode',
                value: function (t) {
                  return new qe(t, new Xn());
                },
              },
            ]),
            o
          );
        })(Qe),
        Hn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'compareTo',
                  value: function (t) {
                    var n = t;
                    return e.compareOriented(this._pts, this._orientation, n._pts, n._orientation);
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._pts = null), (this._orientation = null);
                    var t = arguments[0];
                    (this._pts = t), (this._orientation = e.orientation(t));
                  },
                },
                {
                  key: 'orientation',
                  value: function (t) {
                    return 1 === Zt.increasingDirection(t);
                  },
                },
                {
                  key: 'compareOriented',
                  value: function (t, e, n, r) {
                    for (
                      var i = e ? 1 : -1,
                        o = r ? 1 : -1,
                        a = e ? t.length : -1,
                        s = r ? n.length : -1,
                        u = e ? 0 : t.length - 1,
                        l = r ? 0 : n.length - 1;
                      ;

                    ) {
                      var c = t[u].compareTo(n[l]);
                      if (0 !== c) return c;
                      var h = (u += i) === a,
                        f = (l += o) === s;
                      if (h && !f) return -1;
                      if (!h && f) return 1;
                      if (h && f) return 0;
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        Zn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'print',
                  value: function (t) {
                    t.print('MULTILINESTRING ( ');
                    for (var e = 0; e < this._edges.size(); e++) {
                      var n = this._edges.get(e);
                      e > 0 && t.print(','), t.print('(');
                      for (var r = n.getCoordinates(), i = 0; i < r.length; i++)
                        i > 0 && t.print(','), t.print(r[i].x + ' ' + r[i].y);
                      t.println(')');
                    }
                    t.print(')  ');
                  },
                },
                {
                  key: 'addAll',
                  value: function (t) {
                    for (var e = t.iterator(); e.hasNext(); ) this.add(e.next());
                  },
                },
                {
                  key: 'findEdgeIndex',
                  value: function (t) {
                    for (var e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e;
                    return -1;
                  },
                },
                {
                  key: 'iterator',
                  value: function () {
                    return this._edges.iterator();
                  },
                },
                {
                  key: 'getEdges',
                  value: function () {
                    return this._edges;
                  },
                },
                {
                  key: 'get',
                  value: function (t) {
                    return this._edges.get(t);
                  },
                },
                {
                  key: 'findEqualEdge',
                  value: function (t) {
                    var e = new Hn(t.getCoordinates());
                    return this._ocaMap.get(e);
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    this._edges.add(t);
                    var e = new Hn(t.getCoordinates());
                    this._ocaMap.put(e, t);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._edges = new vt()), (this._ocaMap = new We());
                  },
                },
              ],
            ),
            e
          );
        })(),
        Jn = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(e, [
              { key: 'processIntersections', value: function (t, e, n, r) {} },
              { key: 'isDone', value: function () {} },
            ]),
            e
          );
        })(),
        $n = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'isTrivialIntersection',
                  value: function (t, n, r, i) {
                    if (t === r && 1 === this._li.getIntersectionNum()) {
                      if (e.isAdjacentSegments(n, i)) return !0;
                      if (t.isClosed()) {
                        var o = t.size() - 1;
                        if ((0 === n && i === o) || (0 === i && n === o)) return !0;
                      }
                    }
                    return !1;
                  },
                },
                {
                  key: 'getProperIntersectionPoint',
                  value: function () {
                    return this._properIntersectionPoint;
                  },
                },
                {
                  key: 'hasProperInteriorIntersection',
                  value: function () {
                    return this._hasProperInterior;
                  },
                },
                {
                  key: 'getLineIntersector',
                  value: function () {
                    return this._li;
                  },
                },
                {
                  key: 'hasProperIntersection',
                  value: function () {
                    return this._hasProper;
                  },
                },
                {
                  key: 'processIntersections',
                  value: function (t, e, n, r) {
                    if (t === n && e === r) return null;
                    this.numTests++;
                    var i = t.getCoordinates()[e],
                      o = t.getCoordinates()[e + 1],
                      a = n.getCoordinates()[r],
                      s = n.getCoordinates()[r + 1];
                    this._li.computeIntersection(i, o, a, s),
                      this._li.hasIntersection() &&
                        (this.numIntersections++,
                        this._li.isInteriorIntersection() &&
                          (this.numInteriorIntersections++, (this._hasInterior = !0)),
                        this.isTrivialIntersection(t, e, n, r) ||
                          ((this._hasIntersection = !0),
                          t.addIntersections(this._li, e, 0),
                          n.addIntersections(this._li, r, 1),
                          this._li.isProper() &&
                            (this.numProperIntersections++, (this._hasProper = !0), (this._hasProperInterior = !0))));
                  },
                },
                {
                  key: 'hasIntersection',
                  value: function () {
                    return this._hasIntersection;
                  },
                },
                {
                  key: 'isDone',
                  value: function () {
                    return !1;
                  },
                },
                {
                  key: 'hasInteriorIntersection',
                  value: function () {
                    return this._hasInterior;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Jn];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._hasIntersection = !1),
                      (this._hasProper = !1),
                      (this._hasProperInterior = !1),
                      (this._hasInterior = !1),
                      (this._properIntersectionPoint = null),
                      (this._li = null),
                      (this._isSelfIntersection = null),
                      (this.numIntersections = 0),
                      (this.numInteriorIntersections = 0),
                      (this.numProperIntersections = 0),
                      (this.numTests = 0);
                    var t = arguments[0];
                    this._li = t;
                  },
                },
                {
                  key: 'isAdjacentSegments',
                  value: function (t, e) {
                    return 1 === Math.abs(t - e);
                  },
                },
              ],
            ),
            e
          );
        })(),
        Qn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getSegmentIndex',
                  value: function () {
                    return this.segmentIndex;
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    return this.coord;
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    t.print(this.coord), t.print(' seg # = ' + this.segmentIndex), t.println(' dist = ' + this.dist);
                  },
                },
                {
                  key: 'compareTo',
                  value: function (t) {
                    var e = t;
                    return this.compare(e.segmentIndex, e.dist);
                  },
                },
                {
                  key: 'isEndPoint',
                  value: function (t) {
                    return (0 === this.segmentIndex && 0 === this.dist) || this.segmentIndex === t;
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist;
                  },
                },
                {
                  key: 'getDistance',
                  value: function () {
                    return this.dist;
                  },
                },
                {
                  key: 'compare',
                  value: function (t, e) {
                    return this.segmentIndex < t
                      ? -1
                      : this.segmentIndex > t
                      ? 1
                      : this.dist < e
                      ? -1
                      : this.dist > e
                      ? 1
                      : 0;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [E];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this.coord = null), (this.segmentIndex = null), (this.dist = null);
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2];
                    (this.coord = new Y(t)), (this.segmentIndex = e), (this.dist = n);
                  },
                },
              ],
            ),
            e
          );
        })(),
        Kn = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'print',
                  value: function (t) {
                    t.println('Intersections:');
                    for (var e = this.iterator(); e.hasNext(); ) e.next().print(t);
                  },
                },
                {
                  key: 'iterator',
                  value: function () {
                    return this._nodeMap.values().iterator();
                  },
                },
                {
                  key: 'addSplitEdges',
                  value: function (t) {
                    this.addEndpoints();
                    for (var e = this.iterator(), n = e.next(); e.hasNext(); ) {
                      var r = e.next(),
                        i = this.createSplitEdge(n, r);
                      t.add(i), (n = r);
                    }
                  },
                },
                {
                  key: 'addEndpoints',
                  value: function () {
                    var t = this.edge.pts.length - 1;
                    this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0);
                  },
                },
                {
                  key: 'createSplitEdge',
                  value: function (t, e) {
                    var n = e.segmentIndex - t.segmentIndex + 2,
                      r = this.edge.pts[e.segmentIndex],
                      i = e.dist > 0 || !e.coord.equals2D(r);
                    i || n--;
                    var o = new Array(n).fill(null),
                      a = 0;
                    o[a++] = new Y(t.coord);
                    for (var s = t.segmentIndex + 1; s <= e.segmentIndex; s++) o[a++] = this.edge.pts[s];
                    return i && (o[a] = e.coord), new or(o, new Ae(this.edge._label));
                  },
                },
                {
                  key: 'add',
                  value: function (t, e, n) {
                    var r = new Qn(t, e, n),
                      i = this._nodeMap.get(r);
                    return null !== i ? i : (this._nodeMap.put(r, r), r);
                  },
                },
                {
                  key: 'isIntersection',
                  value: function (t) {
                    for (var e = this.iterator(); e.hasNext(); ) if (e.next().coord.equals(t)) return !0;
                    return !1;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._nodeMap = new We()), (this.edge = null);
                    var t = arguments[0];
                    this.edge = t;
                  },
                },
              ],
            ),
            e
          );
        })(),
        tr = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'isIntersects',
                  value: function () {
                    return !this.isDisjoint();
                  },
                },
                {
                  key: 'isCovers',
                  value: function () {
                    return (
                      (e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) ||
                        e.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) ||
                        e.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) ||
                        e.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY])) &&
                      this._matrix[W.EXTERIOR][W.INTERIOR] === Nt.FALSE &&
                      this._matrix[W.EXTERIOR][W.BOUNDARY] === Nt.FALSE
                    );
                  },
                },
                {
                  key: 'isCoveredBy',
                  value: function () {
                    return (
                      (e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) ||
                        e.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) ||
                        e.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) ||
                        e.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY])) &&
                      this._matrix[W.INTERIOR][W.EXTERIOR] === Nt.FALSE &&
                      this._matrix[W.BOUNDARY][W.EXTERIOR] === Nt.FALSE
                    );
                  },
                },
                {
                  key: 'set',
                  value: function () {
                    if (1 === arguments.length)
                      for (var t = arguments[0], e = 0; e < t.length; e++) {
                        var n = Math.trunc(e / 3),
                          r = e % 3;
                        this._matrix[n][r] = Nt.toDimensionValue(t.charAt(e));
                      }
                    else if (3 === arguments.length) {
                      var i = arguments[0],
                        o = arguments[1],
                        a = arguments[2];
                      this._matrix[i][o] = a;
                    }
                  },
                },
                {
                  key: 'isContains',
                  value: function () {
                    return (
                      e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                      this._matrix[W.EXTERIOR][W.INTERIOR] === Nt.FALSE &&
                      this._matrix[W.EXTERIOR][W.BOUNDARY] === Nt.FALSE
                    );
                  },
                },
                {
                  key: 'setAtLeast',
                  value: function () {
                    if (1 === arguments.length)
                      for (var t = arguments[0], e = 0; e < t.length; e++) {
                        var n = Math.trunc(e / 3),
                          r = e % 3;
                        this.setAtLeast(n, r, Nt.toDimensionValue(t.charAt(e)));
                      }
                    else if (3 === arguments.length) {
                      var i = arguments[0],
                        o = arguments[1],
                        a = arguments[2];
                      this._matrix[i][o] < a && (this._matrix[i][o] = a);
                    }
                  },
                },
                {
                  key: 'setAtLeastIfValid',
                  value: function (t, e, n) {
                    t >= 0 && e >= 0 && this.setAtLeast(t, e, n);
                  },
                },
                {
                  key: 'isWithin',
                  value: function () {
                    return (
                      e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                      this._matrix[W.INTERIOR][W.EXTERIOR] === Nt.FALSE &&
                      this._matrix[W.BOUNDARY][W.EXTERIOR] === Nt.FALSE
                    );
                  },
                },
                {
                  key: 'isTouches',
                  value: function (t, n) {
                    return t > n
                      ? this.isTouches(n, t)
                      : ((t === Nt.A && n === Nt.A) ||
                          (t === Nt.L && n === Nt.L) ||
                          (t === Nt.L && n === Nt.A) ||
                          (t === Nt.P && n === Nt.A) ||
                          (t === Nt.P && n === Nt.L)) &&
                          this._matrix[W.INTERIOR][W.INTERIOR] === Nt.FALSE &&
                          (e.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) ||
                            e.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) ||
                            e.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY]));
                  },
                },
                {
                  key: 'isOverlaps',
                  value: function (t, n) {
                    return (t === Nt.P && n === Nt.P) || (t === Nt.A && n === Nt.A)
                      ? e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                          e.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR]) &&
                          e.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR])
                      : t === Nt.L &&
                          n === Nt.L &&
                          1 === this._matrix[W.INTERIOR][W.INTERIOR] &&
                          e.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR]) &&
                          e.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR]);
                  },
                },
                {
                  key: 'isEquals',
                  value: function (t, n) {
                    return (
                      t === n &&
                      e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                      this._matrix[W.INTERIOR][W.EXTERIOR] === Nt.FALSE &&
                      this._matrix[W.BOUNDARY][W.EXTERIOR] === Nt.FALSE &&
                      this._matrix[W.EXTERIOR][W.INTERIOR] === Nt.FALSE &&
                      this._matrix[W.EXTERIOR][W.BOUNDARY] === Nt.FALSE
                    );
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    for (var t = new Qt('123456789'), e = 0; e < 3; e++)
                      for (var n = 0; n < 3; n++) t.setCharAt(3 * e + n, Nt.toDimensionSymbol(this._matrix[e][n]));
                    return t.toString();
                  },
                },
                {
                  key: 'setAll',
                  value: function (t) {
                    for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this._matrix[e][n] = t;
                  },
                },
                {
                  key: 'get',
                  value: function (t, e) {
                    return this._matrix[t][e];
                  },
                },
                {
                  key: 'transpose',
                  value: function () {
                    var t = this._matrix[1][0];
                    return (
                      (this._matrix[1][0] = this._matrix[0][1]),
                      (this._matrix[0][1] = t),
                      (t = this._matrix[2][0]),
                      (this._matrix[2][0] = this._matrix[0][2]),
                      (this._matrix[0][2] = t),
                      (t = this._matrix[2][1]),
                      (this._matrix[2][1] = this._matrix[1][2]),
                      (this._matrix[1][2] = t),
                      this
                    );
                  },
                },
                {
                  key: 'matches',
                  value: function (t) {
                    if (9 !== t.length) throw new b('Should be length 9: ' + t);
                    for (var n = 0; n < 3; n++)
                      for (var r = 0; r < 3; r++) if (!e.matches(this._matrix[n][r], t.charAt(3 * n + r))) return !1;
                    return !0;
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    for (var e = 0; e < 3; e++) for (var n = 0; n < 3; n++) this.setAtLeast(e, n, t.get(e, n));
                  },
                },
                {
                  key: 'isDisjoint',
                  value: function () {
                    return (
                      this._matrix[W.INTERIOR][W.INTERIOR] === Nt.FALSE &&
                      this._matrix[W.INTERIOR][W.BOUNDARY] === Nt.FALSE &&
                      this._matrix[W.BOUNDARY][W.INTERIOR] === Nt.FALSE &&
                      this._matrix[W.BOUNDARY][W.BOUNDARY] === Nt.FALSE
                    );
                  },
                },
                {
                  key: 'isCrosses',
                  value: function (t, n) {
                    return (t === Nt.P && n === Nt.L) || (t === Nt.P && n === Nt.A) || (t === Nt.L && n === Nt.A)
                      ? e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) && e.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR])
                      : (t === Nt.L && n === Nt.P) || (t === Nt.A && n === Nt.P) || (t === Nt.A && n === Nt.L)
                      ? e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) && e.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR])
                      : t === Nt.L && n === Nt.L && 0 === this._matrix[W.INTERIOR][W.INTERIOR];
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [w];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._matrix = null), 0 === arguments.length))
                      (this._matrix = Array(3)
                        .fill()
                        .map(function () {
                          return Array(3);
                        })),
                        this.setAll(Nt.FALSE);
                    else if (1 === arguments.length)
                      if ('string' == typeof arguments[0]) {
                        var t = arguments[0];
                        e.constructor_.call(this), this.set(t);
                      } else if (arguments[0] instanceof e) {
                        var n = arguments[0];
                        e.constructor_.call(this),
                          (this._matrix[W.INTERIOR][W.INTERIOR] = n._matrix[W.INTERIOR][W.INTERIOR]),
                          (this._matrix[W.INTERIOR][W.BOUNDARY] = n._matrix[W.INTERIOR][W.BOUNDARY]),
                          (this._matrix[W.INTERIOR][W.EXTERIOR] = n._matrix[W.INTERIOR][W.EXTERIOR]),
                          (this._matrix[W.BOUNDARY][W.INTERIOR] = n._matrix[W.BOUNDARY][W.INTERIOR]),
                          (this._matrix[W.BOUNDARY][W.BOUNDARY] = n._matrix[W.BOUNDARY][W.BOUNDARY]),
                          (this._matrix[W.BOUNDARY][W.EXTERIOR] = n._matrix[W.BOUNDARY][W.EXTERIOR]),
                          (this._matrix[W.EXTERIOR][W.INTERIOR] = n._matrix[W.EXTERIOR][W.INTERIOR]),
                          (this._matrix[W.EXTERIOR][W.BOUNDARY] = n._matrix[W.EXTERIOR][W.BOUNDARY]),
                          (this._matrix[W.EXTERIOR][W.EXTERIOR] = n._matrix[W.EXTERIOR][W.EXTERIOR]);
                      }
                  },
                },
                {
                  key: 'matches',
                  value: function () {
                    if (Number.isInteger(arguments[0]) && 'string' == typeof arguments[1]) {
                      var t = arguments[0],
                        n = arguments[1];
                      return (
                        n === Nt.SYM_DONTCARE ||
                        (n === Nt.SYM_TRUE && (t >= 0 || t === Nt.TRUE)) ||
                        (n === Nt.SYM_FALSE && t === Nt.FALSE) ||
                        (n === Nt.SYM_P && t === Nt.P) ||
                        (n === Nt.SYM_L && t === Nt.L) ||
                        (n === Nt.SYM_A && t === Nt.A)
                      );
                    }
                    if ('string' == typeof arguments[0] && 'string' == typeof arguments[1]) {
                      var r = arguments[1];
                      return new e(arguments[0]).matches(r);
                    }
                  },
                },
                {
                  key: 'isTrue',
                  value: function (t) {
                    return t >= 0 || t === Nt.TRUE;
                  },
                },
              ],
            ),
            e
          );
        })(),
        er = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'size',
                  value: function () {
                    return this._size;
                  },
                },
                {
                  key: 'addAll',
                  value: function (t) {
                    return null === t || 0 === t.length
                      ? null
                      : (this.ensureCapacity(this._size + t.length),
                        bt.arraycopy(t, 0, this._data, this._size, t.length),
                        void (this._size += t.length));
                  },
                },
                {
                  key: 'ensureCapacity',
                  value: function (t) {
                    if (t <= this._data.length) return null;
                    var e = Math.max(t, 2 * this._data.length);
                    this._data = At.copyOf(this._data, e);
                  },
                },
                {
                  key: 'toArray',
                  value: function () {
                    var t = new Array(this._size).fill(null);
                    return bt.arraycopy(this._data, 0, t, 0, this._size), t;
                  },
                },
                {
                  key: 'add',
                  value: function (t) {
                    this.ensureCapacity(this._size + 1), (this._data[this._size] = t), ++this._size;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (((this._data = null), (this._size = 0), 0 === arguments.length)) e.constructor_.call(this, 10);
                    else if (1 === arguments.length) {
                      var t = arguments[0];
                      this._data = new Array(t).fill(null);
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        nr = (function () {
          function e() {
            t(this, e);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getChainStartIndices',
                  value: function (t) {
                    var e = 0,
                      n = new er(Math.trunc(t.length / 2));
                    n.add(e);
                    do {
                      var r = this.findChainEnd(t, e);
                      n.add(r), (e = r);
                    } while (e < t.length - 1);
                    return n.toArray();
                  },
                },
                {
                  key: 'findChainEnd',
                  value: function (t, e) {
                    for (
                      var n = Ze.quadrant(t[e], t[e + 1]), r = e + 1;
                      r < t.length && Ze.quadrant(t[r - 1], t[r]) === n;

                    )
                      r++;
                    return r - 1;
                  },
                },
                {
                  key: 'OLDgetChainStartIndices',
                  value: function (t) {
                    var n = 0,
                      r = new vt();
                    r.add(n);
                    do {
                      var i = this.findChainEnd(t, n);
                      r.add(i), (n = i);
                    } while (n < t.length - 1);
                    return e.toIntArray(r);
                  },
                },
              ],
              [
                {
                  key: 'toIntArray',
                  value: function (t) {
                    for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++) e[n] = t.get(n).intValue();
                    return e;
                  },
                },
              ],
            ),
            e
          );
        })(),
        rr = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getCoordinates',
                  value: function () {
                    return this.pts;
                  },
                },
                {
                  key: 'getMaxX',
                  value: function (t) {
                    var e = this.pts[this.startIndex[t]].x,
                      n = this.pts[this.startIndex[t + 1]].x;
                    return e > n ? e : n;
                  },
                },
                {
                  key: 'getMinX',
                  value: function (t) {
                    var e = this.pts[this.startIndex[t]].x,
                      n = this.pts[this.startIndex[t + 1]].x;
                    return e < n ? e : n;
                  },
                },
                {
                  key: 'computeIntersectsForChain',
                  value: function () {
                    if (4 === arguments.length) {
                      var t = arguments[0],
                        e = arguments[1],
                        n = arguments[2],
                        r = arguments[3];
                      this.computeIntersectsForChain(
                        this.startIndex[t],
                        this.startIndex[t + 1],
                        e,
                        e.startIndex[n],
                        e.startIndex[n + 1],
                        r,
                      );
                    } else if (6 === arguments.length) {
                      var i = arguments[0],
                        o = arguments[1],
                        a = arguments[2],
                        s = arguments[3],
                        u = arguments[4],
                        l = arguments[5];
                      if (o - i == 1 && u - s == 1) return l.addIntersections(this.e, i, a.e, s), null;
                      if (!this.overlaps(i, o, a, s, u)) return null;
                      var c = Math.trunc((i + o) / 2),
                        h = Math.trunc((s + u) / 2);
                      i < c &&
                        (s < h && this.computeIntersectsForChain(i, c, a, s, h, l),
                        h < u && this.computeIntersectsForChain(i, c, a, h, u, l)),
                        c < o &&
                          (s < h && this.computeIntersectsForChain(c, o, a, s, h, l),
                          h < u && this.computeIntersectsForChain(c, o, a, h, u, l));
                    }
                  },
                },
                {
                  key: 'overlaps',
                  value: function (t, e, n, r, i) {
                    return U.intersects(this.pts[t], this.pts[e], n.pts[r], n.pts[i]);
                  },
                },
                {
                  key: 'getStartIndexes',
                  value: function () {
                    return this.startIndex;
                  },
                },
                {
                  key: 'computeIntersects',
                  value: function (t, e) {
                    for (var n = 0; n < this.startIndex.length - 1; n++)
                      for (var r = 0; r < t.startIndex.length - 1; r++) this.computeIntersectsForChain(n, t, r, e);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this.e = null), (this.pts = null), (this.startIndex = null);
                    var t = arguments[0];
                    (this.e = t), (this.pts = t.getCoordinates());
                    var e = new nr();
                    this.startIndex = e.getChainStartIndices(this.pts);
                  },
                },
              ],
            ),
            e
          );
        })(),
        ir = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'getDepth',
                  value: function (t, e) {
                    return this._depth[t][e];
                  },
                },
                {
                  key: 'setDepth',
                  value: function (t, e, n) {
                    this._depth[t][e] = n;
                  },
                },
                {
                  key: 'isNull',
                  value: function () {
                    if (0 === arguments.length) {
                      for (var t = 0; t < 2; t++)
                        for (var n = 0; n < 3; n++) if (this._depth[t][n] !== e.NULL_VALUE) return !1;
                      return !0;
                    }
                    if (1 === arguments.length) {
                      var r = arguments[0];
                      return this._depth[r][1] === e.NULL_VALUE;
                    }
                    if (2 === arguments.length) {
                      var i = arguments[0],
                        o = arguments[1];
                      return this._depth[i][o] === e.NULL_VALUE;
                    }
                  },
                },
                {
                  key: 'normalize',
                  value: function () {
                    for (var t = 0; t < 2; t++)
                      if (!this.isNull(t)) {
                        var e = this._depth[t][1];
                        this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0);
                        for (var n = 1; n < 3; n++) {
                          var r = 0;
                          this._depth[t][n] > e && (r = 1), (this._depth[t][n] = r);
                        }
                      }
                  },
                },
                {
                  key: 'getDelta',
                  value: function (t) {
                    return this._depth[t][tt.RIGHT] - this._depth[t][tt.LEFT];
                  },
                },
                {
                  key: 'getLocation',
                  value: function (t, e) {
                    return this._depth[t][e] <= 0 ? W.EXTERIOR : W.INTERIOR;
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    return (
                      'A: ' +
                      this._depth[0][1] +
                      ',' +
                      this._depth[0][2] +
                      ' B: ' +
                      this._depth[1][1] +
                      ',' +
                      this._depth[1][2]
                    );
                  },
                },
                {
                  key: 'add',
                  value: function () {
                    if (1 === arguments.length)
                      for (var t = arguments[0], n = 0; n < 2; n++)
                        for (var r = 1; r < 3; r++) {
                          var i = t.getLocation(n, r);
                          (i !== W.EXTERIOR && i !== W.INTERIOR) ||
                            (this.isNull(n, r)
                              ? (this._depth[n][r] = e.depthAtLocation(i))
                              : (this._depth[n][r] += e.depthAtLocation(i)));
                        }
                    else if (3 === arguments.length) {
                      var o = arguments[0],
                        a = arguments[1];
                      arguments[2] === W.INTERIOR && this._depth[o][a]++;
                    }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    this._depth = Array(2)
                      .fill()
                      .map(function () {
                        return Array(3);
                      });
                    for (var t = 0; t < 2; t++) for (var n = 0; n < 3; n++) this._depth[t][n] = e.NULL_VALUE;
                  },
                },
                {
                  key: 'depthAtLocation',
                  value: function (t) {
                    return t === W.EXTERIOR ? 0 : t === W.INTERIOR ? 1 : e.NULL_VALUE;
                  },
                },
              ],
            ),
            e
          );
        })();
      ir.NULL_VALUE = -1;
      var or = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'getDepth',
                  value: function () {
                    return this._depth;
                  },
                },
                {
                  key: 'getCollapsedEdge',
                  value: function () {
                    var t = new Array(2).fill(null);
                    return (t[0] = this.pts[0]), (t[1] = this.pts[1]), new a(t, Ae.toLineLabel(this._label));
                  },
                },
                {
                  key: 'isIsolated',
                  value: function () {
                    return this._isIsolated;
                  },
                },
                {
                  key: 'getCoordinates',
                  value: function () {
                    return this.pts;
                  },
                },
                {
                  key: 'setIsolated',
                  value: function (t) {
                    this._isIsolated = t;
                  },
                },
                {
                  key: 'setName',
                  value: function (t) {
                    this._name = t;
                  },
                },
                {
                  key: 'equals',
                  value: function (t) {
                    if (!(t instanceof a)) return !1;
                    var e = t;
                    if (this.pts.length !== e.pts.length) return !1;
                    for (var n = !0, r = !0, i = this.pts.length, o = 0; o < this.pts.length; o++)
                      if (
                        (this.pts[o].equals2D(e.pts[o]) || (n = !1),
                        this.pts[o].equals2D(e.pts[--i]) || (r = !1),
                        !n && !r)
                      )
                        return !1;
                    return !0;
                  },
                },
                {
                  key: 'getCoordinate',
                  value: function () {
                    if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null;
                    if (1 === arguments.length) {
                      var t = arguments[0];
                      return this.pts[t];
                    }
                  },
                },
                {
                  key: 'print',
                  value: function (t) {
                    t.print('edge ' + this._name + ': '), t.print('LINESTRING (');
                    for (var e = 0; e < this.pts.length; e++)
                      e > 0 && t.print(','), t.print(this.pts[e].x + ' ' + this.pts[e].y);
                    t.print(')  ' + this._label + ' ' + this._depthDelta);
                  },
                },
                {
                  key: 'computeIM',
                  value: function (t) {
                    a.updateIM(this._label, t);
                  },
                },
                {
                  key: 'isCollapsed',
                  value: function () {
                    return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]);
                  },
                },
                {
                  key: 'isClosed',
                  value: function () {
                    return this.pts[0].equals(this.pts[this.pts.length - 1]);
                  },
                },
                {
                  key: 'getMaximumSegmentIndex',
                  value: function () {
                    return this.pts.length - 1;
                  },
                },
                {
                  key: 'getDepthDelta',
                  value: function () {
                    return this._depthDelta;
                  },
                },
                {
                  key: 'getNumPoints',
                  value: function () {
                    return this.pts.length;
                  },
                },
                {
                  key: 'printReverse',
                  value: function (t) {
                    t.print('edge ' + this._name + ': ');
                    for (var e = this.pts.length - 1; e >= 0; e--) t.print(this.pts[e] + ' ');
                    t.println('');
                  },
                },
                {
                  key: 'getMonotoneChainEdge',
                  value: function () {
                    return null === this._mce && (this._mce = new rr(this)), this._mce;
                  },
                },
                {
                  key: 'getEnvelope',
                  value: function () {
                    if (null === this._env) {
                      this._env = new U();
                      for (var t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t]);
                    }
                    return this._env;
                  },
                },
                {
                  key: 'addIntersection',
                  value: function (t, e, n, r) {
                    var i = new Y(t.getIntersection(r)),
                      o = e,
                      a = t.getEdgeDistance(n, r),
                      s = o + 1;
                    if (s < this.pts.length) {
                      var u = this.pts[s];
                      i.equals2D(u) && ((o = s), (a = 0));
                    }
                    this.eiList.add(i, o, a);
                  },
                },
                {
                  key: 'toString',
                  value: function () {
                    var t = new Qt();
                    t.append('edge ' + this._name + ': '), t.append('LINESTRING (');
                    for (var e = 0; e < this.pts.length; e++)
                      e > 0 && t.append(','), t.append(this.pts[e].x + ' ' + this.pts[e].y);
                    return t.append(')  ' + this._label + ' ' + this._depthDelta), t.toString();
                  },
                },
                {
                  key: 'isPointwiseEqual',
                  value: function (t) {
                    if (this.pts.length !== t.pts.length) return !1;
                    for (var e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1;
                    return !0;
                  },
                },
                {
                  key: 'setDepthDelta',
                  value: function (t) {
                    this._depthDelta = t;
                  },
                },
                {
                  key: 'getEdgeIntersectionList',
                  value: function () {
                    return this.eiList;
                  },
                },
                {
                  key: 'addIntersections',
                  value: function (t, e, n) {
                    for (var r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this.pts = null),
                      (this._env = null),
                      (this.eiList = new Kn(this)),
                      (this._name = null),
                      (this._mce = null),
                      (this._isIsolated = !0),
                      (this._depth = new ir()),
                      (this._depthDelta = 0),
                      1 === arguments.length)
                    ) {
                      var t = arguments[0];
                      a.constructor_.call(this, t, null);
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      (this.pts = e), (this._label = n);
                    }
                  },
                },
                {
                  key: 'updateIM',
                  value: function () {
                    if (!(2 === arguments.length && arguments[1] instanceof tr && arguments[0] instanceof Ae))
                      return p(o(a), 'updateIM', this).apply(this, arguments);
                    var t = arguments[0],
                      e = arguments[1];
                    e.setAtLeastIfValid(t.getLocation(0, tt.ON), t.getLocation(1, tt.ON), 1),
                      t.isArea() &&
                        (e.setAtLeastIfValid(t.getLocation(0, tt.LEFT), t.getLocation(1, tt.LEFT), 2),
                        e.setAtLeastIfValid(t.getLocation(0, tt.RIGHT), t.getLocation(1, tt.RIGHT), 2));
                  },
                },
              ],
            ),
            a
          );
        })(Be),
        ar = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'setWorkingPrecisionModel',
                  value: function (t) {
                    this._workingPrecisionModel = t;
                  },
                },
                {
                  key: 'insertUniqueEdge',
                  value: function (t) {
                    var n = this._edgeList.findEqualEdge(t);
                    if (null !== n) {
                      var r = n.getLabel(),
                        i = t.getLabel();
                      n.isPointwiseEqual(t) || (i = new Ae(t.getLabel())).flip(), r.merge(i);
                      var o = e.depthDelta(i),
                        a = n.getDepthDelta() + o;
                      n.setDepthDelta(a);
                    } else this._edgeList.add(t), t.setDepthDelta(e.depthDelta(t.getLabel()));
                  },
                },
                {
                  key: 'buildSubgraphs',
                  value: function (t, e) {
                    for (var n = new vt(), r = t.iterator(); r.hasNext(); ) {
                      var i = r.next(),
                        o = i.getRightmostCoordinate(),
                        a = new Dn(n).getDepth(o);
                      i.computeDepth(a), i.findResultEdges(), n.add(i), e.add(i.getDirectedEdges(), i.getNodes());
                    }
                  },
                },
                {
                  key: 'createSubgraphs',
                  value: function (t) {
                    for (var e = new vt(), n = t.getNodes().iterator(); n.hasNext(); ) {
                      var r = n.next();
                      if (!r.isVisited()) {
                        var i = new mt();
                        i.create(r), e.add(i);
                      }
                    }
                    return sn.sort(e, sn.reverseOrder()), e;
                  },
                },
                {
                  key: 'createEmptyResultGeometry',
                  value: function () {
                    return this._geomFact.createPolygon();
                  },
                },
                {
                  key: 'getNoder',
                  value: function (t) {
                    if (null !== this._workingNoder) return this._workingNoder;
                    var e = new Mn(),
                      n = new Le();
                    return n.setPrecisionModel(t), e.setSegmentIntersector(new $n(n)), e;
                  },
                },
                {
                  key: 'buffer',
                  value: function (t, e) {
                    var n = this._workingPrecisionModel;
                    null === n && (n = t.getPrecisionModel()), (this._geomFact = t.getFactory());
                    var r = new An(n, this._bufParams),
                      i = new Vn(t, e, r).getCurves();
                    if (i.size() <= 0) return this.createEmptyResultGeometry();
                    this.computeNodedEdges(i, n),
                      (this._graph = new Ke(new Wn())),
                      this._graph.addEdges(this._edgeList.getEdges());
                    var o = this.createSubgraphs(this._graph),
                      a = new tn(this._geomFact);
                    this.buildSubgraphs(o, a);
                    var s = a.getPolygons();
                    return s.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(s);
                  },
                },
                {
                  key: 'computeNodedEdges',
                  value: function (t, e) {
                    var n = this.getNoder(e);
                    n.computeNodes(t);
                    for (var r = n.getNodedSubstrings().iterator(); r.hasNext(); ) {
                      var i = r.next(),
                        o = i.getCoordinates();
                      if (2 !== o.length || !o[0].equals2D(o[1])) {
                        var a = i.getData(),
                          s = new or(i.getCoordinates(), new Ae(a));
                        this.insertUniqueEdge(s);
                      }
                    }
                  },
                },
                {
                  key: 'setNoder',
                  value: function (t) {
                    this._workingNoder = t;
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._bufParams = null),
                      (this._workingPrecisionModel = null),
                      (this._workingNoder = null),
                      (this._geomFact = null),
                      (this._graph = null),
                      (this._edgeList = new Zn());
                    var t = arguments[0];
                    this._bufParams = t;
                  },
                },
                {
                  key: 'depthDelta',
                  value: function (t) {
                    var e = t.getLocation(0, tt.LEFT),
                      n = t.getLocation(0, tt.RIGHT);
                    return e === W.INTERIOR && n === W.EXTERIOR ? 1 : e === W.EXTERIOR && n === W.INTERIOR ? -1 : 0;
                  },
                },
                {
                  key: 'convertSegStrings',
                  value: function (t) {
                    for (var e = new se(), n = new vt(); t.hasNext(); ) {
                      var r = t.next(),
                        i = e.createLineString(r.getCoordinates());
                      n.add(i);
                    }
                    return e.buildGeometry(n);
                  },
                },
              ],
            ),
            e
          );
        })(),
        sr = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'rescale',
                  value: function () {
                    if (ot(arguments[0], H))
                      for (var t = arguments[0].iterator(); t.hasNext(); ) {
                        var e = t.next();
                        this.rescale(e.getCoordinates());
                      }
                    else if (arguments[0] instanceof Array) {
                      for (var n = arguments[0], r = 0; r < n.length; r++)
                        (n[r].x = n[r].x / this._scaleFactor + this._offsetX),
                          (n[r].y = n[r].y / this._scaleFactor + this._offsetY);
                      2 === n.length && n[0].equals2D(n[1]) && bt.out.println(n);
                    }
                  },
                },
                {
                  key: 'scale',
                  value: function () {
                    if (ot(arguments[0], H)) {
                      for (var t = arguments[0], e = new vt(t.size()), n = t.iterator(); n.hasNext(); ) {
                        var r = n.next();
                        e.add(new En(this.scale(r.getCoordinates()), r.getData()));
                      }
                      return e;
                    }
                    if (arguments[0] instanceof Array) {
                      for (var i = arguments[0], o = new Array(i.length).fill(null), a = 0; a < i.length; a++)
                        o[a] = new Y(
                          Math.round((i[a].x - this._offsetX) * this._scaleFactor),
                          Math.round((i[a].y - this._offsetY) * this._scaleFactor),
                          i[a].getZ(),
                        );
                      return Zt.removeRepeatedPoints(o);
                    }
                  },
                },
                {
                  key: 'isIntegerPrecision',
                  value: function () {
                    return 1 === this._scaleFactor;
                  },
                },
                {
                  key: 'getNodedSubstrings',
                  value: function () {
                    var t = this._noder.getNodedSubstrings();
                    return this._isScaled && this.rescale(t), t;
                  },
                },
                {
                  key: 'computeNodes',
                  value: function (t) {
                    var e = t;
                    this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e);
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Pn];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._noder = null),
                      (this._scaleFactor = null),
                      (this._offsetX = null),
                      (this._offsetY = null),
                      (this._isScaled = !1),
                      2 === arguments.length)
                    ) {
                      var t = arguments[0],
                        n = arguments[1];
                      e.constructor_.call(this, t, n, 0, 0);
                    } else if (4 === arguments.length) {
                      var r = arguments[0],
                        i = arguments[1];
                      (this._noder = r), (this._scaleFactor = i), (this._isScaled = !this.isIntegerPrecision());
                    }
                  },
                },
              ],
            ),
            e
          );
        })(),
        ur = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'checkEndPtVertexIntersections',
                  value: function () {
                    if (0 === arguments.length)
                      for (var t = this._segStrings.iterator(); t.hasNext(); ) {
                        var e = t.next().getCoordinates();
                        this.checkEndPtVertexIntersections(e[0], this._segStrings),
                          this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings);
                      }
                    else if (2 === arguments.length)
                      for (var n = arguments[0], r = arguments[1].iterator(); r.hasNext(); )
                        for (var i = r.next().getCoordinates(), o = 1; o < i.length - 1; o++)
                          if (i[o].equals(n))
                            throw new j('found endpt/interior pt intersection at index ' + o + ' :pt ' + n);
                  },
                },
                {
                  key: 'checkInteriorIntersections',
                  value: function () {
                    if (0 === arguments.length)
                      for (var t = this._segStrings.iterator(); t.hasNext(); )
                        for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext(); ) {
                          var r = n.next();
                          this.checkInteriorIntersections(e, r);
                        }
                    else if (2 === arguments.length)
                      for (
                        var i = arguments[0], o = arguments[1], a = i.getCoordinates(), s = o.getCoordinates(), u = 0;
                        u < a.length - 1;
                        u++
                      )
                        for (var l = 0; l < s.length - 1; l++) this.checkInteriorIntersections(i, u, o, l);
                    else if (4 === arguments.length) {
                      var c = arguments[0],
                        h = arguments[1],
                        f = arguments[2],
                        p = arguments[3];
                      if (c === f && h === p) return null;
                      var g = c.getCoordinates()[h],
                        y = c.getCoordinates()[h + 1],
                        v = f.getCoordinates()[p],
                        d = f.getCoordinates()[p + 1];
                      if (
                        (this._li.computeIntersection(g, y, v, d),
                        this._li.hasIntersection() &&
                          (this._li.isProper() ||
                            this.hasInteriorIntersection(this._li, g, y) ||
                            this.hasInteriorIntersection(this._li, v, d)))
                      )
                        throw new j('found non-noded intersection at ' + g + '-' + y + ' and ' + v + '-' + d);
                    }
                  },
                },
                {
                  key: 'checkValid',
                  value: function () {
                    this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
                  },
                },
                {
                  key: 'checkCollapses',
                  value: function () {
                    if (0 === arguments.length)
                      for (var t = this._segStrings.iterator(); t.hasNext(); ) {
                        var e = t.next();
                        this.checkCollapses(e);
                      }
                    else if (1 === arguments.length)
                      for (var n = arguments[0].getCoordinates(), r = 0; r < n.length - 2; r++)
                        this.checkCollapse(n[r], n[r + 1], n[r + 2]);
                  },
                },
                {
                  key: 'hasInteriorIntersection',
                  value: function (t, e, n) {
                    for (var r = 0; r < t.getIntersectionNum(); r++) {
                      var i = t.getIntersection(r);
                      if (!i.equals(e) && !i.equals(n)) return !0;
                    }
                    return !1;
                  },
                },
                {
                  key: 'checkCollapse',
                  value: function (t, n, r) {
                    if (t.equals(r)) throw new j('found non-noded collapse at ' + e.fact.createLineString([t, n, r]));
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._li = new Le()), (this._segStrings = null);
                    var t = arguments[0];
                    this._segStrings = t;
                  },
                },
              ],
            ),
            e
          );
        })();
      ur.fact = new se();
      var lr = (function () {
        function e() {
          t(this, e), e.constructor_.apply(this, arguments);
        }
        return (
          r(
            e,
            [
              {
                key: 'intersectsScaled',
                value: function (t, e) {
                  var n = Math.min(t.x, e.x),
                    r = Math.max(t.x, e.x),
                    i = Math.min(t.y, e.y),
                    o = Math.max(t.y, e.y),
                    a = this._maxx < n || this._minx > r || this._maxy < i || this._miny > o;
                  if (a) return !1;
                  var s = this.intersectsToleranceSquare(t, e);
                  return B.isTrue(!(a && s), 'Found bad envelope test'), s;
                },
              },
              {
                key: 'initCorners',
                value: function (t) {
                  var e = 0.5;
                  (this._minx = t.x - e),
                    (this._maxx = t.x + e),
                    (this._miny = t.y - e),
                    (this._maxy = t.y + e),
                    (this._corner[0] = new Y(this._maxx, this._maxy)),
                    (this._corner[1] = new Y(this._minx, this._maxy)),
                    (this._corner[2] = new Y(this._minx, this._miny)),
                    (this._corner[3] = new Y(this._maxx, this._miny));
                },
              },
              {
                key: 'intersects',
                value: function (t, e) {
                  return 1 === this._scaleFactor
                    ? this.intersectsScaled(t, e)
                    : (this.copyScaled(t, this._p0Scaled),
                      this.copyScaled(e, this._p1Scaled),
                      this.intersectsScaled(this._p0Scaled, this._p1Scaled));
                },
              },
              {
                key: 'scale',
                value: function (t) {
                  return Math.round(t * this._scaleFactor);
                },
              },
              {
                key: 'getCoordinate',
                value: function () {
                  return this._originalPt;
                },
              },
              {
                key: 'copyScaled',
                value: function (t, e) {
                  (e.x = this.scale(t.x)), (e.y = this.scale(t.y));
                },
              },
              {
                key: 'getSafeEnvelope',
                value: function () {
                  if (null === this._safeEnv) {
                    var t = e.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
                    this._safeEnv = new U(
                      this._originalPt.x - t,
                      this._originalPt.x + t,
                      this._originalPt.y - t,
                      this._originalPt.y + t,
                    );
                  }
                  return this._safeEnv;
                },
              },
              {
                key: 'intersectsPixelClosure',
                value: function (t, e) {
                  return (
                    this._li.computeIntersection(t, e, this._corner[0], this._corner[1]),
                    !!(
                      this._li.hasIntersection() ||
                      (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]),
                      this._li.hasIntersection() ||
                        (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]),
                        this._li.hasIntersection() ||
                          (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]),
                          this._li.hasIntersection())))
                    )
                  );
                },
              },
              {
                key: 'intersectsToleranceSquare',
                value: function (t, e) {
                  var n = !1,
                    r = !1;
                  return (
                    this._li.computeIntersection(t, e, this._corner[0], this._corner[1]),
                    !!(
                      this._li.isProper() ||
                      (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]),
                      this._li.isProper() ||
                        (this._li.hasIntersection() && (n = !0),
                        this._li.computeIntersection(t, e, this._corner[2], this._corner[3]),
                        this._li.isProper() ||
                          (this._li.hasIntersection() && (r = !0),
                          this._li.computeIntersection(t, e, this._corner[3], this._corner[0]),
                          this._li.isProper() || (n && r) || t.equals(this._pt) || e.equals(this._pt))))
                    )
                  );
                },
              },
              {
                key: 'addSnappedNode',
                value: function (t, e) {
                  var n = t.getCoordinate(e),
                    r = t.getCoordinate(e + 1);
                  return !!this.intersects(n, r) && (t.addIntersection(this.getCoordinate(), e), !0);
                },
              },
            ],
            [
              {
                key: 'constructor_',
                value: function () {
                  (this._li = null),
                    (this._pt = null),
                    (this._originalPt = null),
                    (this._ptScaled = null),
                    (this._p0Scaled = null),
                    (this._p1Scaled = null),
                    (this._scaleFactor = null),
                    (this._minx = null),
                    (this._maxx = null),
                    (this._miny = null),
                    (this._maxy = null),
                    (this._corner = new Array(4).fill(null)),
                    (this._safeEnv = null);
                  var t = arguments[0],
                    e = arguments[1],
                    n = arguments[2];
                  if (((this._originalPt = t), (this._pt = t), (this._scaleFactor = e), (this._li = n), e <= 0))
                    throw new b('Scale factor must be non-zero');
                  1 !== e &&
                    ((this._pt = new Y(this.scale(t.x), this.scale(t.y))),
                    (this._p0Scaled = new Y()),
                    (this._p1Scaled = new Y())),
                    this.initCorners(this._pt);
                },
              },
            ],
          ),
          e
        );
      })();
      lr.SAFE_ENV_EXPANSION_FACTOR = 0.75;
      var cr = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'select',
                  value: function () {
                    if (1 === arguments.length);
                    else if (2 === arguments.length) {
                      var t = arguments[1];
                      arguments[0].getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment);
                    }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    this.selectedSegment = new wn();
                  },
                },
              ],
            ),
            e
          );
        })(),
        hr = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'snap',
                  value: function () {
                    if (1 === arguments.length) {
                      var e = arguments[0];
                      return this.snap(e, null, -1);
                    }
                    if (3 === arguments.length) {
                      var n = arguments[0],
                        i = arguments[1],
                        o = arguments[2],
                        a = n.getSafeEnvelope(),
                        s = new fr(n, i, o);
                      return (
                        this._index.query(
                          a,
                          new ((function () {
                            function e() {
                              t(this, e);
                            }
                            return (
                              r(e, [
                                {
                                  key: 'interfaces_',
                                  get: function () {
                                    return [cn];
                                  },
                                },
                                {
                                  key: 'visitItem',
                                  value: function (t) {
                                    t.select(a, s);
                                  },
                                },
                              ]),
                              e
                            );
                          })())(),
                        ),
                        s.isNodeAdded()
                      );
                    }
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    this._index = null;
                    var t = arguments[0];
                    this._index = t;
                  },
                },
              ],
            ),
            e
          );
        })(),
        fr = (function (e) {
          i(a, e);
          var n = f(a);
          function a() {
            var e;
            return t(this, a), (e = n.call(this)), a.constructor_.apply(c(e), arguments), e;
          }
          return (
            r(
              a,
              [
                {
                  key: 'isNodeAdded',
                  value: function () {
                    return this._isNodeAdded;
                  },
                },
                {
                  key: 'select',
                  value: function () {
                    if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Sn))
                      return p(o(a.prototype), 'select', this).apply(this, arguments);
                    var t = arguments[1],
                      e = arguments[0].getContext();
                    if (
                      this._parentEdge === e &&
                      (t === this._hotPixelVertexIndex || t + 1 === this._hotPixelVertexIndex)
                    )
                      return null;
                    this._isNodeAdded |= this._hotPixel.addSnappedNode(e, t);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._hotPixel = null),
                      (this._parentEdge = null),
                      (this._hotPixelVertexIndex = null),
                      (this._isNodeAdded = !1);
                    var t = arguments[0],
                      e = arguments[1],
                      n = arguments[2];
                    (this._hotPixel = t), (this._parentEdge = e), (this._hotPixelVertexIndex = n);
                  },
                },
              ],
            ),
            a
          );
        })(cr);
      hr.HotPixelSnapAction = fr;
      var pr = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'processIntersections',
                  value: function (t, e, n, r) {
                    if (t === n && e === r) return null;
                    var i = t.getCoordinates()[e],
                      o = t.getCoordinates()[e + 1],
                      a = n.getCoordinates()[r],
                      s = n.getCoordinates()[r + 1];
                    if (
                      (this._li.computeIntersection(i, o, a, s),
                      this._li.hasIntersection() && this._li.isInteriorIntersection())
                    ) {
                      for (var u = 0; u < this._li.getIntersectionNum(); u++)
                        this._interiorIntersections.add(this._li.getIntersection(u));
                      t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1);
                    }
                  },
                },
                {
                  key: 'isDone',
                  value: function () {
                    return !1;
                  },
                },
                {
                  key: 'getInteriorIntersections',
                  value: function () {
                    return this._interiorIntersections;
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Jn];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._li = null), (this._interiorIntersections = null);
                    var t = arguments[0];
                    (this._li = t), (this._interiorIntersections = new vt());
                  },
                },
              ],
            ),
            e
          );
        })(),
        gr = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'checkCorrectness',
                  value: function (t) {
                    var e = En.getNodedSubstrings(t),
                      n = new ur(e);
                    try {
                      n.checkValid();
                    } catch (t) {
                      if (!(t instanceof _)) throw t;
                      t.printStackTrace();
                    }
                  },
                },
                {
                  key: 'getNodedSubstrings',
                  value: function () {
                    return En.getNodedSubstrings(this._nodedSegStrings);
                  },
                },
                {
                  key: 'snapRound',
                  value: function (t, e) {
                    var n = this.findInteriorIntersections(t, e);
                    this.computeIntersectionSnaps(n), this.computeVertexSnaps(t);
                  },
                },
                {
                  key: 'findInteriorIntersections',
                  value: function (t, e) {
                    var n = new pr(e);
                    return (
                      this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections()
                    );
                  },
                },
                {
                  key: 'computeVertexSnaps',
                  value: function () {
                    if (ot(arguments[0], H))
                      for (var t = arguments[0].iterator(); t.hasNext(); ) {
                        var e = t.next();
                        this.computeVertexSnaps(e);
                      }
                    else if (arguments[0] instanceof En)
                      for (var n = arguments[0], r = n.getCoordinates(), i = 0; i < r.length; i++) {
                        var o = new lr(r[i], this._scaleFactor, this._li);
                        this._pointSnapper.snap(o, n, i) && n.addIntersection(r[i], i);
                      }
                  },
                },
                {
                  key: 'computeNodes',
                  value: function (t) {
                    (this._nodedSegStrings = t),
                      (this._noder = new Mn()),
                      (this._pointSnapper = new hr(this._noder.getIndex())),
                      this.snapRound(t, this._li);
                  },
                },
                {
                  key: 'computeIntersectionSnaps',
                  value: function (t) {
                    for (var e = t.iterator(); e.hasNext(); ) {
                      var n = e.next(),
                        r = new lr(n, this._scaleFactor, this._li);
                      this._pointSnapper.snap(r);
                    }
                  },
                },
                {
                  key: 'interfaces_',
                  get: function () {
                    return [Pn];
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    (this._pm = null),
                      (this._li = null),
                      (this._scaleFactor = null),
                      (this._noder = null),
                      (this._pointSnapper = null),
                      (this._nodedSegStrings = null);
                    var t = arguments[0];
                    (this._pm = t),
                      (this._li = new Le()),
                      this._li.setPrecisionModel(t),
                      (this._scaleFactor = t.getScale());
                  },
                },
              ],
            ),
            e
          );
        })(),
        yr = (function () {
          function e() {
            t(this, e), e.constructor_.apply(this, arguments);
          }
          return (
            r(
              e,
              [
                {
                  key: 'bufferFixedPrecision',
                  value: function (t) {
                    var e = new sr(new gr(new ie(1)), t.getScale()),
                      n = new ar(this._bufParams);
                    n.setWorkingPrecisionModel(t),
                      n.setNoder(e),
                      (this._resultGeometry = n.buffer(this._argGeom, this._distance));
                  },
                },
                {
                  key: 'bufferReducedPrecision',
                  value: function () {
                    if (0 === arguments.length) {
                      for (var t = e.MAX_PRECISION_DIGITS; t >= 0; t--) {
                        try {
                          this.bufferReducedPrecision(t);
                        } catch (t) {
                          if (!(t instanceof gt)) throw t;
                          this._saveException = t;
                        }
                        if (null !== this._resultGeometry) return null;
                      }
                      throw this._saveException;
                    }
                    if (1 === arguments.length) {
                      var n = arguments[0],
                        r = e.precisionScaleFactor(this._argGeom, this._distance, n),
                        i = new ie(r);
                      this.bufferFixedPrecision(i);
                    }
                  },
                },
                {
                  key: 'computeGeometry',
                  value: function () {
                    if ((this.bufferOriginalPrecision(), null !== this._resultGeometry)) return null;
                    var t = this._argGeom.getFactory().getPrecisionModel();
                    t.getType() === ie.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision();
                  },
                },
                {
                  key: 'setQuadrantSegments',
                  value: function (t) {
                    this._bufParams.setQuadrantSegments(t);
                  },
                },
                {
                  key: 'bufferOriginalPrecision',
                  value: function () {
                    try {
                      var t = new ar(this._bufParams);
                      this._resultGeometry = t.buffer(this._argGeom, this._distance);
                    } catch (t) {
                      if (!(t instanceof j)) throw t;
                      this._saveException = t;
                    }
                  },
                },
                {
                  key: 'getResultGeometry',
                  value: function (t) {
                    return (this._distance = t), this.computeGeometry(), this._resultGeometry;
                  },
                },
                {
                  key: 'setEndCapStyle',
                  value: function (t) {
                    this._bufParams.setEndCapStyle(t);
                  },
                },
              ],
              [
                {
                  key: 'constructor_',
                  value: function () {
                    if (
                      ((this._argGeom = null),
                      (this._distance = null),
                      (this._bufParams = new m()),
                      (this._resultGeometry = null),
                      (this._saveException = null),
                      1 === arguments.length)
                    ) {
                      var t = arguments[0];
                      this._argGeom = t;
                    } else if (2 === arguments.length) {
                      var e = arguments[0],
                        n = arguments[1];
                      (this._argGeom = e), (this._bufParams = n);
                    }
                  },
                },
                {
                  key: 'bufferOp',
                  value: function () {
                    if (2 === arguments.length) {
                      var t = arguments[1];
                      return new e(arguments[0]).getResultGeometry(t);
                    }
                    if (3 === arguments.length) {
                      if (
                        Number.isInteger(arguments[2]) &&
                        arguments[0] instanceof X &&
                        'number' == typeof arguments[1]
                      ) {
                        var n = arguments[1],
                          r = arguments[2],
                          i = new e(arguments[0]);
                        return i.setQuadrantSegments(r), i.getResultGeometry(n);
                      }
                      if (arguments[2] instanceof m && arguments[0] instanceof X && 'number' == typeof arguments[1]) {
                        var o = arguments[1];
                        return new e(arguments[0], arguments[2]).getResultGeometry(o);
                      }
                    } else if (4 === arguments.length) {
                      var a = arguments[1],
                        s = arguments[2],
                        u = arguments[3],
                        l = new e(arguments[0]);
                      return l.setQuadrantSegments(s), l.setEndCapStyle(u), l.getResultGeometry(a);
                    }
                  },
                },
                {
                  key: 'precisionScaleFactor',
                  value: function (t, e, n) {
                    var r = t.getEnvelopeInternal(),
                      i =
                        xt.max(
                          Math.abs(r.getMaxX()),
                          Math.abs(r.getMaxY()),
                          Math.abs(r.getMinX()),
                          Math.abs(r.getMinY()),
                        ) +
                        2 * (e > 0 ? e : 0),
                      o = n - Math.trunc(Math.log(i) / Math.log(10) + 1);
                    return Math.pow(10, o);
                  },
                },
              ],
            ),
            e
          );
        })();
      (yr.CAP_ROUND = m.CAP_ROUND),
        (yr.CAP_BUTT = m.CAP_FLAT),
        (yr.CAP_FLAT = m.CAP_FLAT),
        (yr.CAP_SQUARE = m.CAP_SQUARE),
        (yr.MAX_PRECISION_DIGITS = 12);
      var vr = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'],
        dr = (function () {
          function e(n) {
            t(this, e), (this.geometryFactory = n || new se());
          }
          return (
            r(e, [
              {
                key: 'read',
                value: function (t) {
                  var e,
                    n = (e = 'string' == typeof t ? JSON.parse(t) : t).type;
                  if (!mr[n]) throw new Error('Unknown GeoJSON type: ' + e.type);
                  return -1 !== vr.indexOf(n)
                    ? mr[n].call(this, e.coordinates)
                    : 'GeometryCollection' === n
                    ? mr[n].call(this, e.geometries)
                    : mr[n].call(this, e);
                },
              },
              {
                key: 'write',
                value: function (t) {
                  var e = t.getGeometryType();
                  if (!_r[e]) throw new Error('Geometry is not supported');
                  return _r[e].call(this, t);
                },
              },
            ]),
            e
          );
        })(),
        mr = {
          Feature: function (t) {
            var e = {};
            for (var n in t) e[n] = t[n];
            if (t.geometry) {
              var r = t.geometry.type;
              if (!mr[r]) throw new Error('Unknown GeoJSON type: ' + t.type);
              e.geometry = this.read(t.geometry);
            }
            return t.bbox && (e.bbox = mr.bbox.call(this, t.bbox)), e;
          },
          FeatureCollection: function (t) {
            var e = {};
            if (t.features) {
              e.features = [];
              for (var n = 0; n < t.features.length; ++n) e.features.push(this.read(t.features[n]));
            }
            return t.bbox && (e.bbox = this.parse.bbox.call(this, t.bbox)), e;
          },
          coordinates: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) {
              var r = t[n];
              e.push(u(Y, g(r)));
            }
            return e;
          },
          bbox: function (t) {
            return this.geometryFactory.createLinearRing([
              new Y(t[0], t[1]),
              new Y(t[2], t[1]),
              new Y(t[2], t[3]),
              new Y(t[0], t[3]),
              new Y(t[0], t[1]),
            ]);
          },
          Point: function (t) {
            var e = u(Y, g(t));
            return this.geometryFactory.createPoint(e);
          },
          MultiPoint: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) e.push(mr.Point.call(this, t[n]));
            return this.geometryFactory.createMultiPoint(e);
          },
          LineString: function (t) {
            var e = mr.coordinates.call(this, t);
            return this.geometryFactory.createLineString(e);
          },
          MultiLineString: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) e.push(mr.LineString.call(this, t[n]));
            return this.geometryFactory.createMultiLineString(e);
          },
          Polygon: function (t) {
            for (
              var e = mr.coordinates.call(this, t[0]), n = this.geometryFactory.createLinearRing(e), r = [], i = 1;
              i < t.length;
              ++i
            ) {
              var o = t[i],
                a = mr.coordinates.call(this, o),
                s = this.geometryFactory.createLinearRing(a);
              r.push(s);
            }
            return this.geometryFactory.createPolygon(n, r);
          },
          MultiPolygon: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) {
              var r = t[n];
              e.push(mr.Polygon.call(this, r));
            }
            return this.geometryFactory.createMultiPolygon(e);
          },
          GeometryCollection: function (t) {
            for (var e = [], n = 0; n < t.length; ++n) {
              var r = t[n];
              e.push(this.read(r));
            }
            return this.geometryFactory.createGeometryCollection(e);
          },
        },
        _r = {
          coordinate: function (t) {
            var e = [t.x, t.y];
            return t.z && e.push(t.z), t.m && e.push(t.m), e;
          },
          Point: function (t) {
            return { type: 'Point', coordinates: _r.coordinate.call(this, t.getCoordinate()) };
          },
          MultiPoint: function (t) {
            for (var e = [], n = 0; n < t._geometries.length; ++n) {
              var r = t._geometries[n],
                i = _r.Point.call(this, r);
              e.push(i.coordinates);
            }
            return { type: 'MultiPoint', coordinates: e };
          },
          LineString: function (t) {
            for (var e = [], n = t.getCoordinates(), r = 0; r < n.length; ++r) {
              var i = n[r];
              e.push(_r.coordinate.call(this, i));
            }
            return { type: 'LineString', coordinates: e };
          },
          MultiLineString: function (t) {
            for (var e = [], n = 0; n < t._geometries.length; ++n) {
              var r = t._geometries[n],
                i = _r.LineString.call(this, r);
              e.push(i.coordinates);
            }
            return { type: 'MultiLineString', coordinates: e };
          },
          Polygon: function (t) {
            var e = [],
              n = _r.LineString.call(this, t._shell);
            e.push(n.coordinates);
            for (var r = 0; r < t._holes.length; ++r) {
              var i = t._holes[r],
                o = _r.LineString.call(this, i);
              e.push(o.coordinates);
            }
            return { type: 'Polygon', coordinates: e };
          },
          MultiPolygon: function (t) {
            for (var e = [], n = 0; n < t._geometries.length; ++n) {
              var r = t._geometries[n],
                i = _r.Polygon.call(this, r);
              e.push(i.coordinates);
            }
            return { type: 'MultiPolygon', coordinates: e };
          },
          GeometryCollection: function (t) {
            for (var e = [], n = 0; n < t._geometries.length; ++n) {
              var r = t._geometries[n],
                i = r.getGeometryType();
              e.push(_r[i].call(this, r));
            }
            return { type: 'GeometryCollection', geometries: e };
          },
        };
      return {
        BufferOp: yr,
        GeoJSONReader: (function () {
          function e(n) {
            t(this, e), (this.parser = new dr(n || new se()));
          }
          return (
            r(e, [
              {
                key: 'read',
                value: function (t) {
                  return this.parser.read(t);
                },
              },
            ]),
            e
          );
        })(),
        GeoJSONWriter: (function () {
          function e() {
            t(this, e), (this.parser = new dr(this.geometryFactory));
          }
          return (
            r(e, [
              {
                key: 'write',
                value: function (t) {
                  return this.parser.write(t);
                },
              },
            ]),
            e
          );
        })(),
      };
    })();
  })(lp);
  var cp = p(lp.exports);
  function hp() {
    return new fp();
  }
  function fp() {
    this.reset();
  }
  fp.prototype = {
    constructor: fp,
    reset: function () {
      this.s = this.t = 0;
    },
    add: function (t) {
      gp(pp, t, this.t), gp(this, pp.s, this.s), this.s ? (this.t += pp.t) : (this.s = pp.t);
    },
    valueOf: function () {
      return this.s;
    },
  };
  var pp = new fp();
  function gp(t, e, n) {
    var r = (t.s = e + n),
      i = r - e,
      o = r - i;
    t.t = e - o + (n - i);
  }
  var yp = 1e-6,
    vp = Math.PI,
    dp = vp / 2,
    mp = vp / 4,
    _p = 2 * vp,
    bp = 180 / vp,
    xp = vp / 180,
    Ep = Math.abs,
    wp = Math.atan,
    kp = Math.atan2,
    Sp = Math.cos,
    Ip = Math.sin,
    Pp = Math.sqrt;
  function Np(t) {
    return t > 1 ? 0 : t < -1 ? vp : Math.acos(t);
  }
  function Mp(t) {
    return t > 1 ? dp : t < -1 ? -dp : Math.asin(t);
  }
  function Op() {}
  function Lp(t, e) {
    t && Ap.hasOwnProperty(t.type) && Ap[t.type](t, e);
  }
  var Rp,
    Cp,
    Tp = {
      Feature: function (t, e) {
        Lp(t.geometry, e);
      },
      FeatureCollection: function (t, e) {
        for (var n = t.features, r = -1, i = n.length; ++r < i; ) Lp(n[r].geometry, e);
      },
    },
    Ap = {
      Sphere: function (t, e) {
        e.sphere();
      },
      Point: function (t, e) {
        (t = t.coordinates), e.point(t[0], t[1], t[2]);
      },
      MultiPoint: function (t, e) {
        for (var n = t.coordinates, r = -1, i = n.length; ++r < i; ) (t = n[r]), e.point(t[0], t[1], t[2]);
      },
      LineString: function (t, e) {
        Dp(t.coordinates, e, 0);
      },
      MultiLineString: function (t, e) {
        for (var n = t.coordinates, r = -1, i = n.length; ++r < i; ) Dp(n[r], e, 0);
      },
      Polygon: function (t, e) {
        jp(t.coordinates, e);
      },
      MultiPolygon: function (t, e) {
        for (var n = t.coordinates, r = -1, i = n.length; ++r < i; ) jp(n[r], e);
      },
      GeometryCollection: function (t, e) {
        for (var n = t.geometries, r = -1, i = n.length; ++r < i; ) Lp(n[r], e);
      },
    };
  function Dp(t, e, n) {
    var r,
      i = -1,
      o = t.length - n;
    for (e.lineStart(); ++i < o; ) (r = t[i]), e.point(r[0], r[1], r[2]);
    e.lineEnd();
  }
  function jp(t, e) {
    var n = -1,
      r = t.length;
    for (e.polygonStart(); ++n < r; ) Dp(t[n], e, 1);
    e.polygonEnd();
  }
  function Fp(t) {
    return [kp(t[1], t[0]), Mp(t[2])];
  }
  function Bp(t) {
    var e = t[0],
      n = t[1],
      r = Sp(n);
    return [r * Sp(e), r * Ip(e), Ip(n)];
  }
  function qp(t, e) {
    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
  }
  function Vp(t, e) {
    return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]];
  }
  function Gp(t, e) {
    (t[0] += e[0]), (t[1] += e[1]), (t[2] += e[2]);
  }
  function Yp(t, e) {
    return [t[0] * e, t[1] * e, t[2] * e];
  }
  function zp(t) {
    var e = Pp(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
    (t[0] /= e), (t[1] /= e), (t[2] /= e);
  }
  function Up(t, e) {
    function n(n, r) {
      return (n = t(n, r)), e(n[0], n[1]);
    }
    return (
      t.invert &&
        e.invert &&
        (n.invert = function (n, r) {
          return (n = e.invert(n, r)) && t.invert(n[0], n[1]);
        }),
      n
    );
  }
  function Xp(t, e) {
    return [t > vp ? t - _p : t < -vp ? t + _p : t, e];
  }
  function Wp(t) {
    return function (e, n) {
      return [(e += t) > vp ? e - _p : e < -vp ? e + _p : e, n];
    };
  }
  function Hp(t) {
    var e = Wp(t);
    return (e.invert = Wp(-t)), e;
  }
  function Zp(t, e) {
    var n = Sp(t),
      r = Ip(t),
      i = Sp(e),
      o = Ip(e);
    function a(t, e) {
      var a = Sp(e),
        s = Sp(t) * a,
        u = Ip(t) * a,
        l = Ip(e),
        c = l * n + s * r;
      return [kp(u * i - c * o, s * n - l * r), Mp(c * i + u * o)];
    }
    return (
      (a.invert = function (t, e) {
        var a = Sp(e),
          s = Sp(t) * a,
          u = Ip(t) * a,
          l = Ip(e),
          c = l * i - u * o;
        return [kp(u * i + l * o, s * n + c * r), Mp(c * n - s * r)];
      }),
      a
    );
  }
  function Jp(t, e) {
    ((e = Bp(e))[0] -= t), zp(e);
    var n = Np(-e[1]);
    return ((-e[2] < 0 ? -n : n) + _p - yp) % _p;
  }
  function $p() {
    var t,
      e = [];
    return {
      point: function (e, n) {
        t.push([e, n]);
      },
      lineStart: function () {
        e.push((t = []));
      },
      lineEnd: Op,
      rejoin: function () {
        e.length > 1 && e.push(e.pop().concat(e.shift()));
      },
      result: function () {
        var n = e;
        return (e = []), (t = null), n;
      },
    };
  }
  function Qp(t, e) {
    return Ep(t[0] - e[0]) < yp && Ep(t[1] - e[1]) < yp;
  }
  function Kp(t, e, n, r) {
    (this.x = t), (this.z = e), (this.o = n), (this.e = r), (this.v = !1), (this.n = this.p = null);
  }
  function tg(t, e, n, r, i) {
    var o,
      a,
      s = [],
      u = [];
    if (
      (t.forEach(function (t) {
        if (!((e = t.length - 1) <= 0)) {
          var e,
            n,
            r = t[0],
            a = t[e];
          if (Qp(r, a)) {
            for (i.lineStart(), o = 0; o < e; ++o) i.point((r = t[o])[0], r[1]);
            i.lineEnd();
          } else
            s.push((n = new Kp(r, t, null, !0))),
              u.push((n.o = new Kp(r, null, n, !1))),
              s.push((n = new Kp(a, t, null, !1))),
              u.push((n.o = new Kp(a, null, n, !0)));
        }
      }),
      s.length)
    ) {
      for (u.sort(e), eg(s), eg(u), o = 0, a = u.length; o < a; ++o) u[o].e = n = !n;
      for (var l, c, h = s[0]; ; ) {
        for (var f = h, p = !0; f.v; ) if ((f = f.n) === h) return;
        (l = f.z), i.lineStart();
        do {
          if (((f.v = f.o.v = !0), f.e)) {
            if (p) for (o = 0, a = l.length; o < a; ++o) i.point((c = l[o])[0], c[1]);
            else r(f.x, f.n.x, 1, i);
            f = f.n;
          } else {
            if (p) for (l = f.p.z, o = l.length - 1; o >= 0; --o) i.point((c = l[o])[0], c[1]);
            else r(f.x, f.p.x, -1, i);
            f = f.p;
          }
          (l = (f = f.o).z), (p = !p);
        } while (!f.v);
        i.lineEnd();
      }
    }
  }
  function eg(t) {
    if ((e = t.length)) {
      for (var e, n, r = 0, i = t[0]; ++r < e; ) (i.n = n = t[r]), (n.p = i), (i = n);
      (i.n = n = t[0]), (n.p = i);
    }
  }
  function ng(t, e) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  function rg(t) {
    for (var e, n, r, i = t.length, o = -1, a = 0; ++o < i; ) a += t[o].length;
    for (n = new Array(a); --i >= 0; ) for (e = (r = t[i]).length; --e >= 0; ) n[--a] = r[e];
    return n;
  }
  hp(),
    hp(),
    hp(),
    (Xp.invert = Xp),
    1 === (Rp = ng).length &&
      ((Cp = Rp),
      (Rp = function (t, e) {
        return ng(Cp(t), e);
      }));
  var ig = 1e9,
    og = -ig;
  function ag(t, e, n, r) {
    function i(i, o) {
      return t <= i && i <= n && e <= o && o <= r;
    }
    function o(i, o, s, l) {
      var c = 0,
        h = 0;
      if (null == i || (c = a(i, s)) !== (h = a(o, s)) || (u(i, o) < 0) ^ (s > 0))
        do {
          l.point(0 === c || 3 === c ? t : n, c > 1 ? r : e);
        } while ((c = (c + s + 4) % 4) !== h);
      else l.point(o[0], o[1]);
    }
    function a(r, i) {
      return Ep(r[0] - t) < yp
        ? i > 0
          ? 0
          : 3
        : Ep(r[0] - n) < yp
        ? i > 0
          ? 2
          : 1
        : Ep(r[1] - e) < yp
        ? i > 0
          ? 1
          : 0
        : i > 0
        ? 3
        : 2;
    }
    function s(t, e) {
      return u(t.x, e.x);
    }
    function u(t, e) {
      var n = a(t, 1),
        r = a(e, 1);
      return n !== r ? n - r : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0];
    }
    return function (a) {
      var u,
        l,
        c,
        h,
        f,
        p,
        g,
        y,
        v,
        d,
        m,
        _ = a,
        b = $p(),
        x = {
          point: E,
          lineStart: function () {
            (x.point = w), l && l.push((c = []));
            (d = !0), (v = !1), (g = y = NaN);
          },
          lineEnd: function () {
            u && (w(h, f), p && v && b.rejoin(), u.push(b.result()));
            (x.point = E), v && _.lineEnd();
          },
          polygonStart: function () {
            (_ = b), (u = []), (l = []), (m = !0);
          },
          polygonEnd: function () {
            var e = (function () {
                for (var e = 0, n = 0, i = l.length; n < i; ++n)
                  for (var o, a, s = l[n], u = 1, c = s.length, h = s[0], f = h[0], p = h[1]; u < c; ++u)
                    (o = f),
                      (a = p),
                      (f = (h = s[u])[0]),
                      (p = h[1]),
                      a <= r
                        ? p > r && (f - o) * (r - a) > (p - a) * (t - o) && ++e
                        : p <= r && (f - o) * (r - a) < (p - a) * (t - o) && --e;
                return e;
              })(),
              n = m && e,
              i = (u = rg(u)).length;
            (n || i) &&
              (a.polygonStart(),
              n && (a.lineStart(), o(null, null, 1, a), a.lineEnd()),
              i && tg(u, s, e, o, a),
              a.polygonEnd());
            (_ = a), (u = l = c = null);
          },
        };
      function E(t, e) {
        i(t, e) && _.point(t, e);
      }
      function w(o, a) {
        var s = i(o, a);
        if ((l && c.push([o, a]), d)) (h = o), (f = a), (p = s), (d = !1), s && (_.lineStart(), _.point(o, a));
        else if (s && v) _.point(o, a);
        else {
          var u = [(g = Math.max(og, Math.min(ig, g))), (y = Math.max(og, Math.min(ig, y)))],
            b = [(o = Math.max(og, Math.min(ig, o))), (a = Math.max(og, Math.min(ig, a)))];
          !(function (t, e, n, r, i, o) {
            var a,
              s = t[0],
              u = t[1],
              l = 0,
              c = 1,
              h = e[0] - s,
              f = e[1] - u;
            if (((a = n - s), h || !(a > 0))) {
              if (((a /= h), h < 0)) {
                if (a < l) return;
                a < c && (c = a);
              } else if (h > 0) {
                if (a > c) return;
                a > l && (l = a);
              }
              if (((a = i - s), h || !(a < 0))) {
                if (((a /= h), h < 0)) {
                  if (a > c) return;
                  a > l && (l = a);
                } else if (h > 0) {
                  if (a < l) return;
                  a < c && (c = a);
                }
                if (((a = r - u), f || !(a > 0))) {
                  if (((a /= f), f < 0)) {
                    if (a < l) return;
                    a < c && (c = a);
                  } else if (f > 0) {
                    if (a > c) return;
                    a > l && (l = a);
                  }
                  if (((a = o - u), f || !(a < 0))) {
                    if (((a /= f), f < 0)) {
                      if (a > c) return;
                      a > l && (l = a);
                    } else if (f > 0) {
                      if (a < l) return;
                      a < c && (c = a);
                    }
                    return (
                      l > 0 && ((t[0] = s + l * h), (t[1] = u + l * f)),
                      c < 1 && ((e[0] = s + c * h), (e[1] = u + c * f)),
                      !0
                    );
                  }
                }
              }
            }
          })(u, b, t, e, n, r)
            ? s && (_.lineStart(), _.point(o, a), (m = !1))
            : (v || (_.lineStart(), _.point(u[0], u[1])), _.point(b[0], b[1]), s || _.lineEnd(), (m = !1));
        }
        (g = o), (y = a), (v = s);
      }
      return x;
    };
  }
  var sg = hp();
  function ug(t) {
    return t;
  }
  hp(), hp(), hp();
  var lg = 1 / 0,
    cg = lg,
    hg = -lg,
    fg = hg,
    pg = {
      point: function (t, e) {
        t < lg && (lg = t);
        t > hg && (hg = t);
        e < cg && (cg = e);
        e > fg && (fg = e);
      },
      lineStart: Op,
      lineEnd: Op,
      polygonStart: Op,
      polygonEnd: Op,
      result: function () {
        var t = [
          [lg, cg],
          [hg, fg],
        ];
        return (hg = fg = -(cg = lg = 1 / 0)), t;
      },
    };
  function gg(t, e, n, r) {
    return function (i, o) {
      var a,
        s,
        u,
        l = e(o),
        c = i.invert(r[0], r[1]),
        h = $p(),
        f = e(h),
        p = !1,
        g = {
          point: y,
          lineStart: d,
          lineEnd: m,
          polygonStart: function () {
            (g.point = _), (g.lineStart = b), (g.lineEnd = x), (s = []), (a = []);
          },
          polygonEnd: function () {
            (g.point = y), (g.lineStart = d), (g.lineEnd = m), (s = rg(s));
            var t = (function (t, e) {
              var n = e[0],
                r = e[1],
                i = [Ip(n), -Sp(n), 0],
                o = 0,
                a = 0;
              sg.reset();
              for (var s = 0, u = t.length; s < u; ++s)
                if ((c = (l = t[s]).length))
                  for (
                    var l, c, h = l[c - 1], f = h[0], p = h[1] / 2 + mp, g = Ip(p), y = Sp(p), v = 0;
                    v < c;
                    ++v, f = m, g = b, y = x, h = d
                  ) {
                    var d = l[v],
                      m = d[0],
                      _ = d[1] / 2 + mp,
                      b = Ip(_),
                      x = Sp(_),
                      E = m - f,
                      w = E >= 0 ? 1 : -1,
                      k = w * E,
                      S = k > vp,
                      I = g * b;
                    if (
                      (sg.add(kp(I * w * Ip(k), y * x + I * Sp(k))), (o += S ? E + w * _p : E), S ^ (f >= n) ^ (m >= n))
                    ) {
                      var P = Vp(Bp(h), Bp(d));
                      zp(P);
                      var N = Vp(i, P);
                      zp(N);
                      var M = (S ^ (E >= 0) ? -1 : 1) * Mp(N[2]);
                      (r > M || (r === M && (P[0] || P[1]))) && (a += S ^ (E >= 0) ? 1 : -1);
                    }
                  }
              return (o < -yp || (o < yp && sg < -yp)) ^ (1 & a);
            })(a, c);
            s.length
              ? (p || (o.polygonStart(), (p = !0)), tg(s, vg, t, n, o))
              : t && (p || (o.polygonStart(), (p = !0)), o.lineStart(), n(null, null, 1, o), o.lineEnd()),
              p && (o.polygonEnd(), (p = !1)),
              (s = a = null);
          },
          sphere: function () {
            o.polygonStart(), o.lineStart(), n(null, null, 1, o), o.lineEnd(), o.polygonEnd();
          },
        };
      function y(e, n) {
        var r = i(e, n);
        t((e = r[0]), (n = r[1])) && o.point(e, n);
      }
      function v(t, e) {
        var n = i(t, e);
        l.point(n[0], n[1]);
      }
      function d() {
        (g.point = v), l.lineStart();
      }
      function m() {
        (g.point = y), l.lineEnd();
      }
      function _(t, e) {
        u.push([t, e]);
        var n = i(t, e);
        f.point(n[0], n[1]);
      }
      function b() {
        f.lineStart(), (u = []);
      }
      function x() {
        _(u[0][0], u[0][1]), f.lineEnd();
        var t,
          e,
          n,
          r,
          i = f.clean(),
          l = h.result(),
          c = l.length;
        if ((u.pop(), a.push(u), (u = null), c))
          if (1 & i) {
            if ((e = (n = l[0]).length - 1) > 0) {
              for (p || (o.polygonStart(), (p = !0)), o.lineStart(), t = 0; t < e; ++t) o.point((r = n[t])[0], r[1]);
              o.lineEnd();
            }
          } else c > 1 && 2 & i && l.push(l.pop().concat(l.shift())), s.push(l.filter(yg));
      }
      return g;
    };
  }
  function yg(t) {
    return t.length > 1;
  }
  function vg(t, e) {
    return ((t = t.x)[0] < 0 ? t[1] - dp - yp : dp - t[1]) - ((e = e.x)[0] < 0 ? e[1] - dp - yp : dp - e[1]);
  }
  hp();
  var dg = gg(
    function () {
      return !0;
    },
    function (t) {
      var e,
        n = NaN,
        r = NaN,
        i = NaN;
      return {
        lineStart: function () {
          t.lineStart(), (e = 1);
        },
        point: function (o, a) {
          var s = o > 0 ? vp : -vp,
            u = Ep(o - n);
          Ep(u - vp) < yp
            ? (t.point(n, (r = (r + a) / 2 > 0 ? dp : -dp)),
              t.point(i, r),
              t.lineEnd(),
              t.lineStart(),
              t.point(s, r),
              t.point(o, r),
              (e = 0))
            : i !== s &&
              u >= vp &&
              (Ep(n - i) < yp && (n -= i * yp),
              Ep(o - s) < yp && (o -= s * yp),
              (r = (function (t, e, n, r) {
                var i,
                  o,
                  a = Ip(t - n);
                return Ep(a) > yp
                  ? wp((Ip(e) * (o = Sp(r)) * Ip(n) - Ip(r) * (i = Sp(e)) * Ip(t)) / (i * o * a))
                  : (e + r) / 2;
              })(n, r, o, a)),
              t.point(i, r),
              t.lineEnd(),
              t.lineStart(),
              t.point(s, r),
              (e = 0)),
            t.point((n = o), (r = a)),
            (i = s);
        },
        lineEnd: function () {
          t.lineEnd(), (n = r = NaN);
        },
        clean: function () {
          return 2 - e;
        },
      };
    },
    function (t, e, n, r) {
      var i;
      if (null == t)
        (i = n * dp),
          r.point(-vp, i),
          r.point(0, i),
          r.point(vp, i),
          r.point(vp, 0),
          r.point(vp, -i),
          r.point(0, -i),
          r.point(-vp, -i),
          r.point(-vp, 0),
          r.point(-vp, i);
      else if (Ep(t[0] - e[0]) > yp) {
        var o = t[0] < e[0] ? vp : -vp;
        (i = (n * o) / 2), r.point(-o, i), r.point(0, i), r.point(o, i);
      } else r.point(e[0], e[1]);
    },
    [-vp, -dp],
  );
  function mg(t, e) {
    var n = Sp(t),
      r = n > 0,
      i = Ep(n) > yp;
    function o(t, e) {
      return Sp(t) * Sp(e) > n;
    }
    function a(t, e, r) {
      var i = [1, 0, 0],
        o = Vp(Bp(t), Bp(e)),
        a = qp(o, o),
        s = o[0],
        u = a - s * s;
      if (!u) return !r && t;
      var l = (n * a) / u,
        c = (-n * s) / u,
        h = Vp(i, o),
        f = Yp(i, l);
      Gp(f, Yp(o, c));
      var p = h,
        g = qp(f, p),
        y = qp(p, p),
        v = g * g - y * (qp(f, f) - 1);
      if (!(v < 0)) {
        var d = Pp(v),
          m = Yp(p, (-g - d) / y);
        if ((Gp(m, f), (m = Fp(m)), !r)) return m;
        var _,
          b = t[0],
          x = e[0],
          E = t[1],
          w = e[1];
        x < b && ((_ = b), (b = x), (x = _));
        var k = x - b,
          S = Ep(k - vp) < yp;
        if (
          (!S && w < E && ((_ = E), (E = w), (w = _)),
          S || k < yp
            ? S
              ? (E + w > 0) ^ (m[1] < (Ep(m[0] - b) < yp ? E : w))
              : E <= m[1] && m[1] <= w
            : (k > vp) ^ (b <= m[0] && m[0] <= x))
        ) {
          var I = Yp(p, (-g + d) / y);
          return Gp(I, f), [m, Fp(I)];
        }
      }
    }
    function s(e, n) {
      var i = r ? t : vp - t,
        o = 0;
      return e < -i ? (o |= 1) : e > i && (o |= 2), n < -i ? (o |= 4) : n > i && (o |= 8), o;
    }
    return gg(
      o,
      function (t) {
        var e, n, u, l, c;
        return {
          lineStart: function () {
            (l = u = !1), (c = 1);
          },
          point: function (h, f) {
            var p,
              g = [h, f],
              y = o(h, f),
              v = r ? (y ? 0 : s(h, f)) : y ? s(h + (h < 0 ? vp : -vp), f) : 0;
            if (
              (!e && (l = u = y) && t.lineStart(),
              y !== u && (!(p = a(e, g)) || Qp(e, p) || Qp(g, p)) && ((g[0] += yp), (g[1] += yp), (y = o(g[0], g[1]))),
              y !== u)
            )
              (c = 0),
                y
                  ? (t.lineStart(), (p = a(g, e)), t.point(p[0], p[1]))
                  : ((p = a(e, g)), t.point(p[0], p[1]), t.lineEnd()),
                (e = p);
            else if (i && e && r ^ y) {
              var d;
              v & n ||
                !(d = a(g, e, !0)) ||
                ((c = 0),
                r
                  ? (t.lineStart(), t.point(d[0][0], d[0][1]), t.point(d[1][0], d[1][1]), t.lineEnd())
                  : (t.point(d[1][0], d[1][1]), t.lineEnd(), t.lineStart(), t.point(d[0][0], d[0][1])));
            }
            !y || (e && Qp(e, g)) || t.point(g[0], g[1]), (e = g), (u = y), (n = v);
          },
          lineEnd: function () {
            u && t.lineEnd(), (e = null);
          },
          clean: function () {
            return c | ((l && u) << 1);
          },
        };
      },
      function (n, r, i, o) {
        !(function (t, e, n, r, i, o) {
          if (n) {
            var a = Sp(e),
              s = Ip(e),
              u = r * n;
            null == i
              ? ((i = e + r * _p), (o = e - u / 2))
              : ((i = Jp(a, i)), (o = Jp(a, o)), (r > 0 ? i < o : i > o) && (i += r * _p));
            for (var l, c = i; r > 0 ? c > o : c < o; c -= u)
              (l = Fp([a, -s * Sp(c), -s * Ip(c)])), t.point(l[0], l[1]);
          }
        })(o, t, e, i, n, r);
      },
      r ? [0, -t] : [-vp, t - vp],
    );
  }
  function _g(t) {
    return function (e) {
      var n = new bg();
      for (var r in t) n[r] = t[r];
      return (n.stream = e), n;
    };
  }
  function bg() {}
  function xg(t, e, n) {
    var r = e[1][0] - e[0][0],
      i = e[1][1] - e[0][1],
      o = t.clipExtent && t.clipExtent();
    t.scale(150).translate([0, 0]),
      null != o && t.clipExtent(null),
      (function (t, e) {
        t && Tp.hasOwnProperty(t.type) ? Tp[t.type](t, e) : Lp(t, e);
      })(n, t.stream(pg));
    var a = pg.result(),
      s = Math.min(r / (a[1][0] - a[0][0]), i / (a[1][1] - a[0][1])),
      u = +e[0][0] + (r - s * (a[1][0] + a[0][0])) / 2,
      l = +e[0][1] + (i - s * (a[1][1] + a[0][1])) / 2;
    return null != o && t.clipExtent(o), t.scale(150 * s).translate([u, l]);
  }
  bg.prototype = {
    constructor: bg,
    point: function (t, e) {
      this.stream.point(t, e);
    },
    sphere: function () {
      this.stream.sphere();
    },
    lineStart: function () {
      this.stream.lineStart();
    },
    lineEnd: function () {
      this.stream.lineEnd();
    },
    polygonStart: function () {
      this.stream.polygonStart();
    },
    polygonEnd: function () {
      this.stream.polygonEnd();
    },
  };
  var Eg = 16,
    wg = Sp(30 * xp);
  function kg(t, e) {
    return +e
      ? (function (t, e) {
          function n(r, i, o, a, s, u, l, c, h, f, p, g, y, v) {
            var d = l - r,
              m = c - i,
              _ = d * d + m * m;
            if (_ > 4 * e && y--) {
              var b = a + f,
                x = s + p,
                E = u + g,
                w = Pp(b * b + x * x + E * E),
                k = Mp((E /= w)),
                S = Ep(Ep(E) - 1) < yp || Ep(o - h) < yp ? (o + h) / 2 : kp(x, b),
                I = t(S, k),
                P = I[0],
                N = I[1],
                M = P - r,
                O = N - i,
                L = m * M - d * O;
              ((L * L) / _ > e || Ep((d * M + m * O) / _ - 0.5) > 0.3 || a * f + s * p + u * g < wg) &&
                (n(r, i, o, a, s, u, P, N, S, (b /= w), (x /= w), E, y, v),
                v.point(P, N),
                n(P, N, S, b, x, E, l, c, h, f, p, g, y, v));
            }
          }
          return function (e) {
            var r,
              i,
              o,
              a,
              s,
              u,
              l,
              c,
              h,
              f,
              p,
              g,
              y = {
                point: v,
                lineStart: d,
                lineEnd: _,
                polygonStart: function () {
                  e.polygonStart(), (y.lineStart = b);
                },
                polygonEnd: function () {
                  e.polygonEnd(), (y.lineStart = d);
                },
              };
            function v(n, r) {
              (n = t(n, r)), e.point(n[0], n[1]);
            }
            function d() {
              (c = NaN), (y.point = m), e.lineStart();
            }
            function m(r, i) {
              var o = Bp([r, i]),
                a = t(r, i);
              n(c, h, l, f, p, g, (c = a[0]), (h = a[1]), (l = r), (f = o[0]), (p = o[1]), (g = o[2]), Eg, e),
                e.point(c, h);
            }
            function _() {
              (y.point = v), e.lineEnd();
            }
            function b() {
              d(), (y.point = x), (y.lineEnd = E);
            }
            function x(t, e) {
              m((r = t), e), (i = c), (o = h), (a = f), (s = p), (u = g), (y.point = m);
            }
            function E() {
              n(c, h, l, f, p, g, i, o, r, a, s, u, Eg, e), (y.lineEnd = _), _();
            }
            return y;
          };
        })(t, e)
      : (function (t) {
          return _g({
            point: function (e, n) {
              (e = t(e, n)), this.stream.point(e[0], e[1]);
            },
          });
        })(t);
  }
  var Sg = _g({
    point: function (t, e) {
      this.stream.point(t * xp, e * xp);
    },
  });
  function Ig(t) {
    return (function (t) {
      var e,
        n,
        r,
        i,
        o,
        a,
        s,
        u,
        l,
        c,
        h = 150,
        f = 480,
        p = 250,
        g = 0,
        y = 0,
        v = 0,
        d = 0,
        m = 0,
        _ = null,
        b = dg,
        x = null,
        E = ug,
        w = 0.5,
        k = kg(P, w);
      function S(t) {
        return [(t = o(t[0] * xp, t[1] * xp))[0] * h + n, r - t[1] * h];
      }
      function I(t) {
        return (t = o.invert((t[0] - n) / h, (r - t[1]) / h)) && [t[0] * bp, t[1] * bp];
      }
      function P(t, i) {
        return [(t = e(t, i))[0] * h + n, r - t[1] * h];
      }
      function N() {
        o = Up(
          (i = (function (t, e, n) {
            return (t %= _p) ? (e || n ? Up(Hp(t), Zp(e, n)) : Hp(t)) : e || n ? Zp(e, n) : Xp;
          })(v, d, m)),
          e,
        );
        var t = e(g, y);
        return (n = f - t[0] * h), (r = p + t[1] * h), M();
      }
      function M() {
        return (l = c = null), S;
      }
      return (
        (S.stream = function (t) {
          return l && c === t ? l : (l = Sg(b(i, k(E((c = t))))));
        }),
        (S.clipAngle = function (t) {
          return arguments.length ? ((b = +t ? mg((_ = t * xp), 6 * xp) : ((_ = null), dg)), M()) : _ * bp;
        }),
        (S.clipExtent = function (t) {
          return arguments.length
            ? ((E =
                null == t
                  ? ((x = a = s = u = null), ug)
                  : ag((x = +t[0][0]), (a = +t[0][1]), (s = +t[1][0]), (u = +t[1][1]))),
              M())
            : null == x
            ? null
            : [
                [x, a],
                [s, u],
              ];
        }),
        (S.scale = function (t) {
          return arguments.length ? ((h = +t), N()) : h;
        }),
        (S.translate = function (t) {
          return arguments.length ? ((f = +t[0]), (p = +t[1]), N()) : [f, p];
        }),
        (S.center = function (t) {
          return arguments.length ? ((g = (t[0] % 360) * xp), (y = (t[1] % 360) * xp), N()) : [g * bp, y * bp];
        }),
        (S.rotate = function (t) {
          return arguments.length
            ? ((v = (t[0] % 360) * xp), (d = (t[1] % 360) * xp), (m = t.length > 2 ? (t[2] % 360) * xp : 0), N())
            : [v * bp, d * bp, m * bp];
        }),
        (S.precision = function (t) {
          return arguments.length ? ((k = kg(P, (w = t * t))), M()) : Pp(w);
        }),
        (S.fitExtent = function (t, e) {
          return xg(S, t, e);
        }),
        (S.fitSize = function (t, e) {
          return (function (t, e, n) {
            return xg(t, [[0, 0], e], n);
          })(S, t, e);
        }),
        function () {
          return (e = t.apply(this, arguments)), (S.invert = e.invert && I), N();
        }
      );
    })(function () {
      return t;
    })();
  }
  function Pg(t) {
    return function (e, n) {
      var r = Sp(e),
        i = Sp(n),
        o = t(r * i);
      return [o * i * Ip(e), o * Ip(n)];
    };
  }
  function Ng(t) {
    return function (e, n) {
      var r = Pp(e * e + n * n),
        i = t(r),
        o = Ip(i),
        a = Sp(i);
      return [kp(e * o, r * a), Mp(r && (n * o) / r)];
    };
  }
  Pg(function (t) {
    return Pp(2 / (1 + t));
  }).invert = Ng(function (t) {
    return 2 * Mp(t / 2);
  });
  var Mg = Pg(function (t) {
    return (t = Np(t)) && t / Ip(t);
  });
  function Og(t, e) {
    return [t, e];
  }
  (Mg.invert = Ng(function (t) {
    return t;
  })),
    (Og.invert = Og);
  var Lg = Object.defineProperty,
    Rg = function (t, e) {
      return Lg(t, 'name', { value: e, configurable: !0 });
    },
    Cg = cp.BufferOp,
    Tg = cp.GeoJSONReader,
    Ag = cp.GeoJSONWriter;
  function Dg(t, n, r) {
    var i = (r = r || {}).units || 'kilometers',
      o = r.steps || 8;
    if (!t) throw new Error('geojson is required');
    if ('object' !== e(r)) throw new Error('options must be an object');
    if ('number' != typeof o) throw new Error('steps must be an number');
    if (void 0 === n) throw new Error('radius is required');
    if (o <= 0) throw new Error('steps must be greater than 0');
    var a = [];
    switch (t.type) {
      case 'GeometryCollection':
        return (
          jl(t, function (t) {
            var e = jg(t, n, i, o);
            e && a.push(e);
          }),
          ju(a)
        );
      case 'FeatureCollection':
        return (
          Tl(t, function (t) {
            var e = jg(t, n, i, o);
            e &&
              Tl(e, function (t) {
                t && a.push(t);
              });
          }),
          ju(a)
        );
    }
    return jg(t, n, i, o);
  }
  function jg(t, e, n, r) {
    var i = t.properties || {},
      o = 'Feature' === t.type ? t.geometry : t;
    if ('GeometryCollection' === o.type) {
      var a = [];
      return (
        jl(t, function (t) {
          var i = jg(t, e, n, r);
          i && a.push(i);
        }),
        ju(a)
      );
    }
    var s = Vg(o),
      u = { type: o.type, coordinates: Bg(o.coordinates, s) },
      l = new Tg().read(u),
      c = Yu(zu(e, n), 'meters'),
      h = Cg.bufferOp(l, c, r);
    if (!Fg((h = new Ag().write(h)).coordinates)) return Mu({ type: h.type, coordinates: qg(h.coordinates, s) }, i);
  }
  function Fg(t) {
    return Array.isArray(t[0]) ? Fg(t[0]) : isNaN(t[0]);
  }
  function Bg(t, n) {
    return 'object' !== e(t[0])
      ? n(t)
      : t.map(function (t) {
          return Bg(t, n);
        });
  }
  function qg(t, n) {
    return 'object' !== e(t[0])
      ? n.invert(t)
      : t.map(function (t) {
          return qg(t, n);
        });
  }
  function Vg(t) {
    var e = up(t).geometry.coordinates,
      n = [-e[0], -e[1]];
    return Ig(Mg).scale(79.4188).clipAngle(179.999).rotate(n).scale(Iu);
  }
  Rg(Dg, 'buffer'),
    Rg(jg, 'bufferFeature'),
    Rg(Fg, 'coordsIsNaN'),
    Rg(Bg, 'projectCoords'),
    Rg(qg, 'unprojectCoords'),
    Rg(Vg, 'defineProjection');
  var Gg = Object.defineProperty;
  function Yg(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = 0,
      r = 0,
      i = 0;
    return (
      jl(t, function (t, o, a) {
        var s = e.weight ? (null == a ? void 0 : a[e.weight]) : void 0;
        if (!$u((s = null == s ? 1 : s))) throw new Error('weight value must be a number for feature index ' + o);
        (s = Number(s)) > 0 &&
          Ol(t, function (t) {
            (n += t[0] * s), (r += t[1] * s), (i += s);
          });
      }),
      Lu([n / i, r / i], e.properties, e)
    );
  }
  !(function (t, e) {
    Gg(t, 'name', { value: e, configurable: !0 });
  })(Yg, 'centerMean');
  var zg = Object.defineProperty;
  function Ug(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = 0,
      r = 0,
      i = 0;
    return (
      Ol(
        t,
        function (t) {
          (n += t[0]), (r += t[1]), i++;
        },
        !0,
      ),
      Lu([n / i, r / i], e.properties)
    );
  }
  !(function (t, e) {
    zg(t, 'name', { value: e, configurable: !0 });
  })(Ug, 'centroid');
  var Xg = Object.defineProperty,
    Wg = function (t, e) {
      return Xg(t, 'name', { value: e, configurable: !0 });
    };
  function Hg(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.counter || 10;
    if (!$u(n)) throw new Error('counter must be a number');
    var r = e.weight,
      i = Yg(t, { weight: e.weight }),
      o = ju([]);
    Tl(t, function (t) {
      var e;
      o.features.push(Ug(t, { properties: { weight: null == (e = t.properties) ? void 0 : e[r] } }));
    });
    var a = { tolerance: e.tolerance, medianCandidates: [] };
    return Zg(i.geometry.coordinates, [0, 0], o, a, n);
  }
  function Zg(t, e, n, r, i) {
    var o = r.tolerance || 0.001,
      a = 0,
      s = 0,
      u = 0,
      l = 0;
    if (
      (Tl(n, function (e) {
        var n,
          r = null == (n = e.properties) ? void 0 : n.weight,
          i = null == r ? 1 : r;
        if (!$u((i = Number(i)))) throw new Error('weight value must be a number');
        if (i > 0) {
          l += 1;
          var o = i * _l(e, t);
          0 === o && (o = 1);
          var c = i / o;
          (a += e.geometry.coordinates[0] * c), (s += e.geometry.coordinates[1] * c), (u += c);
        }
      }),
      l < 1)
    )
      throw new Error('no features to measure');
    var c = a / u,
      h = s / u;
    return 1 === l || 0 === i || (Math.abs(c - e[0]) < o && Math.abs(h - e[1]) < o)
      ? Lu([c, h], { medianCandidates: r.medianCandidates })
      : (r.medianCandidates.push([c, h]), Zg([c, h], t, n, r, i - 1));
  }
  Wg(Hg, 'centerMedian'), Wg(Zg, 'findMedian');
  var Jg = { exports: {} },
    $g = g(sf),
    Qg = (function () {
      function t() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
          r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Kg;
        if ((n(this, t), (this.data = e), (this.length = this.data.length), (this.compare = r), this.length > 0))
          for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
      }
      return (
        i(t, [
          {
            key: 'push',
            value: function (t) {
              this.data.push(t), this.length++, this._up(this.length - 1);
            },
          },
          {
            key: 'pop',
            value: function () {
              if (0 !== this.length) {
                var t = this.data[0],
                  e = this.data.pop();
                return this.length--, this.length > 0 && ((this.data[0] = e), this._down(0)), t;
              }
            },
          },
          {
            key: 'peek',
            value: function () {
              return this.data[0];
            },
          },
          {
            key: '_up',
            value: function (t) {
              for (var e = this.data, n = this.compare, r = e[t]; t > 0; ) {
                var i = (t - 1) >> 1,
                  o = e[i];
                if (n(r, o) >= 0) break;
                (e[t] = o), (t = i);
              }
              e[t] = r;
            },
          },
          {
            key: '_down',
            value: function (t) {
              for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r; ) {
                var o = 1 + (t << 1),
                  a = e[o],
                  s = o + 1;
                if ((s < this.length && n(e[s], a) < 0 && ((o = s), (a = e[s])), n(a, i) >= 0)) break;
                (e[t] = a), (t = o);
              }
              e[t] = i;
            },
          },
        ]),
        t
      );
    })();
  function Kg(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  var ty = g(Object.freeze({ __proto__: null, default: Qg })),
    ey = { exports: {} },
    ny = function (t, e, n, r) {
      var i = t[0],
        o = t[1],
        a = !1;
      void 0 === n && (n = 0), void 0 === r && (r = e.length);
      for (var s = (r - n) / 2, u = 0, l = s - 1; u < s; l = u++) {
        var c = e[n + 2 * u + 0],
          h = e[n + 2 * u + 1],
          f = e[n + 2 * l + 0],
          p = e[n + 2 * l + 1];
        h > o != p > o && i < ((f - c) * (o - h)) / (p - h) + c && (a = !a);
      }
      return a;
    },
    ry = function (t, e, n, r) {
      var i = t[0],
        o = t[1],
        a = !1;
      void 0 === n && (n = 0), void 0 === r && (r = e.length);
      for (var s = r - n, u = 0, l = s - 1; u < s; l = u++) {
        var c = e[u + n][0],
          h = e[u + n][1],
          f = e[l + n][0],
          p = e[l + n][1];
        h > o != p > o && i < ((f - c) * (o - h)) / (p - h) + c && (a = !a);
      }
      return a;
    };
  (ey.exports = function (t, e, n, r) {
    return e.length > 0 && Array.isArray(e[0]) ? ry(t, e, n, r) : ny(t, e, n, r);
  }),
    (ey.exports.nested = ry),
    (ey.exports.flat = ny);
  var iy = ey.exports,
    oy = { exports: {} };
  !(function (t, e) {
    !(function (t) {
      var e = 134217729,
        n = 33306690738754706e-32;
      function r(t, e, n, r, i) {
        var o,
          a,
          s,
          u,
          l = e[0],
          c = r[0],
          h = 0,
          f = 0;
        c > l == c > -l ? ((o = l), (l = e[++h])) : ((o = c), (c = r[++f]));
        var p = 0;
        if (h < t && f < n)
          for (
            c > l == c > -l ? ((s = o - ((a = l + o) - l)), (l = e[++h])) : ((s = o - ((a = c + o) - c)), (c = r[++f])),
              o = a,
              0 !== s && (i[p++] = s);
            h < t && f < n;

          )
            c > l == c > -l
              ? ((s = o - ((a = o + l) - (u = a - o)) + (l - u)), (l = e[++h]))
              : ((s = o - ((a = o + c) - (u = a - o)) + (c - u)), (c = r[++f])),
              (o = a),
              0 !== s && (i[p++] = s);
        for (; h < t; ) (s = o - ((a = o + l) - (u = a - o)) + (l - u)), (l = e[++h]), (o = a), 0 !== s && (i[p++] = s);
        for (; f < n; ) (s = o - ((a = o + c) - (u = a - o)) + (c - u)), (c = r[++f]), (o = a), 0 !== s && (i[p++] = s);
        return (0 === o && 0 !== p) || (i[p++] = o), p;
      }
      function i(t) {
        return new Float64Array(t);
      }
      var o = 33306690738754716e-32,
        a = 22204460492503146e-32,
        s = 11093356479670487e-47,
        u = i(4),
        l = i(8),
        c = i(12),
        h = i(16),
        f = i(4);
      (t.orient2d = function (t, i, p, g, y, v) {
        var d = (i - v) * (p - y),
          m = (t - y) * (g - v),
          _ = d - m;
        if (0 === d || 0 === m || d > 0 != m > 0) return _;
        var b = Math.abs(d + m);
        return Math.abs(_) >= o * b
          ? _
          : -(function (t, i, o, p, g, y, v) {
              var d,
                m,
                _,
                b,
                x,
                E,
                w,
                k,
                S,
                I,
                P,
                N,
                M,
                O,
                L,
                R,
                C,
                T,
                A = t - g,
                D = o - g,
                j = i - y,
                F = p - y;
              (x =
                (L =
                  (k = A - (w = (E = e * A) - (E - A))) * (I = F - (S = (E = e * F) - (E - F))) -
                  ((O = A * F) - w * S - k * S - w * I)) -
                (P =
                  L -
                  (C =
                    (k = j - (w = (E = e * j) - (E - j))) * (I = D - (S = (E = e * D) - (E - D))) -
                    ((R = j * D) - w * S - k * S - w * I)))),
                (u[0] = L - (P + x) + (x - C)),
                (x = (M = O - ((N = O + P) - (x = N - O)) + (P - x)) - (P = M - R)),
                (u[1] = M - (P + x) + (x - R)),
                (x = (T = N + P) - N),
                (u[2] = N - (T - x) + (P - x)),
                (u[3] = T);
              var B = (function (t, e) {
                  for (var n = e[0], r = 1; r < t; r++) n += e[r];
                  return n;
                })(4, u),
                q = a * v;
              if (B >= q || -B >= q) return B;
              if (
                ((d = t - (A + (x = t - A)) + (x - g)),
                (_ = o - (D + (x = o - D)) + (x - g)),
                (m = i - (j + (x = i - j)) + (x - y)),
                (b = p - (F + (x = p - F)) + (x - y)),
                0 === d && 0 === m && 0 === _ && 0 === b)
              )
                return B;
              if (((q = s * v + n * Math.abs(B)), (B += A * b + F * d - (j * _ + D * m)) >= q || -B >= q)) return B;
              (x =
                (L =
                  (k = d - (w = (E = e * d) - (E - d))) * (I = F - (S = (E = e * F) - (E - F))) -
                  ((O = d * F) - w * S - k * S - w * I)) -
                (P =
                  L -
                  (C =
                    (k = m - (w = (E = e * m) - (E - m))) * (I = D - (S = (E = e * D) - (E - D))) -
                    ((R = m * D) - w * S - k * S - w * I)))),
                (f[0] = L - (P + x) + (x - C)),
                (x = (M = O - ((N = O + P) - (x = N - O)) + (P - x)) - (P = M - R)),
                (f[1] = M - (P + x) + (x - R)),
                (x = (T = N + P) - N),
                (f[2] = N - (T - x) + (P - x)),
                (f[3] = T);
              var V = r(4, u, 4, f, l);
              (x =
                (L =
                  (k = A - (w = (E = e * A) - (E - A))) * (I = b - (S = (E = e * b) - (E - b))) -
                  ((O = A * b) - w * S - k * S - w * I)) -
                (P =
                  L -
                  (C =
                    (k = j - (w = (E = e * j) - (E - j))) * (I = _ - (S = (E = e * _) - (E - _))) -
                    ((R = j * _) - w * S - k * S - w * I)))),
                (f[0] = L - (P + x) + (x - C)),
                (x = (M = O - ((N = O + P) - (x = N - O)) + (P - x)) - (P = M - R)),
                (f[1] = M - (P + x) + (x - R)),
                (x = (T = N + P) - N),
                (f[2] = N - (T - x) + (P - x)),
                (f[3] = T);
              var G = r(V, l, 4, f, c);
              (x =
                (L =
                  (k = d - (w = (E = e * d) - (E - d))) * (I = b - (S = (E = e * b) - (E - b))) -
                  ((O = d * b) - w * S - k * S - w * I)) -
                (P =
                  L -
                  (C =
                    (k = m - (w = (E = e * m) - (E - m))) * (I = _ - (S = (E = e * _) - (E - _))) -
                    ((R = m * _) - w * S - k * S - w * I)))),
                (f[0] = L - (P + x) + (x - C)),
                (x = (M = O - ((N = O + P) - (x = N - O)) + (P - x)) - (P = M - R)),
                (f[1] = M - (P + x) + (x - R)),
                (x = (T = N + P) - N),
                (f[2] = N - (T - x) + (P - x)),
                (f[3] = T);
              var Y = r(G, c, 4, f, h);
              return h[Y - 1];
            })(t, i, p, g, y, v, b);
      }),
        (t.orient2dfast = function (t, e, n, r, i, o) {
          return (e - o) * (n - i) - (t - i) * (r - o);
        }),
        Object.defineProperty(t, '__esModule', { value: !0 });
    })(e);
  })(0, oy.exports);
  var ay = $g,
    sy = ty,
    uy = iy,
    ly = oy.exports.orient2d;
  function cy(t, e, n) {
    (e = Math.max(0, void 0 === e ? 2 : e)), (n = n || 0);
    var r = (function (t) {
        for (var e = t[0], n = t[0], r = t[0], i = t[0], o = 0; o < t.length; o++) {
          var a = t[o];
          a[0] < e[0] && (e = a), a[0] > r[0] && (r = a), a[1] < n[1] && (n = a), a[1] > i[1] && (i = a);
        }
        var s = [e, n, r, i],
          u = s.slice();
        for (o = 0; o < t.length; o++) uy(t[o], s) || u.push(t[o]);
        return (function (t) {
          t.sort(Ey);
          for (var e = [], n = 0; n < t.length; n++) {
            for (; e.length >= 2 && vy(e[e.length - 2], e[e.length - 1], t[n]) <= 0; ) e.pop();
            e.push(t[n]);
          }
          for (var r = [], i = t.length - 1; i >= 0; i--) {
            for (; r.length >= 2 && vy(r[r.length - 2], r[r.length - 1], t[i]) <= 0; ) r.pop();
            r.push(t[i]);
          }
          return r.pop(), e.pop(), e.concat(r);
        })(u);
      })(t),
      i = new ay(16);
    (i.toBBox = function (t) {
      return { minX: t[0], minY: t[1], maxX: t[0], maxY: t[1] };
    }),
      (i.compareMinX = function (t, e) {
        return t[0] - e[0];
      }),
      (i.compareMinY = function (t, e) {
        return t[1] - e[1];
      }),
      i.load(t);
    for (var o, a = [], s = 0; s < r.length; s++) {
      var u = r[s];
      i.remove(u), (o = my(u, o)), a.push(o);
    }
    var l = new ay(16);
    for (s = 0; s < a.length; s++) l.insert(dy(a[s]));
    for (var c = e * e, h = n * n; a.length; ) {
      var f = a.shift(),
        p = f.p,
        g = f.next.p,
        y = _y(p, g);
      if (!(y < h)) {
        var v = y / c;
        (u = hy(i, f.prev.p, p, g, f.next.next.p, v, l)) &&
          Math.min(_y(u, p), _y(u, g)) <= v &&
          (a.push(f), a.push(my(u, f)), i.remove(u), l.remove(f), l.insert(dy(f)), l.insert(dy(f.next)));
      }
    }
    f = o;
    var d = [];
    do {
      d.push(f.p), (f = f.next);
    } while (f !== o);
    return d.push(f.p), d;
  }
  function hy(t, e, n, r, i, o, a) {
    for (var s = new sy([], fy), u = t.data; u; ) {
      for (var l = 0; l < u.children.length; l++) {
        var c = u.children[l],
          h = u.leaf ? by(c, n, r) : py(n, r, c);
        h > o || s.push({ node: c, dist: h });
      }
      for (; s.length && !s.peek().node.children; ) {
        var f = s.pop(),
          p = f.node,
          g = by(p, e, n),
          y = by(p, r, i);
        if (f.dist < g && f.dist < y && yy(n, p, a) && yy(r, p, a)) return p;
      }
      (u = s.pop()) && (u = u.node);
    }
    return null;
  }
  function fy(t, e) {
    return t.dist - e.dist;
  }
  function py(t, e, n) {
    if (gy(t, n) || gy(e, n)) return 0;
    var r = xy(t[0], t[1], e[0], e[1], n.minX, n.minY, n.maxX, n.minY);
    if (0 === r) return 0;
    var i = xy(t[0], t[1], e[0], e[1], n.minX, n.minY, n.minX, n.maxY);
    if (0 === i) return 0;
    var o = xy(t[0], t[1], e[0], e[1], n.maxX, n.minY, n.maxX, n.maxY);
    if (0 === o) return 0;
    var a = xy(t[0], t[1], e[0], e[1], n.minX, n.maxY, n.maxX, n.maxY);
    return 0 === a ? 0 : Math.min(r, i, o, a);
  }
  function gy(t, e) {
    return t[0] >= e.minX && t[0] <= e.maxX && t[1] >= e.minY && t[1] <= e.maxY;
  }
  function yy(t, e, n) {
    for (
      var r,
        i,
        o,
        a,
        s = Math.min(t[0], e[0]),
        u = Math.min(t[1], e[1]),
        l = Math.max(t[0], e[0]),
        c = Math.max(t[1], e[1]),
        h = n.search({ minX: s, minY: u, maxX: l, maxY: c }),
        f = 0;
      f < h.length;
      f++
    )
      if (
        ((r = h[f].p),
        (i = h[f].next.p),
        (o = t),
        r !== (a = e) && i !== o && vy(r, i, o) > 0 != vy(r, i, a) > 0 && vy(o, a, r) > 0 != vy(o, a, i) > 0)
      )
        return !1;
    return !0;
  }
  function vy(t, e, n) {
    return ly(t[0], t[1], e[0], e[1], n[0], n[1]);
  }
  function dy(t) {
    var e = t.p,
      n = t.next.p;
    return (
      (t.minX = Math.min(e[0], n[0])),
      (t.minY = Math.min(e[1], n[1])),
      (t.maxX = Math.max(e[0], n[0])),
      (t.maxY = Math.max(e[1], n[1])),
      t
    );
  }
  function my(t, e) {
    var n = { p: t, prev: null, next: null, minX: 0, minY: 0, maxX: 0, maxY: 0 };
    return e ? ((n.next = e.next), (n.prev = e), (e.next.prev = n), (e.next = n)) : ((n.prev = n), (n.next = n)), n;
  }
  function _y(t, e) {
    var n = t[0] - e[0],
      r = t[1] - e[1];
    return n * n + r * r;
  }
  function by(t, e, n) {
    var r = e[0],
      i = e[1],
      o = n[0] - r,
      a = n[1] - i;
    if (0 !== o || 0 !== a) {
      var s = ((t[0] - r) * o + (t[1] - i) * a) / (o * o + a * a);
      s > 1 ? ((r = n[0]), (i = n[1])) : s > 0 && ((r += o * s), (i += a * s));
    }
    return (o = t[0] - r) * o + (a = t[1] - i) * a;
  }
  function xy(t, e, n, r, i, o, a, s) {
    var u,
      l,
      c,
      h,
      f = n - t,
      p = r - e,
      g = a - i,
      y = s - o,
      v = t - i,
      d = e - o,
      m = f * f + p * p,
      _ = f * g + p * y,
      b = g * g + y * y,
      x = f * v + p * d,
      E = g * v + y * d,
      w = m * b - _ * _,
      k = w,
      S = w;
    0 === w
      ? ((l = 0), (k = 1), (h = E), (S = b))
      : ((h = m * E - _ * x),
        (l = _ * E - b * x) < 0 ? ((l = 0), (h = E), (S = b)) : l > k && ((l = k), (h = E + _), (S = b))),
      h < 0
        ? ((h = 0), -x < 0 ? (l = 0) : -x > m ? (l = k) : ((l = -x), (k = m)))
        : h > S && ((h = S), -x + _ < 0 ? (l = 0) : -x + _ > m ? (l = k) : ((l = -x + _), (k = m)));
    var I = (1 - (c = 0 === h ? 0 : h / S)) * i + c * a - ((1 - (u = 0 === l ? 0 : l / k)) * t + u * n),
      P = (1 - c) * o + c * s - ((1 - u) * e + u * r);
    return I * I + P * P;
  }
  function Ey(t, e) {
    return t[0] === e[0] ? t[1] - e[1] : t[0] - e[0];
  }
  sy.default && (sy = sy.default), (Jg.exports = cy), (Jg.exports.default = cy);
  var wy = p(Jg.exports),
    ky = Object.defineProperty;
  function Sy(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    e.concavity = e.concavity || 1 / 0;
    var n = [];
    if (
      (Ol(t, function (t) {
        n.push([t[0], t[1]]);
      }),
      !n.length)
    )
      return null;
    var r = wy(n, e.concavity);
    return r.length > 3 ? Cu([r]) : null;
  }
  !(function (t, e) {
    ky(t, 'name', { value: e, configurable: !0 });
  })(Sy, 'convex');
  var Iy = Object.defineProperty;
  function Py(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    switch (hl(t)) {
      case 'Point':
        return Lu(il(t), e.properties);
      case 'Polygon':
        var n = [];
        Ol(t, function (t) {
          n.push(t);
        });
        var r,
          i,
          o,
          a,
          s,
          u,
          l,
          c,
          h = Ug(t, { properties: e.properties }),
          f = h.geometry.coordinates,
          p = 0,
          g = 0,
          y = 0,
          v = n.map(function (t) {
            return [t[0] - f[0], t[1] - f[1]];
          });
        for (r = 0; r < n.length - 1; r++)
          (a = (i = v[r])[0]),
            (u = i[1]),
            (s = (o = v[r + 1])[0]),
            (y += c = a * (l = o[1]) - s * u),
            (p += (a + s) * c),
            (g += (u + l) * c);
        if (0 === y) return h;
        var d = 1 / (6 * (0.5 * y));
        return Lu([f[0] + d * p, f[1] + d * g], e.properties);
      default:
        var m = Sy(t);
        return m ? Py(m, { properties: e.properties }) : Ug(t, { properties: e.properties });
    }
  }
  !(function (t, e) {
    Iy(t, 'name', { value: e, configurable: !0 });
  })(Py, 'centerOfMass');
  var Ny = Object.defineProperty;
  function My(t, e) {
    for (
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
        r = n.steps || 64,
        i = n.properties ? n.properties : !Array.isArray(t) && 'Feature' === t.type && t.properties ? t.properties : {},
        o = [],
        a = 0;
      a < r;
      a++
    )
      o.push(dl(t, e, (-360 * a) / r, n).geometry.coordinates);
    return o.push(o[0]), Cu([o], i);
  }
  !(function (t, e) {
    Ny(t, 'name', { value: e, configurable: !0 });
  })(My, 'circle');
  var Oy = Object.defineProperty,
    Ly = function (t, e) {
      return Oy(t, 'name', { value: e, configurable: !0 });
    };
  function Ry(t) {
    if (!t) throw new Error('geojson is required');
    switch (t.type) {
      case 'Feature':
        return Cy(t);
      case 'FeatureCollection':
        return Ay(t);
      case 'Point':
      case 'LineString':
      case 'Polygon':
      case 'MultiPoint':
      case 'MultiLineString':
      case 'MultiPolygon':
      case 'GeometryCollection':
        return Dy(t);
      default:
        throw new Error('unknown GeoJSON type');
    }
  }
  function Cy(t) {
    var e = { type: 'Feature' };
    return (
      Object.keys(t).forEach(function (n) {
        switch (n) {
          case 'type':
          case 'properties':
          case 'geometry':
            return;
          default:
            e[n] = t[n];
        }
      }),
      (e.properties = Ty(t.properties)),
      null == t.geometry ? (e.geometry = null) : (e.geometry = Dy(t.geometry)),
      e
    );
  }
  function Ty(t) {
    var n = {};
    return t
      ? (Object.keys(t).forEach(function (r) {
          var i = t[r];
          'object' === e(i)
            ? null === i
              ? (n[r] = null)
              : Array.isArray(i)
              ? (n[r] = i.map(function (t) {
                  return t;
                }))
              : (n[r] = Ty(i))
            : (n[r] = i);
        }),
        n)
      : n;
  }
  function Ay(t) {
    var e = { type: 'FeatureCollection' };
    return (
      Object.keys(t).forEach(function (n) {
        switch (n) {
          case 'type':
          case 'features':
            return;
          default:
            e[n] = t[n];
        }
      }),
      (e.features = t.features.map(function (t) {
        return Cy(t);
      })),
      e
    );
  }
  function Dy(t) {
    var e = { type: t.type };
    return (
      t.bbox && (e.bbox = t.bbox),
      'GeometryCollection' === t.type
        ? ((e.geometries = t.geometries.map(function (t) {
            return Dy(t);
          })),
          e)
        : ((e.coordinates = jy(t.coordinates)), e)
    );
  }
  function jy(t) {
    var n = t;
    return 'object' !== e(n[0])
      ? n.slice()
      : n.map(function (t) {
          return jy(t);
        });
  }
  Ly(Ry, 'clone'),
    Ly(Cy, 'cloneFeature'),
    Ly(Ty, 'cloneProperties'),
    Ly(Ay, 'cloneFeatureCollection'),
    Ly(Dy, 'cloneGeometry'),
    Ly(jy, 'deepSlice');
  var Fy = Object.defineProperty,
    By = function (t, e) {
      return Fy(t, 'name', { value: e, configurable: !0 });
    };
  function qy(t, e) {
    if (!t) throw new Error('geojson is required');
    if ('FeatureCollection' !== t.type) throw new Error('geojson must be a FeatureCollection');
    if (null == e) throw new Error('filter is required');
    var n = [];
    return (
      Tl(t, function (t) {
        zy(t.properties, e) && n.push(t);
      }),
      ju(n)
    );
  }
  function Vy(t, e, n) {
    if (!t) throw new Error('geojson is required');
    if ('FeatureCollection' !== t.type) throw new Error('geojson must be a FeatureCollection');
    if (null == e) throw new Error('property is required');
    for (var r = Yy(t, e), i = Object.keys(r), o = 0; o < i.length; o++) {
      for (var a = i[o], s = r[a], u = [], l = 0; l < s.length; l++) u.push(t.features[s[l]]);
      n(ju(u), a, o);
    }
  }
  function Gy(t, e, n, r) {
    var i = r;
    return (
      Vy(t, e, function (t, e, o) {
        i = 0 === o && void 0 === r ? t : n(i, t, e, o);
      }),
      i
    );
  }
  function Yy(t, e) {
    var n = {};
    return (
      Tl(t, function (t, r) {
        var i = t.properties || {};
        if (Object.prototype.hasOwnProperty.call(i, String(e))) {
          var o = i[e];
          Object.prototype.hasOwnProperty.call(n, o) ? n[o].push(r) : (n[o] = [r]);
        }
      }),
      n
    );
  }
  function zy(t, n) {
    if (void 0 === t) return !1;
    var r = e(n);
    if ('number' === r || 'string' === r) return Object.prototype.hasOwnProperty.call(t, n);
    if (Array.isArray(n)) {
      for (var i = 0; i < n.length; i++) if (!zy(t, n[i])) return !1;
      return !0;
    }
    return Uy(t, n);
  }
  function Uy(t, e) {
    for (var n = Object.keys(e), r = 0; r < n.length; r++) {
      var i = n[r];
      if (t[i] !== e[i]) return !1;
    }
    return !0;
  }
  function Xy(t, e) {
    if (!e) return {};
    if (!e.length) return {};
    for (var n = {}, r = 0; r < e.length; r++) {
      var i = e[r];
      Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
    }
    return n;
  }
  By(qy, 'getCluster'),
    By(Vy, 'clusterEach'),
    By(Gy, 'clusterReduce'),
    By(Yy, 'createBins'),
    By(zy, 'applyFilter'),
    By(Uy, 'propertiesContainsFilter'),
    By(Xy, 'filterProperties');
  var Wy = Object.freeze({
      __proto__: null,
      applyFilter: zy,
      clusterEach: Vy,
      clusterReduce: Gy,
      createBins: Yy,
      filterProperties: Xy,
      getCluster: qy,
      propertiesContainsFilter: Uy,
    }),
    Hy = Object.defineProperty,
    Zy = function (t, e) {
      return Hy(t, 'name', { value: e, configurable: !0 });
    },
    Jy = Wh;
  function $y(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    !0 !== n.mutate && (t = Ry(t));
    var r = n.minPoints || 3,
      i = Uu(e, n.units),
      o = new Jy(t.features.length),
      u = t.features.map(function (t) {
        return !1;
      }),
      l = t.features.map(function (t) {
        return !1;
      }),
      c = t.features.map(function (t) {
        return !1;
      }),
      h = t.features.map(function (t) {
        return -1;
      });
    o.load(
      t.features.map(function (t, e) {
        var n = a(t.geometry.coordinates, 2),
          r = n[0],
          i = n[1];
        return { minX: r, minY: i, maxX: r, maxY: i, index: e };
      }),
    );
    var f = Zy(function (n) {
        var r = t.features[n],
          s = a(r.geometry.coordinates, 2),
          u = s[0],
          l = s[1],
          c = Math.max(l - i, -90),
          h = Math.min(l + i, 90),
          f = c < 0 && h > 0 ? i : Math.abs(c) < Math.abs(h) ? i / Math.cos(Hu(h)) : i / Math.cos(Hu(c)),
          p = Math.max(u - f, -360),
          g = Math.min(u + f, 360),
          y = { minX: p, minY: c, maxX: g, maxY: h };
        return o.search(y).filter(function (n) {
          var i = n.index,
            o = t.features[i];
          return _l(r, o, { units: 'kilometers' }) <= e;
        });
      }, 'regionQuery'),
      p = Zy(function (t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n].index;
          if (!u[i]) {
            u[i] = !0;
            var o = f(i);
            o.length >= r && e.push.apply(e, s(o));
          }
          l[i] || ((l[i] = !0), (h[i] = t));
        }
      }, 'expandCluster'),
      g = 0;
    return (
      t.features.forEach(function (t, e) {
        if (!u[e]) {
          var n = f(e);
          if (n.length >= r) {
            var i = g;
            g++, (u[e] = !0), p(i, n);
          } else c[e] = !0;
        }
      }),
      t.features.forEach(function (e, n) {
        var r = t.features[n];
        r.properties || (r.properties = {}),
          h[n] >= 0
            ? ((r.properties.dbscan = c[n] ? 'edge' : 'core'), (r.properties.cluster = h[n]))
            : (r.properties.dbscan = 'noise');
      }),
      t
    );
  }
  Zy($y, 'clustersDbscan');
  var Qy = {
      eudist: function (t, e, n) {
        for (var r = t.length, i = 0, o = 0; o < r; o++) {
          var a = (t[o] || 0) - (e[o] || 0);
          i += a * a;
        }
        return n ? Math.sqrt(i) : i;
      },
      mandist: function (t, e, n) {
        for (var r = t.length, i = 0, o = 0; o < r; o++) i += Math.abs((t[o] || 0) - (e[o] || 0));
        return n ? Math.sqrt(i) : i;
      },
      dist: function (t, e, n) {
        var r = Math.abs(t - e);
        return n ? r : r * r;
      },
    },
    Ky = Qy.eudist,
    tv = Qy.dist,
    ev = {
      kmrand: function (t, e) {
        for (var n = {}, r = [], i = e << 2, o = t.length, a = t[0].length > 0; r.length < e && i-- > 0; ) {
          var s = t[Math.floor(Math.random() * o)],
            u = a ? s.join('_') : '' + s;
          n[u] || ((n[u] = !0), r.push(s));
        }
        if (r.length < e) throw new Error('Error initializating clusters');
        return r;
      },
      kmpp: function (t, e) {
        var n = t[0].length ? Ky : tv,
          r = [],
          i = t.length,
          o = t[0].length > 0,
          a = t[Math.floor(Math.random() * i)];
        for (o && a.join('_'), r.push(a); r.length < e; ) {
          for (var s = [], u = r.length, l = 0, c = [], h = 0; h < i; h++) {
            for (var f = 1 / 0, p = 0; p < u; p++) {
              var g = n(t[h], r[p]);
              g <= f && (f = g);
            }
            s[h] = f;
          }
          for (var y = 0; y < i; y++) l += s[y];
          for (var v = 0; v < i; v++) c[v] = { i: v, v: t[v], pr: s[v] / l, cs: 0 };
          c.sort(function (t, e) {
            return t.pr - e.pr;
          }),
            (c[0].cs = c[0].pr);
          for (var d = 1; d < i; d++) c[d].cs = c[d - 1].cs + c[d].pr;
          for (var m = Math.random(), _ = 0; _ < i - 1 && c[_++].cs < m; );
          r.push(c[_ - 1].v);
        }
        return r;
      },
    },
    nv = Qy,
    rv = nv.eudist,
    iv = ev.kmrand,
    ov = ev.kmpp;
  function av(t, e, n) {
    n = n || [];
    for (var r = 0; r < t; r++) n[r] = e;
    return n;
  }
  var sv = function (t, e, n, r) {
      var i = [],
        o = [],
        a = [],
        s = [],
        u = !1,
        l = r || 1e4,
        c = t.length,
        h = t[0].length,
        f = h > 0,
        p = [];
      if (n) i = 'kmrand' == n ? iv(t, e) : 'kmpp' == n ? ov(t, e) : n;
      else
        for (var g = {}; i.length < e; ) {
          var y = Math.floor(Math.random() * c);
          g[y] || ((g[y] = !0), i.push(t[y]));
        }
      do {
        av(e, 0, p);
        for (var v = 0; v < c; v++) {
          for (var d = 1 / 0, m = 0, _ = 0; _ < e; _++) {
            (s = f ? rv(t[v], i[_]) : Math.abs(t[v] - i[_])) <= d && ((d = s), (m = _));
          }
          (a[v] = m), p[m]++;
        }
        for (var b = [], x = ((o = []), 0); x < e; x++) (b[x] = f ? av(h, 0, b[x]) : 0), (o[x] = i[x]);
        if (f) {
          for (var E = 0; E < e; E++) i[E] = [];
          for (var w = 0; w < c; w++) for (var k = b[a[w]], S = t[w], I = 0; I < h; I++) k[I] += S[I];
          u = !0;
          for (var P = 0; P < e; P++) {
            for (var N = i[P], M = b[P], O = o[P], L = p[P], R = 0; R < h; R++) N[R] = M[R] / L || 0;
            if (u)
              for (var C = 0; C < h; C++)
                if (O[C] != N[C]) {
                  u = !1;
                  break;
                }
          }
        } else {
          for (var T = 0; T < c; T++) {
            b[a[T]] += t[T];
          }
          for (var A = 0; A < e; A++) i[A] = b[A] / p[A] || 0;
          u = !0;
          for (var D = 0; D < e; D++)
            if (o[D] != i[D]) {
              u = !1;
              break;
            }
        }
        u = u || --l <= 0;
      } while (!u);
      return { it: 1e4 - l, k: e, idxs: a, centroids: i };
    },
    uv = p(sv),
    lv = Object.defineProperty;
  function cv(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = t.features.length;
    (e.numberOfClusters = e.numberOfClusters || Math.round(Math.sqrt(n / 2))),
      e.numberOfClusters > n && (e.numberOfClusters = n),
      !0 !== e.mutate && (t = Ry(t));
    var r = Dl(t),
      i = r.slice(0, e.numberOfClusters),
      o = uv(r, e.numberOfClusters, i),
      a = {};
    return (
      o.centroids.forEach(function (t, e) {
        a[e] = t;
      }),
      Tl(t, function (t, e) {
        var n = o.idxs[e];
        (t.properties.cluster = n), (t.properties.centroid = a[n]);
      }),
      t
    );
  }
  !(function (t, e) {
    lv(t, 'name', { value: e, configurable: !0 });
  })(cv, 'clustersKmeans');
  var hv = Object.defineProperty,
    fv = Wh;
  function pv(t, e, n, r) {
    var i = new fv(6),
      o = e.features.map(function (t) {
        var e;
        return {
          minX: t.geometry.coordinates[0],
          minY: t.geometry.coordinates[1],
          maxX: t.geometry.coordinates[0],
          maxY: t.geometry.coordinates[1],
          property: null == (e = t.properties) ? void 0 : e[n],
        };
      });
    return (
      i.load(o),
      t.features.forEach(function (t) {
        t.properties || (t.properties = {});
        var e = rc(t),
          n = i.search({ minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] }),
          o = [];
        n.forEach(function (e) {
          Nc([e.minX, e.minY], t) && o.push(e.property);
        }),
          (t.properties[r] = o);
      }),
      t
    );
  }
  !(function (t, e) {
    hv(t, 'name', { value: e, configurable: !0 });
  })(pv, 'collect');
  var gv = Object.defineProperty;
  function yv(t) {
    var e = {
      MultiPoint: { coordinates: [], properties: [] },
      MultiLineString: { coordinates: [], properties: [] },
      MultiPolygon: { coordinates: [], properties: [] },
    };
    return (
      Tl(t, function (t) {
        var n, r, i, o;
        switch (null == (o = t.geometry) ? void 0 : o.type) {
          case 'Point':
            e.MultiPoint.coordinates.push(t.geometry.coordinates), e.MultiPoint.properties.push(t.properties);
            break;
          case 'MultiPoint':
            (n = e.MultiPoint.coordinates).push.apply(n, s(t.geometry.coordinates)),
              e.MultiPoint.properties.push(t.properties);
            break;
          case 'LineString':
            e.MultiLineString.coordinates.push(t.geometry.coordinates), e.MultiLineString.properties.push(t.properties);
            break;
          case 'MultiLineString':
            (r = e.MultiLineString.coordinates).push.apply(r, s(t.geometry.coordinates)),
              e.MultiLineString.properties.push(t.properties);
            break;
          case 'Polygon':
            e.MultiPolygon.coordinates.push(t.geometry.coordinates), e.MultiPolygon.properties.push(t.properties);
            break;
          case 'MultiPolygon':
            (i = e.MultiPolygon.coordinates).push.apply(i, s(t.geometry.coordinates)),
              e.MultiPolygon.properties.push(t.properties);
        }
      }),
      ju(
        Object.keys(e)
          .filter(function (t) {
            return e[t].coordinates.length;
          })
          .sort()
          .map(function (t) {
            return Mu({ type: t, coordinates: e[t].coordinates }, { collectedProperties: e[t].properties });
          }),
      )
    );
  }
  !(function (t, e) {
    gv(t, 'name', { value: e, configurable: !0 });
  })(yv, 'combine');
  var vv = Object.defineProperty,
    dv = function (t, e) {
      return vv(t, 'name', { value: e, configurable: !0 });
    };
  function mv(t, e) {
    var n = !1;
    return ju(
      wv(
        t.features.map(function (t) {
          var r = { x: t.geometry.coordinates[0], y: t.geometry.coordinates[1] };
          return (
            e
              ? (r.z = t.properties[e])
              : 3 === t.geometry.coordinates.length && ((n = !0), (r.z = t.geometry.coordinates[2])),
            r
          );
        }),
      ).map(function (t) {
        var e = [t.a.x, t.a.y],
          r = [t.b.x, t.b.y],
          i = [t.c.x, t.c.y],
          o = {};
        return (
          n ? (e.push(t.a.z), r.push(t.b.z), i.push(t.c.z)) : (o = { a: t.a.z, b: t.b.z, c: t.c.z }),
          Cu([[e, r, i, e]], o)
        );
      }),
    );
  }
  dv(mv, 'tin');
  var _v = i(function t(e, r, i) {
    n(this, t), (this.a = e), (this.b = r), (this.c = i);
    var o,
      a,
      s = r.x - e.x,
      u = r.y - e.y,
      l = i.x - e.x,
      c = i.y - e.y,
      h = s * (e.x + r.x) + u * (e.y + r.y),
      f = l * (e.x + i.x) + c * (e.y + i.y),
      p = 2 * (s * (i.y - r.y) - u * (i.x - r.x));
    (this.x = (c * h - u * f) / p),
      (this.y = (s * f - l * h) / p),
      (o = this.x - e.x),
      (a = this.y - e.y),
      (this.r = o * o + a * a);
  });
  dv(_v, 'Triangle');
  var bv = _v;
  function xv(t, e) {
    return e.x - t.x;
  }
  function Ev(t) {
    var e,
      n,
      r,
      i,
      o,
      a = t.length;
    t: for (; a; )
      for (n = t[--a], e = t[--a], r = a; r; )
        if (((o = t[--r]), (e === (i = t[--r]) && n === o) || (e === o && n === i))) {
          t.splice(a, 2), t.splice(r, 2), (a -= 2);
          continue t;
        }
  }
  function wv(t) {
    if (t.length < 3) return [];
    t.sort(xv);
    for (var e, n, r, i, o, a, s = t.length - 1, u = t[s].x, l = t[0].x, c = t[s].y, h = c; s--; )
      t[s].y < c && (c = t[s].y), t[s].y > h && (h = t[s].y);
    var f,
      p = l - u,
      g = h - c,
      y = p > g ? p : g,
      v = 0.5 * (l + u),
      d = 0.5 * (h + c),
      m = [
        new bv(
          { __sentinel: !0, x: v - 20 * y, y: d - y },
          { __sentinel: !0, x: v, y: d + 20 * y },
          { __sentinel: !0, x: v + 20 * y, y: d - y },
        ),
      ],
      _ = [],
      b = [];
    for (s = t.length; s--; ) {
      for (b.length = 0, f = m.length; f--; )
        (p = t[s].x - m[f].x) > 0 && p * p > m[f].r
          ? (_.push(m[f]), m.splice(f, 1))
          : p * p + (g = t[s].y - m[f].y) * g > m[f].r ||
            (b.push(m[f].a, m[f].b, m[f].b, m[f].c, m[f].c, m[f].a), m.splice(f, 1));
      for (Ev(b), f = b.length; f; )
        (n = b[--f]),
          (e = b[--f]),
          (r = t[s]),
          (i = n.x - e.x),
          (o = n.y - e.y),
          (a = 2 * (i * (r.y - n.y) - o * (r.x - n.x))),
          Math.abs(a) > 1e-12 && m.push(new bv(e, n, r));
    }
    for (Array.prototype.push.apply(_, m), s = _.length; s--; )
      (_[s].a.__sentinel || _[s].b.__sentinel || _[s].c.__sentinel) && _.splice(s, 1);
    return _;
  }
  function kv(t) {
    return t;
  }
  function Sv(t, e) {
    var n = (function (t) {
        if (null == t) return kv;
        var e,
          n,
          r = t.scale[0],
          i = t.scale[1],
          o = t.translate[0],
          a = t.translate[1];
        return function (t, s) {
          s || (e = n = 0);
          var u = 2,
            l = t.length,
            c = new Array(l);
          for (c[0] = (e += t[0]) * r + o, c[1] = (n += t[1]) * i + a; u < l; ) (c[u] = t[u]), ++u;
          return c;
        };
      })(t.transform),
      r = t.arcs;
    function i(t, e) {
      e.length && e.pop();
      for (var i = r[t < 0 ? ~t : t], o = 0, a = i.length; o < a; ++o) e.push(n(i[o], o));
      t < 0 &&
        (function (t, e) {
          for (var n, r = t.length, i = r - e; i < --r; ) (n = t[i]), (t[i++] = t[r]), (t[r] = n);
        })(e, a);
    }
    function o(t) {
      return n(t);
    }
    function a(t) {
      for (var e = [], n = 0, r = t.length; n < r; ++n) i(t[n], e);
      return e.length < 2 && e.push(e[0]), e;
    }
    function s(t) {
      for (var e = a(t); e.length < 4; ) e.push(e[0]);
      return e;
    }
    function u(t) {
      return t.map(s);
    }
    return (function t(e) {
      var n,
        r = e.type;
      switch (r) {
        case 'GeometryCollection':
          return { type: r, geometries: e.geometries.map(t) };
        case 'Point':
          n = o(e.coordinates);
          break;
        case 'MultiPoint':
          n = e.coordinates.map(o);
          break;
        case 'LineString':
          n = a(e.arcs);
          break;
        case 'MultiLineString':
          n = e.arcs.map(a);
          break;
        case 'Polygon':
          n = u(e.arcs);
          break;
        case 'MultiPolygon':
          n = e.arcs.map(u);
          break;
        default:
          return null;
      }
      return { type: r, coordinates: n };
    })(e);
  }
  function Iv(t, e) {
    var n = {},
      r = {},
      i = {},
      o = [],
      a = -1;
    function s(t, e) {
      for (var r in t) {
        var i = t[r];
        delete e[i.start],
          delete i.start,
          delete i.end,
          i.forEach(function (t) {
            n[t < 0 ? ~t : t] = 1;
          }),
          o.push(i);
      }
    }
    return (
      e.forEach(function (n, r) {
        var i,
          o = t.arcs[n < 0 ? ~n : n];
        o.length < 3 && !o[1][0] && !o[1][1] && ((i = e[++a]), (e[a] = n), (e[r] = i));
      }),
      e.forEach(function (e) {
        var n,
          o,
          a = (function (e) {
            var n,
              r = t.arcs[e < 0 ? ~e : e],
              i = r[0];
            t.transform
              ? ((n = [0, 0]),
                r.forEach(function (t) {
                  (n[0] += t[0]), (n[1] += t[1]);
                }))
              : (n = r[r.length - 1]);
            return e < 0 ? [n, i] : [i, n];
          })(e),
          s = a[0],
          u = a[1];
        if ((n = i[s]))
          if ((delete i[n.end], n.push(e), (n.end = u), (o = r[u]))) {
            delete r[o.start];
            var l = o === n ? n : n.concat(o);
            r[(l.start = n.start)] = i[(l.end = o.end)] = l;
          } else r[n.start] = i[n.end] = n;
        else if ((n = r[u]))
          if ((delete r[n.start], n.unshift(e), (n.start = s), (o = i[s]))) {
            delete i[o.end];
            var c = o === n ? n : o.concat(n);
            r[(c.start = o.start)] = i[(c.end = n.end)] = c;
          } else r[n.start] = i[n.end] = n;
        else r[((n = [e]).start = s)] = i[(n.end = u)] = n;
      }),
      s(i, r),
      s(r, i),
      e.forEach(function (t) {
        n[t < 0 ? ~t : t] || o.push([t]);
      }),
      o
    );
  }
  function Pv(t) {
    return Sv(t, Nv.apply(this, arguments));
  }
  function Nv(t, e) {
    var n = {},
      r = [],
      i = [];
    function o(t) {
      t.forEach(function (e) {
        e.forEach(function (e) {
          (n[(e = e < 0 ? ~e : e)] || (n[e] = [])).push(t);
        });
      }),
        r.push(t);
    }
    function a(e) {
      return (function (t) {
        for (var e, n = -1, r = t.length, i = t[r - 1], o = 0; ++n < r; )
          (e = i), (i = t[n]), (o += e[0] * i[1] - e[1] * i[0]);
        return Math.abs(o);
      })(Sv(t, { type: 'Polygon', arcs: [e] }).coordinates[0]);
    }
    return (
      e.forEach(function t(e) {
        switch (e.type) {
          case 'GeometryCollection':
            e.geometries.forEach(t);
            break;
          case 'Polygon':
            o(e.arcs);
            break;
          case 'MultiPolygon':
            e.arcs.forEach(o);
        }
      }),
      r.forEach(function (t) {
        if (!t._) {
          var e = [],
            r = [t];
          for (t._ = 1, i.push(e); (t = r.pop()); )
            e.push(t),
              t.forEach(function (t) {
                t.forEach(function (t) {
                  n[t < 0 ? ~t : t].forEach(function (t) {
                    t._ || ((t._ = 1), r.push(t));
                  });
                });
              });
        }
      }),
      r.forEach(function (t) {
        delete t._;
      }),
      {
        type: 'MultiPolygon',
        arcs: i
          .map(function (e) {
            var r,
              i = [];
            if (
              (e.forEach(function (t) {
                t.forEach(function (t) {
                  t.forEach(function (t) {
                    n[t < 0 ? ~t : t].length < 2 && i.push(t);
                  });
                });
              }),
              (r = (i = Iv(t, i)).length) > 1)
            )
              for (var o, s, u = 1, l = a(i[0]); u < r; ++u)
                (o = a(i[u])) > l && ((s = i[0]), (i[0] = i[u]), (i[u] = s), (l = o));
            return i;
          })
          .filter(function (t) {
            return t.length > 0;
          }),
      }
    );
  }
  dv(xv, 'byX'), dv(Ev, 'dedup'), dv(wv, 'triangulate');
  var Mv = Object.prototype.hasOwnProperty;
  function Ov(t, e, n, r, i, o) {
    3 === arguments.length && ((r = o = Array), (i = null));
    for (
      var a = new r((t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2)))), s = new o(t), u = t - 1, l = 0;
      l < t;
      ++l
    )
      a[l] = i;
    return {
      set: function (r, o) {
        for (var l = e(r) & u, c = a[l], h = 0; c != i; ) {
          if (n(c, r)) return (s[l] = o);
          if (++h >= t) throw new Error('full hashmap');
          c = a[(l = (l + 1) & u)];
        }
        return (a[l] = r), (s[l] = o), o;
      },
      maybeSet: function (r, o) {
        for (var l = e(r) & u, c = a[l], h = 0; c != i; ) {
          if (n(c, r)) return s[l];
          if (++h >= t) throw new Error('full hashmap');
          c = a[(l = (l + 1) & u)];
        }
        return (a[l] = r), (s[l] = o), o;
      },
      get: function (r, o) {
        for (var l = e(r) & u, c = a[l], h = 0; c != i; ) {
          if (n(c, r)) return s[l];
          if (++h >= t) break;
          c = a[(l = (l + 1) & u)];
        }
        return o;
      },
      keys: function () {
        for (var t = [], e = 0, n = a.length; e < n; ++e) {
          var r = a[e];
          r != i && t.push(r);
        }
        return t;
      },
    };
  }
  function Lv(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  var Rv = new ArrayBuffer(16),
    Cv = new Float64Array(Rv),
    Tv = new Uint32Array(Rv);
  function Av(t) {
    (Cv[0] = t[0]), (Cv[1] = t[1]);
    var e = Tv[0] ^ Tv[1];
    return 2147483647 & (e = (e << 5) ^ (e >> 7) ^ Tv[2] ^ Tv[3]);
  }
  function Dv(t) {
    var e,
      n,
      r,
      i,
      o = t.coordinates,
      a = t.lines,
      s = t.rings,
      u = (function () {
        for (
          var t = Ov(1.4 * o.length, x, E, Int32Array, -1, Int32Array),
            e = new Int32Array(o.length),
            n = 0,
            r = o.length;
          n < r;
          ++n
        )
          e[n] = t.maybeSet(n, n);
        return e;
      })(),
      l = new Int32Array(o.length),
      c = new Int32Array(o.length),
      h = new Int32Array(o.length),
      f = new Int8Array(o.length),
      p = 0;
    for (e = 0, n = o.length; e < n; ++e) l[e] = c[e] = h[e] = -1;
    for (e = 0, n = a.length; e < n; ++e) {
      var g = a[e],
        y = g[0],
        v = g[1];
      for (r = u[y], i = u[++y], ++p, f[r] = 1; ++y <= v; ) b(e, r, (r = i), (i = u[y]));
      ++p, (f[i] = 1);
    }
    for (e = 0, n = o.length; e < n; ++e) l[e] = -1;
    for (e = 0, n = s.length; e < n; ++e) {
      var d = s[e],
        m = d[0] + 1,
        _ = d[1];
      for (b(e, u[_ - 1], (r = u[m - 1]), (i = u[m])); ++m <= _; ) b(e, r, (r = i), (i = u[m]));
    }
    function b(t, e, n, r) {
      if (l[n] !== t) {
        l[n] = t;
        var i = c[n];
        if (i >= 0) {
          var o = h[n];
          (i === e && o === r) || (i === r && o === e) || (++p, (f[n] = 1));
        } else (c[n] = e), (h[n] = r);
      }
    }
    function x(t) {
      return Av(o[t]);
    }
    function E(t, e) {
      return Lv(o[t], o[e]);
    }
    l = c = h = null;
    var w,
      k = (function (t, e, n, r, i) {
        3 === arguments.length && ((r = Array), (i = null));
        for (var o = new r((t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2)))), a = t - 1, s = 0; s < t; ++s)
          o[s] = i;
        return {
          add: function (r) {
            for (var s = e(r) & a, u = o[s], l = 0; u != i; ) {
              if (n(u, r)) return !0;
              if (++l >= t) throw new Error('full hashset');
              u = o[(s = (s + 1) & a)];
            }
            return (o[s] = r), !0;
          },
          has: function (r) {
            for (var s = e(r) & a, u = o[s], l = 0; u != i; ) {
              if (n(u, r)) return !0;
              if (++l >= t) break;
              u = o[(s = (s + 1) & a)];
            }
            return !1;
          },
          values: function () {
            for (var t = [], e = 0, n = o.length; e < n; ++e) {
              var r = o[e];
              r != i && t.push(r);
            }
            return t;
          },
        };
      })(1.4 * p, Av, Lv);
    for (e = 0, n = o.length; e < n; ++e) f[(w = u[e])] && k.add(o[w]);
    return k;
  }
  function jv(t, e, n, r) {
    Fv(t, e, n), Fv(t, e, e + r), Fv(t, e + r, n);
  }
  function Fv(t, e, n) {
    for (var r, i = e + ((n-- - e) >> 1); e < i; ++e, --n) (r = t[e]), (t[e] = t[n]), (t[n] = r);
  }
  function Bv(t) {
    var e,
      n,
      r = {};
    for (e in t)
      r[e] =
        null == (n = t[e]) ? { type: null } : ('FeatureCollection' === n.type ? qv : 'Feature' === n.type ? Vv : Gv)(n);
    return r;
  }
  function qv(t) {
    var e = { type: 'GeometryCollection', geometries: t.features.map(Vv) };
    return null != t.bbox && (e.bbox = t.bbox), e;
  }
  function Vv(t) {
    var e,
      n = Gv(t.geometry);
    for (e in (null != t.id && (n.id = t.id), null != t.bbox && (n.bbox = t.bbox), t.properties)) {
      n.properties = t.properties;
      break;
    }
    return n;
  }
  function Gv(t) {
    if (null == t) return { type: null };
    var e =
      'GeometryCollection' === t.type
        ? { type: 'GeometryCollection', geometries: t.geometries.map(Gv) }
        : 'Point' === t.type || 'MultiPoint' === t.type
        ? { type: t.type, coordinates: t.coordinates }
        : { type: t.type, arcs: t.coordinates };
    return null != t.bbox && (e.bbox = t.bbox), e;
  }
  function Yv(t, e) {
    var n = (function (t) {
        var e = 1 / 0,
          n = 1 / 0,
          r = -1 / 0,
          i = -1 / 0;
        function o(t) {
          null != t && Mv.call(a, t.type) && a[t.type](t);
        }
        var a = {
          GeometryCollection: function (t) {
            t.geometries.forEach(o);
          },
          Point: function (t) {
            s(t.coordinates);
          },
          MultiPoint: function (t) {
            t.coordinates.forEach(s);
          },
          LineString: function (t) {
            u(t.arcs);
          },
          MultiLineString: function (t) {
            t.arcs.forEach(u);
          },
          Polygon: function (t) {
            t.arcs.forEach(u);
          },
          MultiPolygon: function (t) {
            t.arcs.forEach(l);
          },
        };
        function s(t) {
          var o = t[0],
            a = t[1];
          o < e && (e = o), o > r && (r = o), a < n && (n = a), a > i && (i = a);
        }
        function u(t) {
          t.forEach(s);
        }
        function l(t) {
          t.forEach(u);
        }
        for (var c in t) o(t[c]);
        return r >= e && i >= n ? [e, n, r, i] : void 0;
      })((t = Bv(t))),
      r =
        e > 0 &&
        n &&
        (function (t, e, n) {
          var r = e[0],
            i = e[1],
            o = e[2],
            a = e[3],
            s = o - r ? (n - 1) / (o - r) : 1,
            u = a - i ? (n - 1) / (a - i) : 1;
          function l(t) {
            return [Math.round((t[0] - r) * s), Math.round((t[1] - i) * u)];
          }
          function c(t, e) {
            for (var n, o, a, l, c, h = -1, f = 0, p = t.length, g = new Array(p); ++h < p; )
              (n = t[h]),
                (l = Math.round((n[0] - r) * s)),
                (c = Math.round((n[1] - i) * u)),
                (l === o && c === a) || (g[f++] = [(o = l), (a = c)]);
            for (g.length = f; f < e; ) f = g.push([g[0][0], g[0][1]]);
            return g;
          }
          function h(t) {
            return c(t, 2);
          }
          function f(t) {
            return c(t, 4);
          }
          function p(t) {
            return t.map(f);
          }
          function g(t) {
            null != t && Mv.call(y, t.type) && y[t.type](t);
          }
          var y = {
            GeometryCollection: function (t) {
              t.geometries.forEach(g);
            },
            Point: function (t) {
              t.coordinates = l(t.coordinates);
            },
            MultiPoint: function (t) {
              t.coordinates = t.coordinates.map(l);
            },
            LineString: function (t) {
              t.arcs = h(t.arcs);
            },
            MultiLineString: function (t) {
              t.arcs = t.arcs.map(h);
            },
            Polygon: function (t) {
              t.arcs = p(t.arcs);
            },
            MultiPolygon: function (t) {
              t.arcs = t.arcs.map(p);
            },
          };
          for (var v in t) g(t[v]);
          return { scale: [1 / s, 1 / u], translate: [r, i] };
        })(t, n, e),
      i = (function (t) {
        var e,
          n,
          r,
          i,
          o = t.coordinates,
          a = t.lines,
          s = t.rings,
          u = a.length + s.length;
        for (delete t.lines, delete t.rings, r = 0, i = a.length; r < i; ++r) for (e = a[r]; (e = e.next); ) ++u;
        for (r = 0, i = s.length; r < i; ++r) for (n = s[r]; (n = n.next); ) ++u;
        var l = Ov(2 * u * 1.4, Av, Lv),
          c = (t.arcs = []);
        for (r = 0, i = a.length; r < i; ++r) {
          e = a[r];
          do {
            h(e);
          } while ((e = e.next));
        }
        for (r = 0, i = s.length; r < i; ++r)
          if ((n = s[r]).next)
            do {
              h(n);
            } while ((n = n.next));
          else f(n);
        function h(t) {
          var e, n, r, i, a, s, u, h;
          if ((r = l.get((e = o[t[0]]))))
            for (u = 0, h = r.length; u < h; ++u) if (p((i = r[u]), t)) return (t[0] = i[0]), void (t[1] = i[1]);
          if ((a = l.get((n = o[t[1]]))))
            for (u = 0, h = a.length; u < h; ++u) if (g((s = a[u]), t)) return (t[1] = s[0]), void (t[0] = s[1]);
          r ? r.push(t) : l.set(e, [t]), a ? a.push(t) : l.set(n, [t]), c.push(t);
        }
        function f(t) {
          var e, n, r, i, a;
          if ((n = l.get(o[t[0]])))
            for (i = 0, a = n.length; i < a; ++i) {
              if (y((r = n[i]), t)) return (t[0] = r[0]), void (t[1] = r[1]);
              if (v(r, t)) return (t[0] = r[1]), void (t[1] = r[0]);
            }
          if ((n = l.get((e = o[t[0] + d(t)]))))
            for (i = 0, a = n.length; i < a; ++i) {
              if (y((r = n[i]), t)) return (t[0] = r[0]), void (t[1] = r[1]);
              if (v(r, t)) return (t[0] = r[1]), void (t[1] = r[0]);
            }
          n ? n.push(t) : l.set(e, [t]), c.push(t);
        }
        function p(t, e) {
          var n = t[0],
            r = e[0],
            i = t[1];
          if (n - i != r - e[1]) return !1;
          for (; n <= i; ++n, ++r) if (!Lv(o[n], o[r])) return !1;
          return !0;
        }
        function g(t, e) {
          var n = t[0],
            r = e[0],
            i = t[1],
            a = e[1];
          if (n - i != r - a) return !1;
          for (; n <= i; ++n, --a) if (!Lv(o[n], o[a])) return !1;
          return !0;
        }
        function y(t, e) {
          var n = t[0],
            r = e[0],
            i = t[1] - n;
          if (i !== e[1] - r) return !1;
          for (var a = d(t), s = d(e), u = 0; u < i; ++u)
            if (!Lv(o[n + ((u + a) % i)], o[r + ((u + s) % i)])) return !1;
          return !0;
        }
        function v(t, e) {
          var n = t[0],
            r = e[0],
            i = t[1],
            a = e[1],
            s = i - n;
          if (s !== a - r) return !1;
          for (var u = d(t), l = s - d(e), c = 0; c < s; ++c)
            if (!Lv(o[n + ((c + u) % s)], o[a - ((c + l) % s)])) return !1;
          return !0;
        }
        function d(t) {
          for (var e = t[0], n = t[1], r = e, i = r, a = o[r]; ++r < n; ) {
            var s = o[r];
            (s[0] < a[0] || (s[0] === a[0] && s[1] < a[1])) && ((i = r), (a = s));
          }
          return i - e;
        }
        return t;
      })(
        (function (t) {
          var e,
            n,
            r,
            i = Dv(t),
            o = t.coordinates,
            a = t.lines,
            s = t.rings;
          for (n = 0, r = a.length; n < r; ++n)
            for (var u = a[n], l = u[0], c = u[1]; ++l < c; )
              i.has(o[l]) && ((e = { 0: l, 1: u[1] }), (u[1] = l), (u = u.next = e));
          for (n = 0, r = s.length; n < r; ++n)
            for (var h = s[n], f = h[0], p = f, g = h[1], y = i.has(o[f]); ++p < g; )
              i.has(o[p]) &&
                (y
                  ? ((e = { 0: p, 1: h[1] }), (h[1] = p), (h = h.next = e))
                  : (jv(o, f, g, g - p), (o[g] = o[f]), (y = !0), (p = f)));
          return t;
        })(
          (function (t) {
            var e = -1,
              n = [],
              r = [],
              i = [];
            function o(t) {
              t && Mv.call(a, t.type) && a[t.type](t);
            }
            var a = {
              GeometryCollection: function (t) {
                t.geometries.forEach(o);
              },
              LineString: function (t) {
                t.arcs = s(t.arcs);
              },
              MultiLineString: function (t) {
                t.arcs = t.arcs.map(s);
              },
              Polygon: function (t) {
                t.arcs = t.arcs.map(u);
              },
              MultiPolygon: function (t) {
                t.arcs = t.arcs.map(l);
              },
            };
            function s(t) {
              for (var r = 0, o = t.length; r < o; ++r) i[++e] = t[r];
              var a = { 0: e - o + 1, 1: e };
              return n.push(a), a;
            }
            function u(t) {
              for (var n = 0, o = t.length; n < o; ++n) i[++e] = t[n];
              var a = { 0: e - o + 1, 1: e };
              return r.push(a), a;
            }
            function l(t) {
              return t.map(u);
            }
            for (var c in t) o(t[c]);
            return { type: 'Topology', coordinates: i, lines: n, rings: r, objects: t };
          })(t),
        ),
      ),
      o = i.coordinates,
      a = Ov(1.4 * i.arcs.length, zv, Uv);
    function s(t) {
      t && Mv.call(u, t.type) && u[t.type](t);
    }
    (t = i.objects),
      (i.bbox = n),
      (i.arcs = i.arcs.map(function (t, e) {
        return a.set(t, e), o.slice(t[0], t[1] + 1);
      })),
      delete i.coordinates,
      (o = null);
    var u = {
      GeometryCollection: function (t) {
        t.geometries.forEach(s);
      },
      LineString: function (t) {
        t.arcs = l(t.arcs);
      },
      MultiLineString: function (t) {
        t.arcs = t.arcs.map(l);
      },
      Polygon: function (t) {
        t.arcs = t.arcs.map(l);
      },
      MultiPolygon: function (t) {
        t.arcs = t.arcs.map(c);
      },
    };
    function l(t) {
      var e = [];
      do {
        var n = a.get(t);
        e.push(t[0] < t[1] ? n : ~n);
      } while ((t = t.next));
      return e;
    }
    function c(t) {
      return t.map(l);
    }
    for (var h in t) s(t[h]);
    return (
      r &&
        ((i.transform = r),
        (i.arcs = (function (t) {
          for (var e = -1, n = t.length; ++e < n; ) {
            for (var r, i, o = t[e], a = 0, s = 1, u = o.length, l = o[0], c = l[0], h = l[1]; ++a < u; )
              (r = (l = o[a])[0]), (i = l[1]), (r === c && i === h) || ((o[s++] = [r - c, i - h]), (c = r), (h = i));
            1 === s && (o[s++] = [0, 0]), (o.length = s);
          }
          return t;
        })(i.arcs))),
      i
    );
  }
  function zv(t) {
    var e,
      n = t[0],
      r = t[1];
    return r < n && ((e = n), (n = r), (r = e)), n + 31 * r;
  }
  function Uv(t, e) {
    var n,
      r = t[0],
      i = t[1],
      o = e[0],
      a = e[1];
    return i < r && ((n = r), (r = i), (i = n)), a < o && ((n = o), (o = a), (a = n)), r === o && i === a;
  }
  var Xv = Object.defineProperty,
    Wv = function (t, e) {
      return Xv(t, 'name', { value: e, configurable: !0 });
    };
  function Hv(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.mutate;
    if ('FeatureCollection' !== hl(t)) throw new Error('geojson must be a FeatureCollection');
    if (!t.features.length) throw new Error('geojson is empty');
    (!1 !== n && void 0 !== n) || (t = Ry(t));
    var r = [],
      i = zl(t, function (t, e) {
        var n = Jv(t, e);
        return n || (r.push(t), e);
      });
    return (
      i && r.push(i),
      r.length
        ? 1 === r.length
          ? r[0]
          : Fu(
              r.map(function (t) {
                return t.coordinates;
              }),
            )
        : null
    );
  }
  function Zv(t) {
    return t[0].toString() + ',' + t[1].toString();
  }
  function Jv(t, e) {
    var n,
      r = t.geometry.coordinates,
      i = e.geometry.coordinates,
      o = Zv(r[0]),
      a = Zv(r[r.length - 1]),
      s = Zv(i[0]),
      u = Zv(i[i.length - 1]);
    if (o === u) n = i.concat(r.slice(1));
    else if (s === a) n = r.concat(i.slice(1));
    else if (o === s) n = r.slice(1).reverse().concat(i);
    else {
      if (a !== u) return null;
      n = r.concat(i.reverse().slice(1));
    }
    return Au(n);
  }
  function $v(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if ('FeatureCollection' !== hl(t)) throw new Error('geojson must be a FeatureCollection');
    if (!t.features.length) throw new Error('geojson is empty');
    (!1 !== e.mutate && void 0 !== e.mutate) || (t = Ry(t));
    var n = [];
    Bl(t, function (t) {
      n.push(t.geometry);
    });
    var r = Yv({ geoms: Vu(n).geometry });
    return Pv(r, r.objects.geoms.geometries);
  }
  function Qv(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.mutate;
    if ('FeatureCollection' !== hl(t)) throw new Error('geojson must be a FeatureCollection');
    if (!t.features.length) throw new Error('geojson is empty');
    (!1 !== n && void 0 !== n) || (t = Ry(t));
    var r = Kv(t);
    if (!r) throw new Error('geojson must be homogenous');
    var i = t;
    switch (r) {
      case 'LineString':
        return Hv(i, e);
      case 'Polygon':
        return $v(i, e);
      default:
        throw new Error(r + ' is not supported');
    }
  }
  function Kv(t) {
    var e = {};
    Bl(t, function (t) {
      e[t.geometry.type] = !0;
    });
    var n = Object.keys(e);
    return 1 === n.length ? n[0] : null;
  }
  function td(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = e.maxEdge || 1 / 0,
      r = mv(ed(t));
    if (
      ((r.features = r.features.filter(function (t) {
        var r = t.geometry.coordinates[0][0],
          i = t.geometry.coordinates[0][1],
          o = t.geometry.coordinates[0][2],
          a = _l(r, i, e),
          s = _l(i, o, e),
          u = _l(r, o, e);
        return a <= n && s <= n && u <= n;
      })),
      r.features.length < 1)
    )
      return null;
    var i = Qv(r);
    return 1 === i.coordinates.length && ((i.coordinates = i.coordinates[0]), (i.type = 'Polygon')), Mu(i);
  }
  function ed(t) {
    var e = [],
      n = {};
    return (
      Tl(t, function (t) {
        if (t.geometry) {
          var r = t.geometry.coordinates.join('-');
          Object.prototype.hasOwnProperty.call(n, r) || (e.push(t), (n[r] = !0));
        }
      }),
      ju(e)
    );
  }
  /**
   * splaytree v3.1.2
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   */
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  function nd(t, e) {
    var n,
      r,
      i,
      o,
      a = {
        label: 0,
        sent: function () {
          if (1 & i[0]) throw i[1];
          return i[1];
        },
        trys: [],
        ops: [],
      };
    return (
      (o = { next: s(0), throw: s(1), return: s(2) }),
      'function' == typeof Symbol &&
        (o[Symbol.iterator] = function () {
          return this;
        }),
      o
    );
    function s(o) {
      return function (s) {
        return (function (o) {
          if (n) throw new TypeError('Generator is already executing.');
          for (; a; )
            try {
              if (
                ((n = 1),
                r &&
                  (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) &&
                  !(i = i.call(r, o[1])).done)
              )
                return i;
              switch (((r = 0), i && (o = [2 & o[0], i.value]), o[0])) {
                case 0:
                case 1:
                  i = o;
                  break;
                case 4:
                  return a.label++, { value: o[1], done: !1 };
                case 5:
                  a.label++, (r = o[1]), (o = [0]);
                  continue;
                case 7:
                  (o = a.ops.pop()), a.trys.pop();
                  continue;
                default:
                  if (!((i = a.trys), (i = i.length > 0 && i[i.length - 1]) || (6 !== o[0] && 2 !== o[0]))) {
                    a = 0;
                    continue;
                  }
                  if (3 === o[0] && (!i || (o[1] > i[0] && o[1] < i[3]))) {
                    a.label = o[1];
                    break;
                  }
                  if (6 === o[0] && a.label < i[1]) {
                    (a.label = i[1]), (i = o);
                    break;
                  }
                  if (i && a.label < i[2]) {
                    (a.label = i[2]), a.ops.push(o);
                    break;
                  }
                  i[2] && a.ops.pop(), a.trys.pop();
                  continue;
              }
              o = e.call(t, a);
            } catch (t) {
              (o = [6, t]), (r = 0);
            } finally {
              n = i = 0;
            }
          if (5 & o[0]) throw o[1];
          return { value: o[0] ? o[1] : void 0, done: !0 };
        })([o, s]);
      };
    }
  }
  Wv(Hv, 'lineDissolve'),
    Wv(Zv, 'coordId'),
    Wv(Jv, 'mergeLineStrings'),
    Wv($v, 'polygonDissolve'),
    Wv(Qv, 'dissolve'),
    Wv(Kv, 'getHomogenousType'),
    Wv(td, 'concave'),
    Wv(ed, 'removeDuplicates');
  var rd = function (t, e) {
    (this.next = null), (this.key = t), (this.data = e), (this.left = null), (this.right = null);
  };
  function id(t, e) {
    return t > e ? 1 : t < e ? -1 : 0;
  }
  function od(t, e, n) {
    for (var r = new rd(null, null), i = r, o = r; ; ) {
      var a = n(t, e.key);
      if (a < 0) {
        if (null === e.left) break;
        if (n(t, e.left.key) < 0) {
          var s = e.left;
          if (((e.left = s.right), (s.right = e), null === (e = s).left)) break;
        }
        (o.left = e), (o = e), (e = e.left);
      } else {
        if (!(a > 0)) break;
        if (null === e.right) break;
        if (n(t, e.right.key) > 0) {
          s = e.right;
          if (((e.right = s.left), (s.left = e), null === (e = s).right)) break;
        }
        (i.right = e), (i = e), (e = e.right);
      }
    }
    return (i.right = e.left), (o.left = e.right), (e.left = r.right), (e.right = r.left), e;
  }
  function ad(t, e, n, r) {
    var i = new rd(t, e);
    if (null === n) return (i.left = i.right = null), i;
    var o = r(t, (n = od(t, n, r)).key);
    return (
      o < 0
        ? ((i.left = n.left), (i.right = n), (n.left = null))
        : o >= 0 && ((i.right = n.right), (i.left = n), (n.right = null)),
      i
    );
  }
  function sd(t, e, n) {
    var r = null,
      i = null;
    if (e) {
      var o = n((e = od(t, e, n)).key, t);
      0 === o
        ? ((r = e.left), (i = e.right))
        : o < 0
        ? ((i = e.right), (e.right = null), (r = e))
        : ((r = e.left), (e.left = null), (i = e));
    }
    return { left: r, right: i };
  }
  function ud(t, e, n, r, i) {
    if (t) {
      r(e + (n ? '└── ' : '├── ') + i(t) + '\n');
      var o = e + (n ? '    ' : '│   ');
      t.left && ud(t.left, o, !1, r, i), t.right && ud(t.right, o, !0, r, i);
    }
  }
  var ld = (function () {
    function t(t) {
      void 0 === t && (t = id), (this._root = null), (this._size = 0), (this._comparator = t);
    }
    return (
      (t.prototype.insert = function (t, e) {
        return this._size++, (this._root = ad(t, e, this._root, this._comparator));
      }),
      (t.prototype.add = function (t, e) {
        var n = new rd(t, e);
        null === this._root && ((n.left = n.right = null), this._size++, (this._root = n));
        var r = this._comparator,
          i = od(t, this._root, r),
          o = r(t, i.key);
        return (
          0 === o
            ? (this._root = i)
            : (o < 0
                ? ((n.left = i.left), (n.right = i), (i.left = null))
                : o > 0 && ((n.right = i.right), (n.left = i), (i.right = null)),
              this._size++,
              (this._root = n)),
          this._root
        );
      }),
      (t.prototype.remove = function (t) {
        this._root = this._remove(t, this._root, this._comparator);
      }),
      (t.prototype._remove = function (t, e, n) {
        var r;
        return null === e
          ? null
          : 0 === n(t, (e = od(t, e, n)).key)
          ? (null === e.left ? (r = e.right) : ((r = od(t, e.left, n)).right = e.right), this._size--, r)
          : e;
      }),
      (t.prototype.pop = function () {
        var t = this._root;
        if (t) {
          for (; t.left; ) t = t.left;
          return (
            (this._root = od(t.key, this._root, this._comparator)),
            (this._root = this._remove(t.key, this._root, this._comparator)),
            { key: t.key, data: t.data }
          );
        }
        return null;
      }),
      (t.prototype.findStatic = function (t) {
        for (var e = this._root, n = this._comparator; e; ) {
          var r = n(t, e.key);
          if (0 === r) return e;
          e = r < 0 ? e.left : e.right;
        }
        return null;
      }),
      (t.prototype.find = function (t) {
        return this._root &&
          ((this._root = od(t, this._root, this._comparator)), 0 !== this._comparator(t, this._root.key))
          ? null
          : this._root;
      }),
      (t.prototype.contains = function (t) {
        for (var e = this._root, n = this._comparator; e; ) {
          var r = n(t, e.key);
          if (0 === r) return !0;
          e = r < 0 ? e.left : e.right;
        }
        return !1;
      }),
      (t.prototype.forEach = function (t, e) {
        for (var n = this._root, r = [], i = !1; !i; )
          null !== n
            ? (r.push(n), (n = n.left))
            : 0 !== r.length
            ? ((n = r.pop()), t.call(e, n), (n = n.right))
            : (i = !0);
        return this;
      }),
      (t.prototype.range = function (t, e, n, r) {
        for (var i = [], o = this._comparator, a = this._root; 0 !== i.length || a; )
          if (a) i.push(a), (a = a.left);
          else {
            if (o((a = i.pop()).key, e) > 0) break;
            if (o(a.key, t) >= 0 && n.call(r, a)) return this;
            a = a.right;
          }
        return this;
      }),
      (t.prototype.keys = function () {
        var t = [];
        return (
          this.forEach(function (e) {
            var n = e.key;
            return t.push(n);
          }),
          t
        );
      }),
      (t.prototype.values = function () {
        var t = [];
        return (
          this.forEach(function (e) {
            var n = e.data;
            return t.push(n);
          }),
          t
        );
      }),
      (t.prototype.min = function () {
        return this._root ? this.minNode(this._root).key : null;
      }),
      (t.prototype.max = function () {
        return this._root ? this.maxNode(this._root).key : null;
      }),
      (t.prototype.minNode = function (t) {
        if ((void 0 === t && (t = this._root), t)) for (; t.left; ) t = t.left;
        return t;
      }),
      (t.prototype.maxNode = function (t) {
        if ((void 0 === t && (t = this._root), t)) for (; t.right; ) t = t.right;
        return t;
      }),
      (t.prototype.at = function (t) {
        for (var e = this._root, n = !1, r = 0, i = []; !n; )
          if (e) i.push(e), (e = e.left);
          else if (i.length > 0) {
            if (((e = i.pop()), r === t)) return e;
            r++, (e = e.right);
          } else n = !0;
        return null;
      }),
      (t.prototype.next = function (t) {
        var e = this._root,
          n = null;
        if (t.right) {
          for (n = t.right; n.left; ) n = n.left;
          return n;
        }
        for (var r = this._comparator; e; ) {
          var i = r(t.key, e.key);
          if (0 === i) break;
          i < 0 ? ((n = e), (e = e.left)) : (e = e.right);
        }
        return n;
      }),
      (t.prototype.prev = function (t) {
        var e = this._root,
          n = null;
        if (null !== t.left) {
          for (n = t.left; n.right; ) n = n.right;
          return n;
        }
        for (var r = this._comparator; e; ) {
          var i = r(t.key, e.key);
          if (0 === i) break;
          i < 0 ? (e = e.left) : ((n = e), (e = e.right));
        }
        return n;
      }),
      (t.prototype.clear = function () {
        return (this._root = null), (this._size = 0), this;
      }),
      (t.prototype.toList = function () {
        return (function (t) {
          var e = t,
            n = [],
            r = !1,
            i = new rd(null, null),
            o = i;
          for (; !r; ) e ? (n.push(e), (e = e.left)) : n.length > 0 ? (e = (e = o = o.next = n.pop()).right) : (r = !0);
          return (o.next = null), i.next;
        })(this._root);
      }),
      (t.prototype.load = function (t, e, n) {
        void 0 === e && (e = []), void 0 === n && (n = !1);
        var r = t.length,
          i = this._comparator;
        if ((n && fd(t, e, 0, r - 1, i), null === this._root)) (this._root = cd(t, e, 0, r)), (this._size = r);
        else {
          var o = (function (t, e, n) {
            var r = new rd(null, null),
              i = r,
              o = t,
              a = e;
            for (; null !== o && null !== a; )
              n(o.key, a.key) < 0 ? ((i.next = o), (o = o.next)) : ((i.next = a), (a = a.next)), (i = i.next);
            null !== o ? (i.next = o) : null !== a && (i.next = a);
            return r.next;
          })(
            this.toList(),
            (function (t, e) {
              for (var n = new rd(null, null), r = n, i = 0; i < t.length; i++) r = r.next = new rd(t[i], e[i]);
              return (r.next = null), n.next;
            })(t, e),
            i,
          );
          (r = this._size + r), (this._root = hd({ head: o }, 0, r));
        }
        return this;
      }),
      (t.prototype.isEmpty = function () {
        return null === this._root;
      }),
      Object.defineProperty(t.prototype, 'size', {
        get: function () {
          return this._size;
        },
        enumerable: !0,
        configurable: !0,
      }),
      Object.defineProperty(t.prototype, 'root', {
        get: function () {
          return this._root;
        },
        enumerable: !0,
        configurable: !0,
      }),
      (t.prototype.toString = function (t) {
        void 0 === t &&
          (t = function (t) {
            return String(t.key);
          });
        var e = [];
        return (
          ud(
            this._root,
            '',
            !0,
            function (t) {
              return e.push(t);
            },
            t,
          ),
          e.join('')
        );
      }),
      (t.prototype.update = function (t, e, n) {
        var r = this._comparator,
          i = sd(t, this._root, r),
          o = i.left,
          a = i.right;
        r(t, e) < 0 ? (a = ad(e, n, a, r)) : (o = ad(e, n, o, r)),
          (this._root = (function (t, e, n) {
            return null === e ? t : (null === t || ((e = od(t.key, e, n)).left = t), e);
          })(o, a, r));
      }),
      (t.prototype.split = function (t) {
        return sd(t, this._root, this._comparator);
      }),
      (t.prototype[Symbol.iterator] = function () {
        var t, e, n;
        return nd(this, function (r) {
          switch (r.label) {
            case 0:
              (t = this._root), (e = []), (n = !1), (r.label = 1);
            case 1:
              return n ? [3, 6] : null === t ? [3, 2] : (e.push(t), (t = t.left), [3, 5]);
            case 2:
              return 0 === e.length ? [3, 4] : [4, (t = e.pop())];
            case 3:
              return r.sent(), (t = t.right), [3, 5];
            case 4:
              (n = !0), (r.label = 5);
            case 5:
              return [3, 1];
            case 6:
              return [2];
          }
        });
      }),
      t
    );
  })();
  function cd(t, e, n, r) {
    var i = r - n;
    if (i > 0) {
      var o = n + Math.floor(i / 2),
        a = t[o],
        s = e[o],
        u = new rd(a, s);
      return (u.left = cd(t, e, n, o)), (u.right = cd(t, e, o + 1, r)), u;
    }
    return null;
  }
  function hd(t, e, n) {
    var r = n - e;
    if (r > 0) {
      var i = e + Math.floor(r / 2),
        o = hd(t, e, i),
        a = t.head;
      return (a.left = o), (t.head = t.head.next), (a.right = hd(t, i + 1, n)), a;
    }
    return null;
  }
  function fd(t, e, n, r, i) {
    if (!(n >= r)) {
      for (var o = t[(n + r) >> 1], a = n - 1, s = r + 1; ; ) {
        do {
          a++;
        } while (i(t[a], o) < 0);
        do {
          s--;
        } while (i(t[s], o) > 0);
        if (a >= s) break;
        var u = t[a];
        (t[a] = t[s]), (t[s] = u), (u = e[a]), (e[a] = e[s]), (e[s] = u);
      }
      fd(t, e, n, s, i), fd(t, e, s + 1, r, i);
    }
  }
  function pd(t, e) {
    if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function');
  }
  function gd(t, e) {
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      (r.enumerable = r.enumerable || !1),
        (r.configurable = !0),
        'value' in r && (r.writable = !0),
        Object.defineProperty(t, r.key, r);
    }
  }
  function yd(t, e, n) {
    return e && gd(t.prototype, e), n && gd(t, n), t;
  }
  var vd = function (t, e) {
      return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y;
    },
    dd = function (t, e) {
      if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null;
      var n = t.ll.x < e.ll.x ? e.ll.x : t.ll.x,
        r = t.ur.x < e.ur.x ? t.ur.x : e.ur.x;
      return { ll: { x: n, y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y }, ur: { x: r, y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y } };
    },
    md = Number.EPSILON;
  void 0 === md && (md = Math.pow(2, -52));
  var _d = md * md,
    bd = function (t, e) {
      if (-md < t && t < md && -md < e && e < md) return 0;
      var n = t - e;
      return n * n < _d * t * e ? 0 : t < e ? -1 : 1;
    },
    xd = (function () {
      function t() {
        pd(this, t), this.reset();
      }
      return (
        yd(t, [
          {
            key: 'reset',
            value: function () {
              (this.xRounder = new Ed()), (this.yRounder = new Ed());
            },
          },
          {
            key: 'round',
            value: function (t, e) {
              return { x: this.xRounder.round(t), y: this.yRounder.round(e) };
            },
          },
        ]),
        t
      );
    })(),
    Ed = (function () {
      function t() {
        pd(this, t), (this.tree = new ld()), this.round(0);
      }
      return (
        yd(t, [
          {
            key: 'round',
            value: function (t) {
              var e = this.tree.add(t),
                n = this.tree.prev(e);
              if (null !== n && 0 === bd(e.key, n.key)) return this.tree.remove(t), n.key;
              var r = this.tree.next(e);
              return null !== r && 0 === bd(e.key, r.key) ? (this.tree.remove(t), r.key) : t;
            },
          },
        ]),
        t
      );
    })(),
    wd = new xd(),
    kd = function (t, e) {
      return t.x * e.y - t.y * e.x;
    },
    Sd = function (t, e) {
      return t.x * e.x + t.y * e.y;
    },
    Id = function (t, e, n) {
      var r = { x: e.x - t.x, y: e.y - t.y },
        i = { x: n.x - t.x, y: n.y - t.y },
        o = kd(r, i);
      return bd(o, 0);
    },
    Pd = function (t) {
      return Math.sqrt(Sd(t, t));
    },
    Nd = function (t, e, n) {
      var r = { x: e.x - t.x, y: e.y - t.y },
        i = { x: n.x - t.x, y: n.y - t.y };
      return Sd(i, r) / Pd(i) / Pd(r);
    },
    Md = function (t, e, n) {
      return 0 === e.y ? null : { x: t.x + (e.x / e.y) * (n - t.y), y: n };
    },
    Od = function (t, e, n) {
      return 0 === e.x ? null : { x: n, y: t.y + (e.y / e.x) * (n - t.x) };
    },
    Ld = (function () {
      function t(e, n) {
        pd(this, t),
          void 0 === e.events ? (e.events = [this]) : e.events.push(this),
          (this.point = e),
          (this.isLeft = n);
      }
      return (
        yd(t, null, [
          {
            key: 'compare',
            value: function (e, n) {
              var r = t.comparePoints(e.point, n.point);
              return 0 !== r
                ? r
                : (e.point !== n.point && e.link(n),
                  e.isLeft !== n.isLeft ? (e.isLeft ? 1 : -1) : Cd.compare(e.segment, n.segment));
            },
          },
          {
            key: 'comparePoints',
            value: function (t, e) {
              return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0;
            },
          },
        ]),
        yd(t, [
          {
            key: 'link',
            value: function (t) {
              if (t.point === this.point) throw new Error('Tried to link already linked events');
              for (var e = t.point.events, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                this.point.events.push(i), (i.point = this.point);
              }
              this.checkForConsuming();
            },
          },
          {
            key: 'checkForConsuming',
            value: function () {
              for (var t = this.point.events.length, e = 0; e < t; e++) {
                var n = this.point.events[e];
                if (void 0 === n.segment.consumedBy)
                  for (var r = e + 1; r < t; r++) {
                    var i = this.point.events[r];
                    void 0 === i.consumedBy &&
                      n.otherSE.point.events === i.otherSE.point.events &&
                      n.segment.consume(i.segment);
                  }
              }
            },
          },
          {
            key: 'getAvailableLinkedEvents',
            value: function () {
              for (var t = [], e = 0, n = this.point.events.length; e < n; e++) {
                var r = this.point.events[e];
                r !== this && !r.segment.ringOut && r.segment.isInResult() && t.push(r);
              }
              return t;
            },
          },
          {
            key: 'getLeftmostComparator',
            value: function (t) {
              var e = this,
                n = new Map(),
                r = function (r) {
                  var i,
                    o,
                    a,
                    s,
                    u,
                    l = r.otherSE;
                  n.set(r, {
                    sine:
                      ((i = e.point),
                      (o = t.point),
                      (a = l.point),
                      (s = { x: o.x - i.x, y: o.y - i.y }),
                      (u = { x: a.x - i.x, y: a.y - i.y }),
                      kd(u, s) / Pd(u) / Pd(s)),
                    cosine: Nd(e.point, t.point, l.point),
                  });
                };
              return function (t, e) {
                n.has(t) || r(t), n.has(e) || r(e);
                var i = n.get(t),
                  o = i.sine,
                  a = i.cosine,
                  s = n.get(e),
                  u = s.sine,
                  l = s.cosine;
                return o >= 0 && u >= 0
                  ? a < l
                    ? 1
                    : a > l
                    ? -1
                    : 0
                  : o < 0 && u < 0
                  ? a < l
                    ? -1
                    : a > l
                    ? 1
                    : 0
                  : u < o
                  ? -1
                  : u > o
                  ? 1
                  : 0;
              };
            },
          },
        ]),
        t
      );
    })(),
    Rd = 0,
    Cd = (function () {
      function t(e, n, r, i) {
        pd(this, t),
          (this.id = ++Rd),
          (this.leftSE = e),
          (e.segment = this),
          (e.otherSE = n),
          (this.rightSE = n),
          (n.segment = this),
          (n.otherSE = e),
          (this.rings = r),
          (this.windings = i);
      }
      return (
        yd(t, null, [
          {
            key: 'compare',
            value: function (t, e) {
              var n = t.leftSE.point.x,
                r = e.leftSE.point.x,
                i = t.rightSE.point.x,
                o = e.rightSE.point.x;
              if (o < n) return 1;
              if (i < r) return -1;
              var a = t.leftSE.point.y,
                s = e.leftSE.point.y,
                u = t.rightSE.point.y,
                l = e.rightSE.point.y;
              if (n < r) {
                if (s < a && s < u) return 1;
                if (s > a && s > u) return -1;
                var c = t.comparePoint(e.leftSE.point);
                if (c < 0) return 1;
                if (c > 0) return -1;
                var h = e.comparePoint(t.rightSE.point);
                return 0 !== h ? h : -1;
              }
              if (n > r) {
                if (a < s && a < l) return -1;
                if (a > s && a > l) return 1;
                var f = e.comparePoint(t.leftSE.point);
                if (0 !== f) return f;
                var p = t.comparePoint(e.rightSE.point);
                return p < 0 ? 1 : p > 0 ? -1 : 1;
              }
              if (a < s) return -1;
              if (a > s) return 1;
              if (i < o) {
                var g = e.comparePoint(t.rightSE.point);
                if (0 !== g) return g;
              }
              if (i > o) {
                var y = t.comparePoint(e.rightSE.point);
                if (y < 0) return 1;
                if (y > 0) return -1;
              }
              if (i !== o) {
                var v = u - a,
                  d = i - n,
                  m = l - s,
                  _ = o - r;
                if (v > d && m < _) return 1;
                if (v < d && m > _) return -1;
              }
              return i > o ? 1 : i < o || u < l ? -1 : u > l ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0;
            },
          },
        ]),
        yd(
          t,
          [
            {
              key: 'replaceRightSE',
              value: function (t) {
                (this.rightSE = t),
                  (this.rightSE.segment = this),
                  (this.rightSE.otherSE = this.leftSE),
                  (this.leftSE.otherSE = this.rightSE);
              },
            },
            {
              key: 'bbox',
              value: function () {
                var t = this.leftSE.point.y,
                  e = this.rightSE.point.y;
                return {
                  ll: { x: this.leftSE.point.x, y: t < e ? t : e },
                  ur: { x: this.rightSE.point.x, y: t > e ? t : e },
                };
              },
            },
            {
              key: 'vector',
              value: function () {
                return { x: this.rightSE.point.x - this.leftSE.point.x, y: this.rightSE.point.y - this.leftSE.point.y };
              },
            },
            {
              key: 'isAnEndpoint',
              value: function (t) {
                return (
                  (t.x === this.leftSE.point.x && t.y === this.leftSE.point.y) ||
                  (t.x === this.rightSE.point.x && t.y === this.rightSE.point.y)
                );
              },
            },
            {
              key: 'comparePoint',
              value: function (t) {
                if (this.isAnEndpoint(t)) return 0;
                var e = this.leftSE.point,
                  n = this.rightSE.point,
                  r = this.vector();
                if (e.x === n.x) return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
                var i = (t.y - e.y) / r.y,
                  o = e.x + i * r.x;
                if (t.x === o) return 0;
                var a = (t.x - e.x) / r.x,
                  s = e.y + a * r.y;
                return t.y === s ? 0 : t.y < s ? -1 : 1;
              },
            },
            {
              key: 'getIntersection',
              value: function (t) {
                var e = this.bbox(),
                  n = t.bbox(),
                  r = dd(e, n);
                if (null === r) return null;
                var i = this.leftSE.point,
                  o = this.rightSE.point,
                  a = t.leftSE.point,
                  s = t.rightSE.point,
                  u = vd(e, a) && 0 === this.comparePoint(a),
                  l = vd(n, i) && 0 === t.comparePoint(i),
                  c = vd(e, s) && 0 === this.comparePoint(s),
                  h = vd(n, o) && 0 === t.comparePoint(o);
                if (l && u) return h && !c ? o : !h && c ? s : null;
                if (l) return c && i.x === s.x && i.y === s.y ? null : i;
                if (u) return h && o.x === a.x && o.y === a.y ? null : a;
                if (h && c) return null;
                if (h) return o;
                if (c) return s;
                var f = (function (t, e, n, r) {
                  if (0 === e.x) return Od(n, r, t.x);
                  if (0 === r.x) return Od(t, e, n.x);
                  if (0 === e.y) return Md(n, r, t.y);
                  if (0 === r.y) return Md(t, e, n.y);
                  var i = kd(e, r);
                  if (0 == i) return null;
                  var o = { x: n.x - t.x, y: n.y - t.y },
                    a = kd(o, e) / i,
                    s = kd(o, r) / i;
                  return { x: (t.x + s * e.x + (n.x + a * r.x)) / 2, y: (t.y + s * e.y + (n.y + a * r.y)) / 2 };
                })(i, this.vector(), a, t.vector());
                return null === f ? null : vd(r, f) ? wd.round(f.x, f.y) : null;
              },
            },
            {
              key: 'split',
              value: function (e) {
                var n = [],
                  r = void 0 !== e.events,
                  i = new Ld(e, !0),
                  o = new Ld(e, !1),
                  a = this.rightSE;
                this.replaceRightSE(o), n.push(o), n.push(i);
                var s = new t(i, a, this.rings.slice(), this.windings.slice());
                return (
                  Ld.comparePoints(s.leftSE.point, s.rightSE.point) > 0 && s.swapEvents(),
                  Ld.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(),
                  r && (i.checkForConsuming(), o.checkForConsuming()),
                  n
                );
              },
            },
            {
              key: 'swapEvents',
              value: function () {
                var t = this.rightSE;
                (this.rightSE = this.leftSE), (this.leftSE = t), (this.leftSE.isLeft = !0), (this.rightSE.isLeft = !1);
                for (var e = 0, n = this.windings.length; e < n; e++) this.windings[e] *= -1;
              },
            },
            {
              key: 'consume',
              value: function (e) {
                for (var n = this, r = e; n.consumedBy; ) n = n.consumedBy;
                for (; r.consumedBy; ) r = r.consumedBy;
                var i = t.compare(n, r);
                if (0 !== i) {
                  if (i > 0) {
                    var o = n;
                    (n = r), (r = o);
                  }
                  if (n.prev === r) {
                    var a = n;
                    (n = r), (r = a);
                  }
                  for (var s = 0, u = r.rings.length; s < u; s++) {
                    var l = r.rings[s],
                      c = r.windings[s],
                      h = n.rings.indexOf(l);
                    -1 === h ? (n.rings.push(l), n.windings.push(c)) : (n.windings[h] += c);
                  }
                  (r.rings = null),
                    (r.windings = null),
                    (r.consumedBy = n),
                    (r.leftSE.consumedBy = n.leftSE),
                    (r.rightSE.consumedBy = n.rightSE);
                }
              },
            },
            {
              key: 'prevInResult',
              value: function () {
                return (
                  void 0 !== this._prevInResult ||
                    (this.prev
                      ? this.prev.isInResult()
                        ? (this._prevInResult = this.prev)
                        : (this._prevInResult = this.prev.prevInResult())
                      : (this._prevInResult = null)),
                  this._prevInResult
                );
              },
            },
            {
              key: 'beforeState',
              value: function () {
                if (void 0 !== this._beforeState) return this._beforeState;
                if (this.prev) {
                  var t = this.prev.consumedBy || this.prev;
                  this._beforeState = t.afterState();
                } else this._beforeState = { rings: [], windings: [], multiPolys: [] };
                return this._beforeState;
              },
            },
            {
              key: 'afterState',
              value: function () {
                if (void 0 !== this._afterState) return this._afterState;
                var t = this.beforeState();
                this._afterState = { rings: t.rings.slice(0), windings: t.windings.slice(0), multiPolys: [] };
                for (
                  var e = this._afterState.rings,
                    n = this._afterState.windings,
                    r = this._afterState.multiPolys,
                    i = 0,
                    o = this.rings.length;
                  i < o;
                  i++
                ) {
                  var a = this.rings[i],
                    s = this.windings[i],
                    u = e.indexOf(a);
                  -1 === u ? (e.push(a), n.push(s)) : (n[u] += s);
                }
                for (var l = [], c = [], h = 0, f = e.length; h < f; h++)
                  if (0 !== n[h]) {
                    var p = e[h],
                      g = p.poly;
                    if (-1 === c.indexOf(g))
                      if (p.isExterior) l.push(g);
                      else {
                        -1 === c.indexOf(g) && c.push(g);
                        var y = l.indexOf(p.poly);
                        -1 !== y && l.splice(y, 1);
                      }
                  }
                for (var v = 0, d = l.length; v < d; v++) {
                  var m = l[v].multiPoly;
                  -1 === r.indexOf(m) && r.push(m);
                }
                return this._afterState;
              },
            },
            {
              key: 'isInResult',
              value: function () {
                if (this.consumedBy) return !1;
                if (void 0 !== this._isInResult) return this._isInResult;
                var t = this.beforeState().multiPolys,
                  e = this.afterState().multiPolys;
                switch (zd.type) {
                  case 'union':
                    var n = 0 === t.length,
                      r = 0 === e.length;
                    this._isInResult = n !== r;
                    break;
                  case 'intersection':
                    var i, o;
                    t.length < e.length ? ((i = t.length), (o = e.length)) : ((i = e.length), (o = t.length)),
                      (this._isInResult = o === zd.numMultiPolys && i < o);
                    break;
                  case 'xor':
                    var a = Math.abs(t.length - e.length);
                    this._isInResult = a % 2 == 1;
                    break;
                  case 'difference':
                    var s = function (t) {
                      return 1 === t.length && t[0].isSubject;
                    };
                    this._isInResult = s(t) !== s(e);
                    break;
                  default:
                    throw new Error('Unrecognized operation type found '.concat(zd.type));
                }
                return this._isInResult;
              },
            },
          ],
          [
            {
              key: 'fromRing',
              value: function (e, n, r) {
                var i,
                  o,
                  a,
                  s = Ld.comparePoints(e, n);
                if (s < 0) (i = e), (o = n), (a = 1);
                else {
                  if (!(s > 0))
                    throw new Error('Tried to create degenerate segment at ['.concat(e.x, ', ').concat(e.y, ']'));
                  (i = n), (o = e), (a = -1);
                }
                return new t(new Ld(i, !0), new Ld(o, !1), [r], [a]);
              },
            },
          ],
        ),
        t
      );
    })(),
    Td = (function () {
      function t(e, n, r) {
        if ((pd(this, t), !Array.isArray(e) || 0 === e.length))
          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        if (
          ((this.poly = n),
          (this.isExterior = r),
          (this.segments = []),
          'number' != typeof e[0][0] || 'number' != typeof e[0][1])
        )
          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        var i = wd.round(e[0][0], e[0][1]);
        this.bbox = { ll: { x: i.x, y: i.y }, ur: { x: i.x, y: i.y } };
        for (var o = i, a = 1, s = e.length; a < s; a++) {
          if ('number' != typeof e[a][0] || 'number' != typeof e[a][1])
            throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
          var u = wd.round(e[a][0], e[a][1]);
          (u.x === o.x && u.y === o.y) ||
            (this.segments.push(Cd.fromRing(o, u, this)),
            u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x),
            u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y),
            u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x),
            u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y),
            (o = u));
        }
        (i.x === o.x && i.y === o.y) || this.segments.push(Cd.fromRing(o, i, this));
      }
      return (
        yd(t, [
          {
            key: 'getSweepEvents',
            value: function () {
              for (var t = [], e = 0, n = this.segments.length; e < n; e++) {
                var r = this.segments[e];
                t.push(r.leftSE), t.push(r.rightSE);
              }
              return t;
            },
          },
        ]),
        t
      );
    })(),
    Ad = (function () {
      function t(e, n) {
        if ((pd(this, t), !Array.isArray(e))) throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        (this.exteriorRing = new Td(e[0], this, !0)),
          (this.bbox = {
            ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
            ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y },
          }),
          (this.interiorRings = []);
        for (var r = 1, i = e.length; r < i; r++) {
          var o = new Td(e[r], this, !1);
          o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x),
            o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y),
            o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x),
            o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y),
            this.interiorRings.push(o);
        }
        this.multiPoly = n;
      }
      return (
        yd(t, [
          {
            key: 'getSweepEvents',
            value: function () {
              for (var t = this.exteriorRing.getSweepEvents(), e = 0, n = this.interiorRings.length; e < n; e++)
                for (var r = this.interiorRings[e].getSweepEvents(), i = 0, o = r.length; i < o; i++) t.push(r[i]);
              return t;
            },
          },
        ]),
        t
      );
    })(),
    Dd = (function () {
      function t(e, n) {
        if ((pd(this, t), !Array.isArray(e))) throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
        try {
          'number' == typeof e[0][0][0] && (e = [e]);
        } catch (t) {}
        (this.polys = []),
          (this.bbox = {
            ll: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY },
            ur: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY },
          });
        for (var r = 0, i = e.length; r < i; r++) {
          var o = new Ad(e[r], this);
          o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x),
            o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y),
            o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x),
            o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y),
            this.polys.push(o);
        }
        this.isSubject = n;
      }
      return (
        yd(t, [
          {
            key: 'getSweepEvents',
            value: function () {
              for (var t = [], e = 0, n = this.polys.length; e < n; e++)
                for (var r = this.polys[e].getSweepEvents(), i = 0, o = r.length; i < o; i++) t.push(r[i]);
              return t;
            },
          },
        ]),
        t
      );
    })(),
    jd = (function () {
      function t(e) {
        pd(this, t), (this.events = e);
        for (var n = 0, r = e.length; n < r; n++) e[n].segment.ringOut = this;
        this.poly = null;
      }
      return (
        yd(t, null, [
          {
            key: 'factory',
            value: function (e) {
              for (var n = [], r = 0, i = e.length; r < i; r++) {
                var o = e[r];
                if (o.isInResult() && !o.ringOut) {
                  for (
                    var a = null, s = o.leftSE, u = o.rightSE, l = [s], c = s.point, h = [];
                    (a = s), (s = u), l.push(s), s.point !== c;

                  )
                    for (;;) {
                      var f = s.getAvailableLinkedEvents();
                      if (0 === f.length) {
                        var p = l[0].point,
                          g = l[l.length - 1].point;
                        throw new Error(
                          'Unable to complete output ring starting at ['.concat(p.x, ',') +
                            ' '.concat(p.y, ']. Last matching segment found ends at') +
                            ' ['.concat(g.x, ', ').concat(g.y, '].'),
                        );
                      }
                      if (1 === f.length) {
                        u = f[0].otherSE;
                        break;
                      }
                      for (var y = null, v = 0, d = h.length; v < d; v++)
                        if (h[v].point === s.point) {
                          y = v;
                          break;
                        }
                      if (null === y) {
                        h.push({ index: l.length, point: s.point });
                        var m = s.getLeftmostComparator(a);
                        u = f.sort(m)[0].otherSE;
                        break;
                      }
                      var _ = h.splice(y)[0],
                        b = l.splice(_.index);
                      b.unshift(b[0].otherSE), n.push(new t(b.reverse()));
                    }
                  n.push(new t(l));
                }
              }
              return n;
            },
          },
        ]),
        yd(t, [
          {
            key: 'getGeom',
            value: function () {
              for (var t = this.events[0].point, e = [t], n = 1, r = this.events.length - 1; n < r; n++) {
                var i = this.events[n].point,
                  o = this.events[n + 1].point;
                0 !== Id(i, t, o) && (e.push(i), (t = i));
              }
              if (1 === e.length) return null;
              var a = e[0],
                s = e[1];
              0 === Id(a, t, s) && e.shift(), e.push(e[0]);
              for (
                var u = this.isExteriorRing() ? 1 : -1,
                  l = this.isExteriorRing() ? 0 : e.length - 1,
                  c = this.isExteriorRing() ? e.length : -1,
                  h = [],
                  f = l;
                f != c;
                f += u
              )
                h.push([e[f].x, e[f].y]);
              return h;
            },
          },
          {
            key: 'isExteriorRing',
            value: function () {
              if (void 0 === this._isExteriorRing) {
                var t = this.enclosingRing();
                this._isExteriorRing = !t || !t.isExteriorRing();
              }
              return this._isExteriorRing;
            },
          },
          {
            key: 'enclosingRing',
            value: function () {
              return (
                void 0 === this._enclosingRing && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing
              );
            },
          },
          {
            key: '_calcEnclosingRing',
            value: function () {
              for (var t = this.events[0], e = 1, n = this.events.length; e < n; e++) {
                var r = this.events[e];
                Ld.compare(t, r) > 0 && (t = r);
              }
              for (var i = t.segment.prevInResult(), o = i ? i.prevInResult() : null; ; ) {
                if (!i) return null;
                if (!o) return i.ringOut;
                if (o.ringOut !== i.ringOut)
                  return o.ringOut.enclosingRing() !== i.ringOut ? i.ringOut : i.ringOut.enclosingRing();
                (i = o.prevInResult()), (o = i ? i.prevInResult() : null);
              }
            },
          },
        ]),
        t
      );
    })(),
    Fd = (function () {
      function t(e) {
        pd(this, t), (this.exteriorRing = e), (e.poly = this), (this.interiorRings = []);
      }
      return (
        yd(t, [
          {
            key: 'addInterior',
            value: function (t) {
              this.interiorRings.push(t), (t.poly = this);
            },
          },
          {
            key: 'getGeom',
            value: function () {
              var t = [this.exteriorRing.getGeom()];
              if (null === t[0]) return null;
              for (var e = 0, n = this.interiorRings.length; e < n; e++) {
                var r = this.interiorRings[e].getGeom();
                null !== r && t.push(r);
              }
              return t;
            },
          },
        ]),
        t
      );
    })(),
    Bd = (function () {
      function t(e) {
        pd(this, t), (this.rings = e), (this.polys = this._composePolys(e));
      }
      return (
        yd(t, [
          {
            key: 'getGeom',
            value: function () {
              for (var t = [], e = 0, n = this.polys.length; e < n; e++) {
                var r = this.polys[e].getGeom();
                null !== r && t.push(r);
              }
              return t;
            },
          },
          {
            key: '_composePolys',
            value: function (t) {
              for (var e = [], n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                if (!i.poly)
                  if (i.isExteriorRing()) e.push(new Fd(i));
                  else {
                    var o = i.enclosingRing();
                    o.poly || e.push(new Fd(o)), o.poly.addInterior(i);
                  }
              }
              return e;
            },
          },
        ]),
        t
      );
    })(),
    qd = (function () {
      function t(e) {
        var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Cd.compare;
        pd(this, t), (this.queue = e), (this.tree = new ld(n)), (this.segments = []);
      }
      return (
        yd(t, [
          {
            key: 'process',
            value: function (t) {
              var e = t.segment,
                n = [];
              if (t.consumedBy) return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), n;
              var r = t.isLeft ? this.tree.insert(e) : this.tree.find(e);
              if (!r)
                throw new Error(
                  'Unable to find segment #'.concat(e.id, ' ') +
                    '['.concat(e.leftSE.point.x, ', ').concat(e.leftSE.point.y, '] -> ') +
                    '['.concat(e.rightSE.point.x, ', ').concat(e.rightSE.point.y, '] ') +
                    'in SweepLine tree. Please submit a bug report.',
                );
              for (var i = r, o = r, a = void 0, s = void 0; void 0 === a; )
                null === (i = this.tree.prev(i)) ? (a = null) : void 0 === i.key.consumedBy && (a = i.key);
              for (; void 0 === s; )
                null === (o = this.tree.next(o)) ? (s = null) : void 0 === o.key.consumedBy && (s = o.key);
              if (t.isLeft) {
                var u = null;
                if (a) {
                  var l = a.getIntersection(e);
                  if (null !== l && (e.isAnEndpoint(l) || (u = l), !a.isAnEndpoint(l)))
                    for (var c = this._splitSafely(a, l), h = 0, f = c.length; h < f; h++) n.push(c[h]);
                }
                var p = null;
                if (s) {
                  var g = s.getIntersection(e);
                  if (null !== g && (e.isAnEndpoint(g) || (p = g), !s.isAnEndpoint(g)))
                    for (var y = this._splitSafely(s, g), v = 0, d = y.length; v < d; v++) n.push(y[v]);
                }
                if (null !== u || null !== p) {
                  var m = null;
                  if (null === u) m = p;
                  else if (null === p) m = u;
                  else {
                    m = Ld.comparePoints(u, p) <= 0 ? u : p;
                  }
                  this.queue.remove(e.rightSE), n.push(e.rightSE);
                  for (var _ = e.split(m), b = 0, x = _.length; b < x; b++) n.push(_[b]);
                }
                n.length > 0 ? (this.tree.remove(e), n.push(t)) : (this.segments.push(e), (e.prev = a));
              } else {
                if (a && s) {
                  var E = a.getIntersection(s);
                  if (null !== E) {
                    if (!a.isAnEndpoint(E))
                      for (var w = this._splitSafely(a, E), k = 0, S = w.length; k < S; k++) n.push(w[k]);
                    if (!s.isAnEndpoint(E))
                      for (var I = this._splitSafely(s, E), P = 0, N = I.length; P < N; P++) n.push(I[P]);
                  }
                }
                this.tree.remove(e);
              }
              return n;
            },
          },
          {
            key: '_splitSafely',
            value: function (t, e) {
              this.tree.remove(t);
              var n = t.rightSE;
              this.queue.remove(n);
              var r = t.split(e);
              return r.push(n), void 0 === t.consumedBy && this.tree.insert(t), r;
            },
          },
        ]),
        t
      );
    })(),
    Vd = ('undefined' != typeof process && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE) || 1e6,
    Gd = ('undefined' != typeof process && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) || 1e6,
    Yd = (function () {
      function t() {
        pd(this, t);
      }
      return (
        yd(t, [
          {
            key: 'run',
            value: function (t, e, n) {
              (zd.type = t), wd.reset();
              for (var r = [new Dd(e, !0)], i = 0, o = n.length; i < o; i++) r.push(new Dd(n[i], !1));
              if (((zd.numMultiPolys = r.length), 'difference' === zd.type))
                for (var a = r[0], s = 1; s < r.length; ) null !== dd(r[s].bbox, a.bbox) ? s++ : r.splice(s, 1);
              if ('intersection' === zd.type)
                for (var u = 0, l = r.length; u < l; u++)
                  for (var c = r[u], h = u + 1, f = r.length; h < f; h++) if (null === dd(c.bbox, r[h].bbox)) return [];
              for (var p = new ld(Ld.compare), g = 0, y = r.length; g < y; g++)
                for (var v = r[g].getSweepEvents(), d = 0, m = v.length; d < m; d++)
                  if ((p.insert(v[d]), p.size > Vd))
                    throw new Error(
                      'Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.',
                    );
              for (var _ = new qd(p), b = p.size, x = p.pop(); x; ) {
                var E = x.key;
                if (p.size === b) {
                  var w = E.segment;
                  throw new Error(
                    'Unable to pop() '.concat(E.isLeft ? 'left' : 'right', ' SweepEvent ') +
                      '['.concat(E.point.x, ', ').concat(E.point.y, '] from segment #').concat(w.id, ' ') +
                      '['.concat(w.leftSE.point.x, ', ').concat(w.leftSE.point.y, '] -> ') +
                      '['.concat(w.rightSE.point.x, ', ').concat(w.rightSE.point.y, '] from queue. ') +
                      'Please file a bug report.',
                  );
                }
                if (p.size > Vd)
                  throw new Error(
                    'Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.',
                  );
                if (_.segments.length > Gd)
                  throw new Error(
                    'Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.',
                  );
                for (var k = _.process(E), S = 0, I = k.length; S < I; S++) {
                  var P = k[S];
                  void 0 === P.consumedBy && p.insert(P);
                }
                (b = p.size), (x = p.pop());
              }
              wd.reset();
              var N = jd.factory(_.segments);
              return new Bd(N).getGeom();
            },
          },
        ]),
        t
      );
    })(),
    zd = new Yd(),
    Ud = {
      union: function (t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
        return zd.run('union', t, n);
      },
      intersection: function (t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
        return zd.run('intersection', t, n);
      },
      xor: function (t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
        return zd.run('xor', t, n);
      },
      difference: function (t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
        return zd.run('difference', t, n);
      },
    },
    Xd = Object.defineProperty;
  function Wd(t) {
    var e = [];
    if (
      (jl(t, function (t) {
        e.push(t.coordinates);
      }),
      e.length < 2)
    )
      throw new Error('Must have at least two features');
    var n = t.features[0].properties || {},
      r = Ud.difference.apply(Ud, [e[0]].concat(s(e.slice(1))));
    return 0 === r.length ? null : 1 === r.length ? Cu(r[0], n) : qu(r, n);
  }
  !(function (t, e) {
    Xd(t, 'name', { value: e, configurable: !0 });
  })(Wd, 'difference');
  var Hd = Object.defineProperty;
  function Zd(t) {
    if (!t) throw new Error('geojson is required');
    var e = [];
    return (
      Bl(t, function (t) {
        e.push(t);
      }),
      ju(e)
    );
  }
  !(function (t, e) {
    Hd(t, 'name', { value: e, configurable: !0 });
  })(Zd, 'flatten');
  var Jd = Object.defineProperty;
  function $d(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.propertyName;
    ll(t, 'Polygon', 'dissolve');
    var r = [];
    if (!n)
      return Zd(
        qu(
          Ud.union.apply(
            null,
            t.features.map(function (t) {
              return t.geometry.coordinates;
            }),
          ),
        ),
      );
    var i = {};
    Tl(t, function (t) {
      t.properties &&
        (Object.prototype.hasOwnProperty.call(i, t.properties[n]) || (i[t.properties[n]] = []),
        i[t.properties[n]].push(t));
    });
    for (var o = Object.keys(i), a = 0; a < o.length; a++) {
      var s = qu(
        Ud.union.apply(
          null,
          i[o[a]].map(function (t) {
            return t.geometry.coordinates;
          }),
        ),
      );
      s && s.properties && ((s.properties[n] = o[a]), r.push(s));
    }
    return Zd(ju(r));
  }
  !(function (t, e) {
    Jd(t, 'name', { value: e, configurable: !0 });
  })($d, 'dissolve');
  var Qd = Object.defineProperty,
    Kd = function (t, e) {
      return Qd(t, 'name', { value: e, configurable: !0 });
    };
  function tm(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2,
      r = il(t),
      i = il(e),
      o = r[0] - i[0],
      a = r[1] - i[1];
    return 1 === n ? Math.abs(o) + Math.abs(a) : Math.pow(Math.pow(o, n) + Math.pow(a, n), 1 / n);
  }
  function em(t, e) {
    var n,
      r,
      i = (e = e || {}).threshold || 1e4,
      o = e.p || 2,
      a = null != (n = e.binary) && n,
      s = e.alpha || -1,
      u = null != (r = e.standardization) && r,
      l = [];
    Tl(t, function (t) {
      l.push(Ug(t));
    });
    for (var c = [], h = 0; h < l.length; h++) c[h] = [];
    for (var f = 0; f < l.length; f++)
      for (var p = f; p < l.length; p++) {
        f === p && (c[f][p] = 0);
        var g = tm(l[f], l[p], o);
        (c[f][p] = g), (c[p][f] = g);
      }
    for (var y = 0; y < l.length; y++)
      for (var v = 0; v < l.length; v++) {
        var d = c[y][v];
        0 !== d && (c[y][v] = a ? (d <= i ? 1 : 0) : d <= i ? Math.pow(d, s) : 0);
      }
    if (u)
      for (var m = 0; m < l.length; m++)
        for (
          var _ = c[m].reduce(function (t, e) {
              return t + e;
            }, 0),
            b = 0;
          b < l.length;
          b++
        )
          c[m][b] = c[m][b] / _;
    return c;
  }
  Kd(tm, 'pNormDistance'), Kd(em, 'distanceWeight');
  var nm = Object.defineProperty,
    rm = function (t, e) {
      return nm(t, 'name', { value: e, configurable: !0 });
    };
  function im(t, e, n) {
    var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
      i = e < 0,
      o = Zu(Math.abs(e), r.units, 'meters');
    i && (o = -Math.abs(o));
    var a = il(t),
      s = om(a, o, n);
    return (s[0] += s[0] - a[0] > 180 ? -360 : a[0] - s[0] > 180 ? 360 : 0), Lu(s, r.properties);
  }
  function om(t, e, n, r) {
    var i = e / (r = void 0 === r ? Iu : Number(r)),
      o = (t[0] * Math.PI) / 180,
      a = Hu(t[1]),
      s = Hu(n),
      u = i * Math.cos(s),
      l = a + u;
    Math.abs(l) > Math.PI / 2 && (l = l > 0 ? Math.PI - l : -Math.PI - l);
    var c = Math.log(Math.tan(l / 2 + Math.PI / 4) / Math.tan(a / 2 + Math.PI / 4)),
      h = Math.abs(c) > 1e-11 ? u / c : Math.cos(a);
    return [(((180 * (o + (i * Math.sin(s)) / h)) / Math.PI + 540) % 360) - 180, (180 * l) / Math.PI];
  }
  rm(im, 'rhumbDestination'), rm(om, 'calculateRhumbDestination');
  var am = Object.defineProperty,
    sm = function (t, e) {
      return am(t, 'name', { value: e, configurable: !0 });
    };
  function um(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      r = il(t),
      i = il(e);
    return (i[0] += i[0] - r[0] > 180 ? -360 : r[0] - i[0] > 180 ? 360 : 0), Zu(lm(r, i), 'meters', n.units);
  }
  function lm(t, e, n) {
    var r = (n = void 0 === n ? Iu : Number(n)),
      i = (t[1] * Math.PI) / 180,
      o = (e[1] * Math.PI) / 180,
      a = o - i,
      s = (Math.abs(e[0] - t[0]) * Math.PI) / 180;
    s > Math.PI && (s -= 2 * Math.PI);
    var u = Math.log(Math.tan(o / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)),
      l = Math.abs(u) > 1e-11 ? a / u : Math.cos(i);
    return Math.sqrt(a * a + l * l * s * s) * r;
  }
  sm(um, 'rhumbDistance'), sm(lm, 'calculateRhumbDistance');
  var cm = Object.defineProperty;
  function hm(t, e, n) {
    if (!Qu((n = n || {}))) throw new Error('options is invalid');
    var r = n.pivot,
      i = n.mutate;
    if (!t) throw new Error('geojson is required');
    if (null == e || isNaN(e)) throw new Error('angle is required');
    return (
      0 === e ||
        (r || (r = Ug(t)),
        (!1 !== i && void 0 !== i) || (t = Ry(t)),
        Ol(t, function (t) {
          var n = kl(r, t) + e,
            i = um(r, t),
            o = ol(im(r, i, n));
          (t[0] = o[0]), (t[1] = o[1]);
        })),
      t
    );
  }
  !(function (t, e) {
    cm(t, 'name', { value: e, configurable: !0 });
  })(hm, 'transformRotate');
  var fm = Object.defineProperty,
    pm = function (t, e) {
      return fm(t, 'name', { value: e, configurable: !0 });
    };
  function gm(t, e, n, r) {
    var i = (r = r || {}).steps || 64,
      o = r.units || 'kilometers',
      a = r.angle || 0,
      s = r.pivot || t,
      u = r.properties || {};
    if (!t) throw new Error('center is required');
    if (!e) throw new Error('xSemiAxis is required');
    if (!n) throw new Error('ySemiAxis is required');
    if (!Qu(r)) throw new Error('options must be an object');
    if (!$u(i)) throw new Error('steps must be a number');
    if (!$u(a)) throw new Error('angle must be a number');
    var l = il(t);
    if ('degrees' !== o) {
      var c = im(t, e, 90, { units: o }),
        h = im(t, n, 0, { units: o });
      (e = il(c)[0] - l[0]), (n = il(h)[1] - l[1]);
    }
    for (var f = [], p = 0; p < i; p += 1) {
      var g = (-360 * p) / i,
        y = (e * n) / Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2) * Math.pow(ym(g), 2)),
        v = (e * n) / Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) / Math.pow(ym(g), 2));
      if ((g < -90 && g >= -270 && (y = -y), g < -180 && g >= -360 && (v = -v), 'degrees' === o)) {
        var d = Hu(a),
          m = y * Math.cos(d) + v * Math.sin(d),
          _ = v * Math.cos(d) - y * Math.sin(d);
        (y = m), (v = _);
      }
      f.push([y + l[0], v + l[1]]);
    }
    return f.push(f[0]), 'degrees' === o ? Cu([f], u) : hm(Cu([f], u), a, { pivot: s });
  }
  function ym(t) {
    var e = (t * Math.PI) / 180;
    return Math.tan(e);
  }
  pm(gm, 'ellipse'), pm(ym, 'getTanDeg');
  var vm = Object.defineProperty;
  function dm(t) {
    return pc(rc(t));
  }
  !(function (t, e) {
    vm(t, 'name', { value: e, configurable: !0 });
  })(dm, 'envelope');
  var mm = Object.defineProperty;
  function _m(t) {
    var e = [];
    return (
      'FeatureCollection' === t.type
        ? Tl(t, function (t) {
            Ol(t, function (n) {
              e.push(Lu(n, t.properties));
            });
          })
        : 'Feature' === t.type
        ? Ol(t, function (n) {
            e.push(Lu(n, t.properties));
          })
        : Ol(t, function (t) {
            e.push(Lu(t));
          }),
      ju(e)
    );
  }
  !(function (t, e) {
    mm(t, 'name', { value: e, configurable: !0 });
  })(_m, 'explode');
  var bm = Object.defineProperty;
  function xm(t, e) {
    var n;
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var r = null != (n = e.mutate) && n;
    if (!t) throw new Error('geojson is required');
    return (
      (!1 !== r && void 0 !== r) || (t = Ry(t)),
      Ol(t, function (t) {
        var e = t[0],
          n = t[1];
        (t[0] = n), (t[1] = e);
      }),
      t
    );
  }
  !(function (t, e) {
    bm(t, 'name', { value: e, configurable: !0 });
  })(xm, 'flip');
  var Em = Object.defineProperty,
    wm = function (t, e) {
      return Em(t, 'name', { value: e, configurable: !0 });
    },
    km = Math.PI / 180,
    Sm = 180 / Math.PI,
    Im = wm(function (t, e) {
      (this.lon = t), (this.lat = e), (this.x = km * t), (this.y = km * e);
    }, 'Coord');
  (Im.prototype.view = function () {
    return String(this.lon).slice(0, 4) + ',' + String(this.lat).slice(0, 4);
  }),
    (Im.prototype.antipode = function () {
      var t = -1 * this.lat,
        e = this.lon < 0 ? 180 + this.lon : -1 * (180 - this.lon);
      return new Im(e, t);
    });
  var Pm = wm(function () {
    (this.coords = []), (this.length = 0);
  }, 'LineString');
  Pm.prototype.move_to = function (t) {
    this.length++, this.coords.push(t);
  };
  var Nm = wm(function (t) {
    (this.properties = t || {}), (this.geometries = []);
  }, 'Arc');
  (Nm.prototype.json = function () {
    if (this.geometries.length <= 0)
      return { geometry: { type: 'LineString', coordinates: null }, type: 'Feature', properties: this.properties };
    if (1 === this.geometries.length)
      return {
        geometry: { type: 'LineString', coordinates: this.geometries[0].coords },
        type: 'Feature',
        properties: this.properties,
      };
    for (var t = [], e = 0; e < this.geometries.length; e++) t.push(this.geometries[e].coords);
    return { geometry: { type: 'MultiLineString', coordinates: t }, type: 'Feature', properties: this.properties };
  }),
    (Nm.prototype.wkt = function () {
      for (
        var t = '',
          e = 'LINESTRING(',
          n = wm(function (t) {
            e += t[0] + ' ' + t[1] + ',';
          }, 'collect'),
          r = 0;
        r < this.geometries.length;
        r++
      ) {
        if (0 === this.geometries[r].coords.length) return 'LINESTRING(empty)';
        this.geometries[r].coords.forEach(n), (t += e.substring(0, e.length - 1) + ')');
      }
      return t;
    });
  var Mm = wm(function (t, e, n) {
    if (!t || void 0 === t.x || void 0 === t.y)
      throw new Error('GreatCircle constructor expects two args: start and end objects with x and y properties');
    if (!e || void 0 === e.x || void 0 === e.y)
      throw new Error('GreatCircle constructor expects two args: start and end objects with x and y properties');
    (this.start = new Im(t.x, t.y)), (this.end = new Im(e.x, e.y)), (this.properties = n || {});
    var r = this.start.x - this.end.x,
      i = this.start.y - this.end.y,
      o = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(r / 2), 2);
    if (((this.g = 2 * Math.asin(Math.sqrt(o))), this.g === Math.PI))
      throw new Error(
        'it appears ' +
          t.view() +
          ' and ' +
          e.view() +
          " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite",
      );
    if (isNaN(this.g)) throw new Error('could not calculate great circle between ' + t + ' and ' + e);
  }, 'GreatCircle');
  function Om(t, n, r) {
    if ('object' !== e((r = r || {}))) throw new Error('options is invalid');
    var i = r.properties,
      o = r.npoints,
      a = r.offset;
    return (
      (t = il(t)),
      (n = il(n)),
      (i = i || {}),
      (o = o || 100),
      (a = a || 10),
      new Mm({ x: t[0], y: t[1] }, { x: n[0], y: n[1] }, i).Arc(o, { offset: a }).json()
    );
  }
  (Mm.prototype.interpolate = function (t) {
    var e = Math.sin((1 - t) * this.g) / Math.sin(this.g),
      n = Math.sin(t * this.g) / Math.sin(this.g),
      r = e * Math.cos(this.start.y) * Math.cos(this.start.x) + n * Math.cos(this.end.y) * Math.cos(this.end.x),
      i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + n * Math.cos(this.end.y) * Math.sin(this.end.x),
      o = e * Math.sin(this.start.y) + n * Math.sin(this.end.y),
      a = Sm * Math.atan2(o, Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2)));
    return [Sm * Math.atan2(i, r), a];
  }),
    (Mm.prototype.Arc = function (t, e) {
      var n = [];
      if (!t || t <= 2) n.push([this.start.lon, this.start.lat]), n.push([this.end.lon, this.end.lat]);
      else
        for (var r = 1 / (t - 1), i = 0; i < t; ++i) {
          var o = r * i,
            a = this.interpolate(o);
          n.push(a);
        }
      for (
        var s = !1, u = 0, l = e && e.offset ? e.offset : 10, c = 180 - l, h = -180 + l, f = 360 - l, p = 1;
        p < n.length;
        ++p
      ) {
        var g = n[p - 1][0],
          y = n[p][0],
          v = Math.abs(y - g);
        v > f && ((y > c && g < h) || (g > c && y < h)) ? (s = !0) : v > u && (u = v);
      }
      var d = [];
      if (s && u < l) {
        var m = [];
        d.push(m);
        for (var _ = 0; _ < n.length; ++_) {
          var b = parseFloat(n[_][0]);
          if (_ > 0 && Math.abs(b - n[_ - 1][0]) > f) {
            var x = parseFloat(n[_ - 1][0]),
              E = parseFloat(n[_ - 1][1]),
              w = parseFloat(n[_][0]),
              k = parseFloat(n[_][1]);
            if (x > -180 && x < h && 180 === w && _ + 1 < n.length && n[_ - 1][0] > -180 && n[_ - 1][0] < h) {
              m.push([-180, n[_][1]]), _++, m.push([n[_][0], n[_][1]]);
              continue;
            }
            if (x > c && x < 180 && -180 === w && _ + 1 < n.length && n[_ - 1][0] > c && n[_ - 1][0] < 180) {
              m.push([180, n[_][1]]), _++, m.push([n[_][0], n[_][1]]);
              continue;
            }
            if (x < h && w > c) {
              var S = x;
              (x = w), (w = S);
              var I = E;
              (E = k), (k = I);
            }
            if ((x > c && w < h && (w += 360), x <= 180 && w >= 180 && x < w)) {
              var P = (180 - x) / (w - x),
                N = P * k + (1 - P) * E;
              m.push([n[_ - 1][0] > c ? 180 : -180, N]), (m = []).push([n[_ - 1][0] > c ? -180 : 180, N]), d.push(m);
            } else (m = []), d.push(m);
            m.push([b, n[_][1]]);
          } else m.push([n[_][0], n[_][1]]);
        }
      } else {
        var M = [];
        d.push(M);
        for (var O = 0; O < n.length; ++O) M.push([n[O][0], n[O][1]]);
      }
      for (var L = new Nm(this.properties), R = 0; R < d.length; ++R) {
        var C = new Pm();
        L.geometries.push(C);
        for (var T = d[R], A = 0; A < T.length; ++A) C.move_to(T[A]);
      }
      return L;
    }),
    wm(Om, 'greatCircle');
  /*!
   * Copyright (c) 2019, Dane Springmeyer
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *     * Redistributions of source code must retain the above copyright
   *       notice, this list of conditions and the following disclaimer.
   *     * Redistributions in binary form must reproduce the above copyright
   *       notice, this list of conditions and the following disclaimer in
   *       the documentation and/or other materials provided with the
   *       distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
   * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
   * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  var Lm = Object.defineProperty;
  function Rm(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = [];
    if (
      (jl(t, function (t) {
        n.push(t.coordinates);
      }),
      n.length < 2)
    )
      throw new Error('Must specify at least 2 geometries');
    var r = Ud.intersection.apply(Ud, [n[0]].concat(s(n.slice(1))));
    return 0 === r.length ? null : 1 === r.length ? Cu(r[0], e.properties) : qu(r, e.properties);
  }
  !(function (t, e) {
    Lm(t, 'name', { value: e, configurable: !0 });
  })(Rm, 'intersect');
  var Cm = Object.defineProperty,
    Tm = function (t, e) {
      return Cm(t, 'name', { value: e, configurable: !0 });
    };
  function Am(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      r = JSON.stringify(n.properties || {}),
      i = a(t, 4),
      o = i[0],
      s = i[1],
      u = i[2],
      l = i[3],
      c = (s + l) / 2,
      h = (o + u) / 2,
      f = ((2 * e) / _l([o, c], [u, c], n)) * (u - o),
      p = ((2 * e) / _l([h, s], [h, l], n)) * (l - s),
      g = f / 2,
      y = 2 * g,
      v = (Math.sqrt(3) / 2) * p,
      d = u - o,
      m = l - s,
      _ = (3 / 4) * y,
      b = v,
      x = (d - y) / (y - g / 2),
      E = Math.floor(x),
      w = (E * _ - g / 2 - d) / 2 - g / 2 + _ / 2,
      k = Math.floor((m - v) / v),
      S = (m - k * v) / 2,
      I = k * v - m > v / 2;
    I && (S -= v / 4);
    for (var P = [], N = [], M = 0; M < 6; M++) {
      var O = ((2 * Math.PI) / 6) * M;
      P.push(Math.cos(O)), N.push(Math.sin(O));
    }
    for (var L = [], R = 0; R <= E; R++)
      for (var C = 0; C <= k; C++) {
        var T = R % 2 == 1;
        if ((0 !== C || !T) && (0 !== C || !I)) {
          var A = R * _ + o - w,
            D = C * b + s + S;
          if ((T && (D -= v / 2), !0 === n.triangles))
            jm([A, D], f / 2, p / 2, JSON.parse(r), P, N).forEach(function (t) {
              n.mask ? Rm(ju([n.mask, t])) && L.push(t) : L.push(t);
            });
          else {
            var j = Dm([A, D], f / 2, p / 2, JSON.parse(r), P, N);
            n.mask ? Rm(ju([n.mask, j])) && L.push(j) : L.push(j);
          }
        }
      }
    return ju(L);
  }
  function Dm(t, e, n, r, i, o) {
    for (var a = [], s = 0; s < 6; s++) {
      var u = t[0] + e * i[s],
        l = t[1] + n * o[s];
      a.push([u, l]);
    }
    return a.push(a[0].slice()), Cu([a], r);
  }
  function jm(t, e, n, r, i, o) {
    for (var a = [], s = 0; s < 6; s++) {
      var u = [];
      u.push(t),
        u.push([t[0] + e * i[s], t[1] + n * o[s]]),
        u.push([t[0] + e * i[(s + 1) % 6], t[1] + n * o[(s + 1) % 6]]),
        u.push(t),
        a.push(Cu([u], r));
    }
    return a;
  }
  Tm(Am, 'hexGrid'), Tm(Dm, 'hexagon'), Tm(jm, 'hexTriangles');
  var Fm = Object.defineProperty;
  function Bm(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    n.mask && !n.units && (n.units = 'kilometers');
    for (
      var r = [],
        i = t[0],
        o = t[1],
        a = t[2],
        s = t[3],
        u = (e / _l([i, o], [a, o], n)) * (a - i),
        l = (e / _l([i, o], [i, s], n)) * (s - o),
        c = a - i,
        h = s - o,
        f = Math.floor(c / u),
        p = (h - Math.floor(h / l) * l) / 2,
        g = i + (c - f * u) / 2;
      g <= a;

    ) {
      for (var y = o + p; y <= s; ) {
        var v = Lu([g, y], n.properties);
        n.mask ? Jf(v, n.mask) && r.push(v) : r.push(v), (y += l);
      }
      g += u;
    }
    return ju(r);
  }
  !(function (t, e) {
    Fm(t, 'name', { value: e, configurable: !0 });
  })(Bm, 'pointGrid');
  var qm = Object.defineProperty;
  function Vm(t, e, n) {
    for (
      var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
        i = [],
        o = t[0],
        a = t[1],
        s = t[2],
        u = t[3],
        l = s - o,
        c = Zu(e, r.units, 'degrees'),
        h = u - a,
        f = Zu(n, r.units, 'degrees'),
        p = Math.floor(Math.abs(l) / c),
        g = Math.floor(Math.abs(h) / f),
        y = (h - g * f) / 2,
        v = o + (l - p * c) / 2,
        d = 0;
      d < p;
      d++
    ) {
      for (var m = a + y, _ = 0; _ < g; _++) {
        var b = Cu(
          [
            [
              [v, m],
              [v, m + f],
              [v + c, m + f],
              [v + c, m],
              [v, m],
            ],
          ],
          r.properties,
        );
        r.mask ? Gh(r.mask, b) && i.push(b) : i.push(b), (m += f);
      }
      v += c;
    }
    return ju(i);
  }
  !(function (t, e) {
    qm(t, 'name', { value: e, configurable: !0 });
  })(Vm, 'rectangleGrid');
  var Gm = Object.defineProperty;
  function Ym(t, e) {
    return Vm(t, e, e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {});
  }
  !(function (t, e) {
    Gm(t, 'name', { value: e, configurable: !0 });
  })(Ym, 'squareGrid');
  var zm = Object.defineProperty;
  function Um(t, e) {
    for (
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
        r = [],
        i = (e / _l([t[0], t[1]], [t[2], t[1]], n)) * (t[2] - t[0]),
        o = (e / _l([t[0], t[1]], [t[0], t[3]], n)) * (t[3] - t[1]),
        a = 0,
        s = t[0];
      s <= t[2];

    ) {
      for (var u = 0, l = t[1]; l <= t[3]; ) {
        var c = null,
          h = null;
        a % 2 == 0 && u % 2 == 0
          ? ((c = Cu(
              [
                [
                  [s, l],
                  [s, l + o],
                  [s + i, l],
                  [s, l],
                ],
              ],
              n.properties,
            )),
            (h = Cu(
              [
                [
                  [s, l + o],
                  [s + i, l + o],
                  [s + i, l],
                  [s, l + o],
                ],
              ],
              n.properties,
            )))
          : a % 2 == 0 && u % 2 == 1
          ? ((c = Cu(
              [
                [
                  [s, l],
                  [s + i, l + o],
                  [s + i, l],
                  [s, l],
                ],
              ],
              n.properties,
            )),
            (h = Cu(
              [
                [
                  [s, l],
                  [s, l + o],
                  [s + i, l + o],
                  [s, l],
                ],
              ],
              n.properties,
            )))
          : u % 2 == 0 && a % 2 == 1
          ? ((c = Cu(
              [
                [
                  [s, l],
                  [s, l + o],
                  [s + i, l + o],
                  [s, l],
                ],
              ],
              n.properties,
            )),
            (h = Cu(
              [
                [
                  [s, l],
                  [s + i, l + o],
                  [s + i, l],
                  [s, l],
                ],
              ],
              n.properties,
            )))
          : u % 2 == 1 &&
            a % 2 == 1 &&
            ((c = Cu(
              [
                [
                  [s, l],
                  [s, l + o],
                  [s + i, l],
                  [s, l],
                ],
              ],
              n.properties,
            )),
            (h = Cu(
              [
                [
                  [s, l + o],
                  [s + i, l + o],
                  [s + i, l],
                  [s, l + o],
                ],
              ],
              n.properties,
            ))),
          n.mask ? (Rm(ju([n.mask, c])) && r.push(c), Rm(ju([n.mask, h])) && r.push(h)) : (r.push(c), r.push(h)),
          (l += o),
          u++;
      }
      a++, (s += i);
    }
    return ju(r);
  }
  !(function (t, e) {
    zm(t, 'name', { value: e, configurable: !0 });
  })(Um, 'triangleGrid');
  var Xm = Object.defineProperty;
  function Wm(t, n, r) {
    if ('object' !== e((r = r || {}))) throw new Error('options is invalid');
    var i = r.gridType,
      o = r.property,
      a = r.weight;
    if (!t) throw new Error('points is required');
    if ((ll(t, 'Point', 'input must contain Points'), !n)) throw new Error('cellSize is required');
    if (void 0 !== a && 'number' != typeof a) throw new Error('weight must be a number');
    (o = o || 'elevation'), (i = i || 'square'), (a = a || 1);
    var s,
      u = rc(t);
    switch (i) {
      case 'point':
      case 'points':
        s = Bm(u, n, r);
        break;
      case 'square':
      case 'squares':
        s = Ym(u, n, r);
        break;
      case 'hex':
      case 'hexes':
        s = Am(u, n, r);
        break;
      case 'triangle':
      case 'triangles':
        s = Um(u, n, r);
        break;
      default:
        throw new Error('invalid gridType');
    }
    var l = [];
    return (
      Tl(s, function (e) {
        var n = 0,
          s = 0;
        Tl(t, function (t) {
          var u,
            l = _l('point' === i ? e : Ug(e), t, r);
          if ((void 0 !== o && (u = t.properties[o]), void 0 === u && (u = t.geometry.coordinates[2]), void 0 === u))
            throw new Error('zValue is missing');
          0 === l && (n = u);
          var c = 1 / Math.pow(l, a);
          (s += c), (n += c * u);
        });
        var u = Ry(e);
        (u.properties[o] = n / s), l.push(u);
      }),
      ju(l)
    );
  }
  /*!
   * MarchingSquaresJS
   * version 1.3.3
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * @license GNU Affero General Public License.
   * Copyright (c) 2015-2019 Ronny Lorenz <ronny@tbi.univie.ac.at>
   */
  function Hm(t, e, n) {
    return t < e ? (n - t) / (e - t) : (t - n) / (t - e);
  }
  function Zm(t, e, n, r) {
    var i;
    return (
      n > r && ((i = n), (n = r), (r = i)),
      t < e ? (t < n ? (n - t) / (e - t) : (r - t) / (e - t)) : t > r ? (t - r) / (t - e) : (t - n) / (t - e)
    );
  }
  function Jm(t, e, n, r) {
    return t < e ? (n - t) / (e - t) : (t - r) / (t - e);
  }
  function $m(t, e, n, r) {
    return t < e ? (r - t) / (e - t) : (t - n) / (t - e);
  }
  function Qm() {
    (this.successCallback = null),
      (this.verbose = !1),
      (this.polygons = !1),
      (this.polygons_full = !1),
      (this.linearRing = !0),
      (this.noQuadTree = !1),
      (this.noFrame = !1);
  }
  function Km(t, e, n, r) {
    var i = [];
    return (
      t.polygons.forEach(function (t) {
        t.forEach(function (t) {
          (t[0] += e), (t[1] += n);
        }),
          r.linearRing && t.push(t[0]),
          i.push(t);
      }),
      i
    );
  }
  function t_(t, e, n, r) {
    return (
      0 === n
        ? ((t += 1), (e += r[0][1]))
        : 1 === n
        ? (t += r[0][0])
        : 2 === n
        ? (e += r[0][1])
        : 3 === n && ((t += r[0][0]), (e += 1)),
      [t, e]
    );
  }
  function e_(t, e, n) {
    return 0 === n ? t++ : 1 === n || (2 === n ? e++ : 3 === n && (t++, e++)), [t, e];
  }
  function n_(t, e, n, r, i) {
    var o = r,
      a = i,
      s = 0,
      u = 0;
    if (
      ((this.x = e),
      (this.y = n),
      (this.lowerBound = null),
      (this.upperBound = null),
      (this.childA = null),
      (this.childB = null),
      (this.childC = null),
      (this.childD = null),
      1 === r && 1 === i)
    )
      (this.lowerBound = Math.min(t[n][e], t[n][e + 1], t[n + 1][e + 1], t[n + 1][e])),
        (this.upperBound = Math.max(t[n][e], t[n][e + 1], t[n + 1][e + 1], t[n + 1][e]));
    else {
      if (r > 1) {
        for (; 0 !== o; ) (o >>= 1), s++;
        r === 1 << (s - 1) && s--, (o = 1 << (s - 1));
      }
      if (i > 1) {
        for (; 0 !== a; ) (a >>= 1), u++;
        i === 1 << (u - 1) && u--, (a = 1 << (u - 1));
      }
      (this.childA = new n_(t, e, n, o, a)),
        (this.lowerBound = this.childA.lowerBound),
        (this.upperBound = this.childA.upperBound),
        r - o > 0 &&
          ((this.childB = new n_(t, e + o, n, r - o, a)),
          (this.lowerBound = Math.min(this.lowerBound, this.childB.lowerBound)),
          (this.upperBound = Math.max(this.upperBound, this.childB.upperBound)),
          i - a > 0 &&
            ((this.childC = new n_(t, e + o, n + a, r - o, i - a)),
            (this.lowerBound = Math.min(this.lowerBound, this.childC.lowerBound)),
            (this.upperBound = Math.max(this.upperBound, this.childC.upperBound)))),
        i - a > 0 &&
          ((this.childD = new n_(t, e, n + a, o, i - a)),
          (this.lowerBound = Math.min(this.lowerBound, this.childD.lowerBound)),
          (this.upperBound = Math.max(this.upperBound, this.childD.upperBound)));
    }
  }
  function r_(t) {
    var e, n;
    if (!t) throw new Error('data is required');
    if (!Array.isArray(t) || !Array.isArray(t[0])) throw new Error('data must be scalar field, i.e. array of arrays');
    if (t.length < 2) throw new Error('data must contain at least two rows');
    if ((n = t[0].length) < 2) throw new Error('data must contain at least two columns');
    for (e = 1; e < t.length; e++) {
      if (!Array.isArray(t[e])) throw new Error('Row ' + e + ' is not an array');
      if (t[e].length != n) throw new Error('unequal row lengths detected, please provide a regular grid');
    }
    (this.data = t), (this.root = new n_(t, 0, 0, t[0].length - 1, t.length - 1));
  }
  function i_(t, n, r) {
    var i,
      o,
      a,
      s = !1,
      u = !1,
      l = null,
      c = null,
      h = null,
      f = null,
      p = null,
      g = [];
    if (!t) throw new Error('data is required');
    if (null == n) throw new Error('threshold is required');
    if (r && 'object' !== e(r)) throw new Error('options must be an object');
    if (
      ((i = (function (t) {
        var e, n, r, i, o;
        for (i = new Qm(), t = t || {}, o = Object.keys(i), e = 0; e < o.length; e++)
          null != (r = t[(n = o[e])]) && (i[n] = r);
        return (i.polygons_full = !i.polygons), (i.interpolate = Hm), i;
      })(r)),
      t instanceof r_)
    )
      (l = t), (c = t.root), (h = t.data), i.noQuadTree || (s = !0);
    else {
      if (!Array.isArray(t) || !Array.isArray(t[0]))
        throw new Error("input is neither array of arrays nor object retrieved from 'QuadTree()'");
      h = t;
    }
    if (Array.isArray(n)) {
      for (u = !0, i.noQuadTree || (s = !0), o = 0; o < n.length; o++)
        if (isNaN(+n[o])) throw new Error('threshold[' + o + '] is not a number');
    } else {
      if (isNaN(+n)) throw new Error('threshold must be a number or array of numbers');
      n = [n];
    }
    return (
      s && !c && ((l = new r_(h)), (c = l.root), (h = l.data)),
      i.verbose &&
        (i.polygons
          ? console.log('MarchingSquaresJS-isoLines: returning single lines (polygons) for each grid cell')
          : console.log('MarchingSquaresJS-isoLines: returning line paths (polygons) for entire data grid'),
        u &&
          console.log(
            'MarchingSquaresJS-isoLines: multiple lines requested, returning array of line paths instead of lines for a single threshold',
          )),
      n.forEach(function (t, n) {
        if (
          ((p = []),
          (i.threshold = t),
          i.verbose && console.log('MarchingSquaresJS-isoLines: computing iso lines for threshold ' + t),
          i.polygons)
        )
          if (s)
            c.cellsBelowThreshold(i.threshold, !0).forEach(function (t) {
              p = p.concat(Km(o_(h, t.x, t.y, i), t.x, t.y, i));
            });
          else
            for (a = 0; a < h.length - 1; ++a)
              for (n = 0; n < h[0].length - 1; ++n) p = p.concat(Km(o_(h, n, a, i), n, a, i));
        else {
          for (f = [], n = 0; n < h[0].length - 1; ++n) f[n] = [];
          if (s)
            c.cellsBelowThreshold(i.threshold, !1).forEach(function (t) {
              f[t.x][t.y] = o_(h, t.x, t.y, i);
            });
          else for (n = 0; n < h[0].length - 1; ++n) for (a = 0; a < h.length - 1; ++a) f[n][a] = o_(h, n, a, i);
          p = (function (t, n, r) {
            var i,
              o,
              a,
              s,
              u,
              l,
              c,
              h,
              f,
              p,
              g,
              y,
              v,
              d,
              m,
              _ = [],
              b = t.length - 1,
              x = t[0].length - 1,
              E = ['right', 'bottom', 'left', 'top'],
              w = [0, -1, 0, 1],
              k = [-1, 0, 1, 0],
              S = { bottom: 1, left: 2, top: 3, right: 0 };
            return (
              r.noFrame ||
                ((function (t, e) {
                  var n, r, i, o, a;
                  for (n = !0, r = t[0].length, i = t.length, a = 0; a < i; a++)
                    if (t[a][0] >= e || t[a][r - 1] >= e) {
                      n = !1;
                      break;
                    }
                  if ((n && (t[i - 1][0] >= e || t[i - 1][r - 1] >= e) && (n = !1), n))
                    for (o = 0; o < r - 1; o++)
                      if (t[0][o] >= e || t[i - 1][o] > e) {
                        n = !1;
                        break;
                      }
                  return n;
                })(t, r.threshold) &&
                  (r.linearRing
                    ? _.push([
                        [0, 0],
                        [0, b],
                        [x, b],
                        [x, 0],
                        [0, 0],
                      ])
                    : _.push([
                        [0, 0],
                        [0, b],
                        [x, b],
                        [x, 0],
                      ]))),
              n.forEach(function (t, I) {
                t.forEach(function (t, P) {
                  for (i = null, o = 0; o < 4; o++)
                    if (((i = E[o]), 'object' === e(t.edges[i]))) {
                      for (
                        u = [],
                          a = t.edges[i],
                          l = i,
                          c = I,
                          h = P,
                          f = !1,
                          p = [I + a.path[0][0], P + a.path[0][1]],
                          u.push(p);
                        !f && 'object' === e((s = n[c][h]).edges[l]);

                      )
                        if (
                          ((a = s.edges[l]),
                          delete s.edges[l],
                          ((g = a.path[1])[0] += c),
                          (g[1] += h),
                          u.push(g),
                          (l = a.move.enter),
                          (c += a.move.x),
                          (h += a.move.y),
                          void 0 === n[c] || void 0 === n[c][h])
                        ) {
                          if (!r.linearRing) break;
                          if (
                            ((y = 0),
                            (v = 0),
                            c === x
                              ? (c--, (y = 0))
                              : c < 0
                              ? (c++, (y = 2))
                              : h === b
                              ? (h--, (y = 3))
                              : h < 0 && (h++, (y = 1)),
                            c === I && h === P && y === S[i])
                          ) {
                            (f = !0), (l = i);
                            break;
                          }
                          for (;;) {
                            if (((d = !1), v > 4))
                              throw new Error('Direction change counter overflow! This should never happen!');
                            if (
                              void 0 !== n[c] &&
                              void 0 !== n[c][h] &&
                              ((s = n[c][h]), (m = E[y]), 'object' === e(s.edges[m]))
                            ) {
                              (a = s.edges[m]), u.push(t_(c, h, y, a.path)), (l = m), (d = !0);
                              break;
                            }
                            if (d) break;
                            if (
                              (u.push(e_(c, h, y)),
                              (h += k[y]),
                              (void 0 !== n[(c += w[y])] && void 0 !== n[c][h]) ||
                                (((0 === y && h < 0) ||
                                  (1 === y && c < 0) ||
                                  (2 === y && h === b) ||
                                  (3 === y && c === x)) &&
                                  ((c -= w[y]), (h -= k[y]), (y = (y + 1) % 4), v++)),
                              c === I && h === P && y === S[i])
                            ) {
                              (f = !0), (l = i);
                              break;
                            }
                          }
                        }
                      !r.linearRing || (u[u.length - 1][0] === p[0] && u[u.length - 1][1] === p[1]) || u.push(p),
                        _.push(u);
                    }
                });
              }),
              _
            );
          })(h, f, i);
        }
        u ? g.push(p) : (g = p), 'function' == typeof i.successCallback && i.successCallback(g, t);
      }),
      g
    );
  }
  function o_(t, e, n, r) {
    var i,
      o,
      a,
      s,
      u,
      l,
      c = 0,
      h = t[n + 1][e],
      f = t[n + 1][e + 1],
      p = t[n][e + 1],
      g = t[n][e],
      y = r.threshold;
    if (!(isNaN(g) || isNaN(p) || isNaN(f) || isNaN(h))) {
      switch (
        ((c |= h >= y ? 8 : 0),
        (c |= f >= y ? 4 : 0),
        (c |= p >= y ? 2 : 0),
        (l = { cval: (c = +(c |= g >= y ? 1 : 0)), polygons: [], edges: {}, x0: g, x1: p, x2: f, x3: h }),
        c)
      ) {
        case 0:
          r.polygons &&
            l.polygons.push([
              [0, 0],
              [0, 1],
              [1, 1],
              [1, 0],
            ]);
          break;
        case 15:
          break;
        case 14:
          (i = r.interpolate(g, h, y)),
            (s = r.interpolate(g, p, y)),
            r.polygons_full &&
              (l.edges.left = {
                path: [
                  [0, i],
                  [s, 0],
                ],
                move: { x: 0, y: -1, enter: 'top' },
              }),
            r.polygons &&
              l.polygons.push([
                [0, 0],
                [0, i],
                [s, 0],
              ]);
          break;
        case 13:
          (s = r.interpolate(g, p, y)),
            (o = r.interpolate(p, f, y)),
            r.polygons_full &&
              (l.edges.bottom = {
                path: [
                  [s, 0],
                  [1, o],
                ],
                move: { x: 1, y: 0, enter: 'left' },
              }),
            r.polygons &&
              l.polygons.push([
                [s, 0],
                [1, o],
                [1, 0],
              ]);
          break;
        case 11:
          (o = r.interpolate(p, f, y)),
            (a = r.interpolate(h, f, y)),
            r.polygons_full &&
              (l.edges.right = {
                path: [
                  [1, o],
                  [a, 1],
                ],
                move: { x: 0, y: 1, enter: 'bottom' },
              }),
            r.polygons &&
              l.polygons.push([
                [1, o],
                [a, 1],
                [1, 1],
              ]);
          break;
        case 7:
          (i = r.interpolate(g, h, y)),
            (a = r.interpolate(h, f, y)),
            r.polygons_full &&
              (l.edges.top = {
                path: [
                  [a, 1],
                  [0, i],
                ],
                move: { x: -1, y: 0, enter: 'right' },
              }),
            r.polygons &&
              l.polygons.push([
                [a, 1],
                [0, i],
                [0, 1],
              ]);
          break;
        case 1:
          (i = r.interpolate(g, h, y)),
            (s = r.interpolate(g, p, y)),
            r.polygons_full &&
              (l.edges.bottom = {
                path: [
                  [s, 0],
                  [0, i],
                ],
                move: { x: -1, y: 0, enter: 'right' },
              }),
            r.polygons &&
              l.polygons.push([
                [s, 0],
                [0, i],
                [0, 1],
                [1, 1],
                [1, 0],
              ]);
          break;
        case 2:
          (s = r.interpolate(g, p, y)),
            (o = r.interpolate(p, f, y)),
            r.polygons_full &&
              (l.edges.right = {
                path: [
                  [1, o],
                  [s, 0],
                ],
                move: { x: 0, y: -1, enter: 'top' },
              }),
            r.polygons &&
              l.polygons.push([
                [0, 0],
                [0, 1],
                [1, 1],
                [1, o],
                [s, 0],
              ]);
          break;
        case 4:
          (o = r.interpolate(p, f, y)),
            (a = r.interpolate(h, f, y)),
            r.polygons_full &&
              (l.edges.top = {
                path: [
                  [a, 1],
                  [1, o],
                ],
                move: { x: 1, y: 0, enter: 'left' },
              }),
            r.polygons &&
              l.polygons.push([
                [0, 0],
                [0, 1],
                [a, 1],
                [1, o],
                [1, 0],
              ]);
          break;
        case 8:
          (i = r.interpolate(g, h, y)),
            (a = r.interpolate(h, f, y)),
            r.polygons_full &&
              (l.edges.left = {
                path: [
                  [0, i],
                  [a, 1],
                ],
                move: { x: 0, y: 1, enter: 'bottom' },
              }),
            r.polygons &&
              l.polygons.push([
                [0, 0],
                [0, i],
                [a, 1],
                [1, 1],
                [1, 0],
              ]);
          break;
        case 12:
          (i = r.interpolate(g, h, y)),
            (o = r.interpolate(p, f, y)),
            r.polygons_full &&
              (l.edges.left = {
                path: [
                  [0, i],
                  [1, o],
                ],
                move: { x: 1, y: 0, enter: 'left' },
              }),
            r.polygons &&
              l.polygons.push([
                [0, 0],
                [0, i],
                [1, o],
                [1, 0],
              ]);
          break;
        case 9:
          (s = r.interpolate(g, p, y)),
            (a = r.interpolate(h, f, y)),
            r.polygons_full &&
              (l.edges.bottom = {
                path: [
                  [s, 0],
                  [a, 1],
                ],
                move: { x: 0, y: 1, enter: 'bottom' },
              }),
            r.polygons &&
              l.polygons.push([
                [s, 0],
                [a, 1],
                [1, 1],
                [1, 0],
              ]);
          break;
        case 3:
          (i = r.interpolate(g, h, y)),
            (o = r.interpolate(p, f, y)),
            r.polygons_full &&
              (l.edges.right = {
                path: [
                  [1, o],
                  [0, i],
                ],
                move: { x: -1, y: 0, enter: 'right' },
              }),
            r.polygons &&
              l.polygons.push([
                [0, i],
                [0, 1],
                [1, 1],
                [1, o],
              ]);
          break;
        case 6:
          (s = r.interpolate(g, p, y)),
            (a = r.interpolate(h, f, y)),
            r.polygons_full &&
              (l.edges.top = {
                path: [
                  [a, 1],
                  [s, 0],
                ],
                move: { x: 0, y: -1, enter: 'top' },
              }),
            r.polygons &&
              l.polygons.push([
                [0, 0],
                [0, 1],
                [a, 1],
                [s, 0],
              ]);
          break;
        case 10:
          (i = r.interpolate(g, h, y)),
            (o = r.interpolate(p, f, y)),
            (s = r.interpolate(g, p, y)),
            (a = r.interpolate(h, f, y)),
            (u = (g + p + f + h) / 4),
            r.polygons_full &&
              (u < y
                ? ((l.edges.left = {
                    path: [
                      [0, i],
                      [a, 1],
                    ],
                    move: { x: 0, y: 1, enter: 'bottom' },
                  }),
                  (l.edges.right = {
                    path: [
                      [1, o],
                      [s, 0],
                    ],
                    move: { x: 0, y: -1, enter: 'top' },
                  }))
                : ((l.edges.right = {
                    path: [
                      [1, o],
                      [a, 1],
                    ],
                    move: { x: 0, y: 1, enter: 'bottom' },
                  }),
                  (l.edges.left = {
                    path: [
                      [0, i],
                      [s, 0],
                    ],
                    move: { x: 0, y: -1, enter: 'top' },
                  }))),
            r.polygons &&
              (u < y
                ? l.polygons.push([
                    [0, 0],
                    [0, i],
                    [a, 1],
                    [1, 1],
                    [1, o],
                    [s, 0],
                  ])
                : (l.polygons.push([
                    [0, 0],
                    [0, i],
                    [s, 0],
                  ]),
                  l.polygons.push([
                    [a, 1],
                    [1, 1],
                    [1, o],
                  ])));
          break;
        case 5:
          (i = r.interpolate(g, h, y)),
            (o = r.interpolate(p, f, y)),
            (s = r.interpolate(g, p, y)),
            (a = r.interpolate(h, f, y)),
            (u = (g + p + f + h) / 4),
            r.polygons_full &&
              (u < y
                ? ((l.edges.bottom = {
                    path: [
                      [s, 0],
                      [0, i],
                    ],
                    move: { x: -1, y: 0, enter: 'right' },
                  }),
                  (l.edges.top = {
                    path: [
                      [a, 1],
                      [1, o],
                    ],
                    move: { x: 1, y: 0, enter: 'left' },
                  }))
                : ((l.edges.top = {
                    path: [
                      [a, 1],
                      [0, i],
                    ],
                    move: { x: -1, y: 0, enter: 'right' },
                  }),
                  (l.edges.bottom = {
                    path: [
                      [s, 0],
                      [1, o],
                    ],
                    move: { x: 1, y: 0, enter: 'left' },
                  }))),
            r.polygons &&
              (u < y
                ? l.polygons.push([
                    [0, i],
                    [0, 1],
                    [a, 1],
                    [1, o],
                    [1, 0],
                    [s, 0],
                  ])
                : (l.polygons.push([
                    [0, i],
                    [0, 1],
                    [a, 1],
                  ]),
                  l.polygons.push([
                    [s, 0],
                    [1, o],
                    [1, 0],
                  ])));
      }
      return l;
    }
  }
  !(function (t, e) {
    Xm(t, 'name', { value: e, configurable: !0 });
  })(Wm, 'interpolate'),
    (n_.prototype.cellsInBand = function (t, e, n) {
      var r = [];
      return (
        (n = void 0 === n || n),
        this.lowerBound > e ||
          this.upperBound < t ||
          (this.childA || this.childB || this.childC || this.childD
            ? (this.childA && (r = r.concat(this.childA.cellsInBand(t, e, n))),
              this.childB && (r = r.concat(this.childB.cellsInBand(t, e, n))),
              this.childD && (r = r.concat(this.childD.cellsInBand(t, e, n))),
              this.childC && (r = r.concat(this.childC.cellsInBand(t, e, n))))
            : (n || this.lowerBound <= t || this.upperBound >= e) && r.push({ x: this.x, y: this.y })),
        r
      );
    }),
    (n_.prototype.cellsBelowThreshold = function (t, e) {
      var n = [];
      return (
        (e = void 0 === e || e),
        this.lowerBound > t ||
          (this.childA || this.childB || this.childC || this.childD
            ? (this.childA && (n = n.concat(this.childA.cellsBelowThreshold(t, e))),
              this.childB && (n = n.concat(this.childB.cellsBelowThreshold(t, e))),
              this.childD && (n = n.concat(this.childD.cellsBelowThreshold(t, e))),
              this.childC && (n = n.concat(this.childC.cellsBelowThreshold(t, e))))
            : (e || this.upperBound >= t) && n.push({ x: this.x, y: this.y })),
        n
      );
    });
  var a_ = {
    square: function (t, e, n, r, i, o) {
      o.polygons &&
        t.polygons.push([
          [0, 0],
          [0, 1],
          [1, 1],
          [1, 0],
        ]);
    },
    triangle_bl: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate(e, i, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.lb = {
          path: [
            [0, s],
            [a, 0],
          ],
          move: { x: 0, y: -1, enter: 'tl' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, s],
            [a, 0],
            [0, 0],
          ]);
    },
    triangle_br: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.br = {
          path: [
            [a, 0],
            [1, s],
          ],
          move: { x: 1, y: 0, enter: 'lb' },
        }),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [1, s],
            [1, 0],
          ]);
    },
    triangle_tr: function (t, e, n, r, i, o) {
      var a = o.interpolate(n, r, o.minV, o.maxV),
        s = o.interpolate(i, r, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.rt = {
          path: [
            [1, a],
            [s, 1],
          ],
          move: { x: 0, y: 1, enter: 'br' },
        }),
        o.polygons &&
          t.polygons.push([
            [1, a],
            [s, 1],
            [1, 1],
          ]);
    },
    triangle_tl: function (t, e, n, r, i, o) {
      var a = o.interpolate(i, r, o.minV, o.maxV),
        s = o.interpolate(e, i, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.tl = {
          path: [
            [a, 1],
            [0, s],
          ],
          move: { x: -1, y: 0, enter: 'rt' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, s],
            [0, 1],
            [a, 1],
          ]);
    },
    tetragon_t: function (t, e, n, r, i, o) {
      var a = o.interpolate(n, r, o.minV, o.maxV),
        s = o.interpolate(e, i, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.rt = {
          path: [
            [1, a],
            [0, s],
          ],
          move: { x: -1, y: 0, enter: 'rt' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, s],
            [0, 1],
            [1, 1],
            [1, a],
          ]);
    },
    tetragon_r: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate(i, r, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.br = {
          path: [
            [a, 0],
            [s, 1],
          ],
          move: { x: 0, y: 1, enter: 'br' },
        }),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [s, 1],
            [1, 1],
            [1, 0],
          ]);
    },
    tetragon_b: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.lb = {
          path: [
            [0, a],
            [1, s],
          ],
          move: { x: 1, y: 0, enter: 'lb' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, a],
            [1, s],
            [1, 0],
          ]);
    },
    tetragon_l: function (t, e, n, r, i, o) {
      var a = o.interpolate(i, r, o.minV, o.maxV),
        s = o.interpolate(e, n, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.tl = {
          path: [
            [a, 1],
            [s, 0],
          ],
          move: { x: 0, y: -1, enter: 'tl' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, 1],
            [a, 1],
            [s, 0],
          ]);
    },
    tetragon_bl: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(e, n, o.minV, o.maxV),
        s = o.interpolate_b(e, n, o.minV, o.maxV),
        u = o.interpolate_a(e, i, o.minV, o.maxV),
        l = o.interpolate_b(e, i, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.bl = {
          path: [
            [a, 0],
            [0, u],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        }),
        (t.edges.lt = {
          path: [
            [0, l],
            [s, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, u],
            [0, l],
            [s, 0],
          ]);
    },
    tetragon_br: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(e, n, o.minV, o.maxV),
        s = o.interpolate_b(e, n, o.minV, o.maxV),
        u = o.interpolate_a(n, r, o.minV, o.maxV),
        l = o.interpolate_b(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.bl = {
          path: [
            [a, 0],
            [1, l],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        }),
        (t.edges.rb = {
          path: [
            [1, u],
            [s, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [1, l],
            [1, u],
            [s, 0],
          ]);
    },
    tetragon_tr: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(i, r, o.minV, o.maxV),
        s = o.interpolate_b(i, r, o.minV, o.maxV),
        u = o.interpolate_b(n, r, o.minV, o.maxV),
        l = o.interpolate_a(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.rb = {
          path: [
            [1, l],
            [a, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        }),
        (t.edges.tr = {
          path: [
            [s, 1],
            [1, u],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        })),
        o.polygons &&
          t.polygons.push([
            [1, l],
            [a, 1],
            [s, 1],
            [1, u],
          ]);
    },
    tetragon_tl: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(i, r, o.minV, o.maxV),
        s = o.interpolate_b(i, r, o.minV, o.maxV),
        u = o.interpolate_b(e, i, o.minV, o.maxV),
        l = o.interpolate_a(e, i, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.tr = {
          path: [
            [s, 1],
            [0, l],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        }),
        (t.edges.lt = {
          path: [
            [0, u],
            [a, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        })),
        o.polygons &&
          t.polygons.push([
            [s, 1],
            [0, l],
            [0, u],
            [a, 1],
          ]);
    },
    tetragon_lr: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(e, i, o.minV, o.maxV),
        s = o.interpolate_b(e, i, o.minV, o.maxV),
        u = o.interpolate_b(n, r, o.minV, o.maxV),
        l = o.interpolate_a(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.lt = {
          path: [
            [0, s],
            [1, u],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        }),
        (t.edges.rb = {
          path: [
            [1, l],
            [0, a],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, a],
            [0, s],
            [1, u],
            [1, l],
          ]);
    },
    tetragon_tb: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(i, r, o.minV, o.maxV),
        s = o.interpolate_b(i, r, o.minV, o.maxV),
        u = o.interpolate_b(e, n, o.minV, o.maxV),
        l = o.interpolate_a(e, n, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.tr = {
          path: [
            [s, 1],
            [u, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        }),
        (t.edges.bl = {
          path: [
            [l, 0],
            [a, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        })),
        o.polygons &&
          t.polygons.push([
            [l, 0],
            [a, 1],
            [s, 1],
            [u, 0],
          ]);
    },
    pentagon_tr: function (t, e, n, r, i, o) {
      var a = o.interpolate(i, r, o.minV, o.maxV),
        s = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.tl = {
          path: [
            [a, 1],
            [1, s],
          ],
          move: { x: 1, y: 0, enter: 'lb' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, 1],
            [a, 1],
            [1, s],
            [1, 0],
          ]);
    },
    pentagon_tl: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate(i, r, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.lb = {
          path: [
            [0, a],
            [s, 1],
          ],
          move: { x: 0, y: 1, enter: 'br' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, a],
            [s, 1],
            [1, 1],
            [1, 0],
          ]);
    },
    pentagon_br: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.rt = {
          path: [
            [1, s],
            [a, 0],
          ],
          move: { x: 0, y: -1, enter: 'tl' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, 1],
            [1, 1],
            [1, s],
            [a, 0],
          ]);
    },
    pentagon_bl: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate(e, n, o.minV, o.maxV);
      o.polygons_full &&
        (t.edges.br = {
          path: [
            [s, 0],
            [0, a],
          ],
          move: { x: -1, y: 0, enter: 'rt' },
        }),
        o.polygons &&
          t.polygons.push([
            [0, a],
            [0, 1],
            [1, 1],
            [1, 0],
            [s, 0],
          ]);
    },
    pentagon_tr_rl: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate(i, r, o.minV, o.maxV),
        u = o.interpolate_b(n, r, o.minV, o.maxV),
        l = o.interpolate_a(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.tl = {
          path: [
            [s, 1],
            [1, u],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        }),
        (t.edges.rb = {
          path: [
            [1, l],
            [0, a],
          ],
          move: { x: -1, y: 0, enter: 'rt' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, a],
            [0, 1],
            [s, 1],
            [1, u],
            [1, l],
          ]);
    },
    pentagon_rb_bt: function (t, e, n, r, i, o) {
      var a = o.interpolate(n, r, o.minV, o.maxV),
        s = o.interpolate_b(e, n, o.minV, o.maxV),
        u = o.interpolate_a(e, n, o.minV, o.maxV),
        l = o.interpolate(i, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.rt = {
          path: [
            [1, a],
            [s, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        }),
        (t.edges.bl = {
          path: [
            [u, 0],
            [l, 1],
          ],
          move: { x: 0, y: 1, enter: 'br' },
        })),
        o.polygons &&
          t.polygons.push([
            [l, 1],
            [1, 1],
            [1, a],
            [s, 0],
            [u, 0],
          ]);
    },
    pentagon_bl_lr: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate_a(e, i, o.minV, o.maxV),
        u = o.interpolate_b(e, i, o.minV, o.maxV),
        l = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.br = {
          path: [
            [a, 0],
            [0, s],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        }),
        (t.edges.lt = {
          path: [
            [0, u],
            [1, l],
          ],
          move: { x: 1, y: 0, enter: 'lb' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, s],
            [0, u],
            [1, l],
            [1, 0],
          ]);
    },
    pentagon_lt_tb: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate_a(i, r, o.minV, o.maxV),
        u = o.interpolate_b(i, r, o.minV, o.maxV),
        l = o.interpolate(e, n, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.lb = {
          path: [
            [0, a],
            [s, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        }),
        (t.edges.tr = {
          path: [
            [u, 1],
            [l, 0],
          ],
          move: { x: 0, y: -1, enter: 'tl' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, a],
            [s, 1],
            [u, 1],
            [l, 0],
          ]);
    },
    pentagon_bl_tb: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate(i, r, o.minV, o.maxV),
        u = o.interpolate_b(e, n, o.minV, o.maxV),
        l = o.interpolate_a(e, n, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.bl = {
          path: [
            [l, 0],
            [0, a],
          ],
          move: { x: -1, y: 0, enter: 'rt' },
        }),
        (t.edges.tl = {
          path: [
            [s, 1],
            [u, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, a],
            [0, 1],
            [s, 1],
            [u, 0],
            [l, 0],
          ]);
    },
    pentagon_lt_rl: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(e, i, o.minV, o.maxV),
        s = o.interpolate_b(e, i, o.minV, o.maxV),
        u = o.interpolate(i, r, o.minV, o.maxV),
        l = o.interpolate(n, i, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.lt = {
          path: [
            [0, s],
            [u, 1],
          ],
          move: { x: 0, y: 1, enter: 'br' },
        }),
        (t.edges.rt = {
          path: [
            [1, l],
            [0, a],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, a],
            [0, s],
            [u, 1],
            [1, 1],
            [1, l],
          ]);
    },
    pentagon_tr_bt: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(i, r, o.minV, o.maxV),
        s = o.interpolate_b(i, r, o.minV, o.maxV),
        u = o.interpolate(n, r, o.minV, o.maxV),
        l = o.interpolate(e, n, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.br = {
          path: [
            [l, 0],
            [a, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        }),
        (t.edges.tr = {
          path: [
            [s, 1],
            [1, u],
          ],
          move: { x: 1, y: 0, enter: 'lb' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 1],
            [s, 1],
            [1, u],
            [1, 0],
            [l, 0],
          ]);
    },
    pentagon_rb_lr: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate_b(n, r, o.minV, o.maxV),
        u = o.interpolate_a(n, r, o.minV, o.maxV),
        l = o.interpolate(e, n, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.lb = {
          path: [
            [0, a],
            [1, s],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        }),
        (t.edges.rb = {
          path: [
            [1, u],
            [l, 0],
          ],
          move: { x: 0, y: -1, enter: 'tl' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, a],
            [1, s],
            [1, u],
            [l, 0],
          ]);
    },
    hexagon_lt_tr: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate_a(i, r, o.minV, o.maxV),
        u = o.interpolate_b(i, r, o.minV, o.maxV),
        l = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.lb = {
          path: [
            [0, a],
            [s, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        }),
        (t.edges.tr = {
          path: [
            [u, 1],
            [1, l],
          ],
          move: { x: 1, y: 0, enter: 'lb' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, a],
            [s, 1],
            [u, 1],
            [1, l],
            [1, 0],
          ]);
    },
    hexagon_bl_lt: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate_a(e, i, o.minV, o.maxV),
        u = o.interpolate_b(e, i, o.minV, o.maxV),
        l = o.interpolate(i, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.br = {
          path: [
            [a, 0],
            [0, s],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        }),
        (t.edges.lt = {
          path: [
            [0, u],
            [l, 1],
          ],
          move: { x: 0, y: 1, enter: 'br' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, s],
            [0, u],
            [l, 1],
            [1, 1],
            [1, 0],
          ]);
    },
    hexagon_bl_rb: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(e, n, o.minV, o.maxV),
        s = o.interpolate_b(e, n, o.minV, o.maxV),
        u = o.interpolate(e, i, o.minV, o.maxV),
        l = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.bl = {
          path: [
            [a, 0],
            [0, u],
          ],
          move: { x: -1, y: 0, enter: 'rt' },
        }),
        (t.edges.rt = {
          path: [
            [1, l],
            [s, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, u],
            [0, 1],
            [1, 1],
            [1, l],
            [s, 0],
          ]);
    },
    hexagon_tr_rb: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate(i, r, o.minV, o.maxV),
        u = o.interpolate_b(n, r, o.minV, o.maxV),
        l = o.interpolate_a(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.tl = {
          path: [
            [s, 1],
            [1, u],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        }),
        (t.edges.rb = {
          path: [
            [1, l],
            [a, 0],
          ],
          move: { x: 0, y: -1, enter: 'tl' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, 1],
            [s, 1],
            [1, u],
            [1, l],
            [a, 0],
          ]);
    },
    hexagon_lt_rb: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, i, o.minV, o.maxV),
        s = o.interpolate(i, r, o.minV, o.maxV),
        u = o.interpolate(n, r, o.minV, o.maxV),
        l = o.interpolate(e, n, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.lb = {
          path: [
            [0, a],
            [s, 1],
          ],
          move: { x: 0, y: 1, enter: 'br' },
        }),
        (t.edges.rt = {
          path: [
            [1, u],
            [l, 0],
          ],
          move: { x: 0, y: -1, enter: 'tl' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, a],
            [s, 1],
            [1, 1],
            [1, u],
            [l, 0],
          ]);
    },
    hexagon_bl_tr: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate(e, i, o.minV, o.maxV),
        u = o.interpolate(i, r, o.minV, o.maxV),
        l = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.br = {
          path: [
            [a, 0],
            [0, s],
          ],
          move: { x: -1, y: 0, enter: 'rt' },
        }),
        (t.edges.tl = {
          path: [
            [u, 1],
            [1, l],
          ],
          move: { x: 1, y: 0, enter: 'lb' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, s],
            [0, 1],
            [u, 1],
            [1, l],
            [1, 0],
          ]);
    },
    heptagon_tr: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(e, n, o.minV, o.maxV),
        s = o.interpolate_b(e, n, o.minV, o.maxV),
        u = o.interpolate_a(e, i, o.minV, o.maxV),
        l = o.interpolate_b(e, i, o.minV, o.maxV),
        c = o.interpolate(i, r, o.minV, o.maxV),
        h = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.bl = {
          path: [
            [a, 0],
            [0, u],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        }),
        (t.edges.lt = {
          path: [
            [0, l],
            [c, 1],
          ],
          move: { x: 0, y: 1, enter: 'br' },
        }),
        (t.edges.rt = {
          path: [
            [1, h],
            [s, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, u],
            [0, l],
            [c, 1],
            [1, 1],
            [1, h],
            [s, 0],
          ]);
    },
    heptagon_bl: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate(e, i, o.minV, o.maxV),
        u = o.interpolate_a(i, r, o.minV, o.maxV),
        l = o.interpolate_b(i, r, o.minV, o.maxV),
        c = o.interpolate_b(n, r, o.minV, o.maxV),
        h = o.interpolate_a(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.lb = {
          path: [
            [0, s],
            [u, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        }),
        (t.edges.tr = {
          path: [
            [l, 1],
            [1, c],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        }),
        (t.edges.rb = {
          path: [
            [1, h],
            [a, 0],
          ],
          move: { x: 0, y: -1, enter: 'tl' },
        })),
        o.polygons &&
          t.polygons.push([
            [0, 0],
            [0, s],
            [u, 1],
            [l, 1],
            [1, c],
            [1, h],
            [a, 0],
          ]);
    },
    heptagon_tl: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(e, n, o.minV, o.maxV),
        s = o.interpolate_b(e, n, o.minV, o.maxV),
        u = o.interpolate(e, i, o.minV, o.maxV),
        l = o.interpolate(i, r, o.minV, o.maxV),
        c = o.interpolate_b(n, r, o.minV, o.maxV),
        h = o.interpolate_a(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.bl = {
          path: [
            [a, 0],
            [0, u],
          ],
          move: { x: -1, y: 0, enter: 'rt' },
        }),
        (t.edges.tl = {
          path: [
            [l, 1],
            [1, c],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        }),
        (t.edges.rb = {
          path: [
            [1, h],
            [s, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, u],
            [0, 1],
            [l, 1],
            [1, c],
            [1, h],
            [s, 0],
          ]);
    },
    heptagon_br: function (t, e, n, r, i, o) {
      var a = o.interpolate(e, n, o.minV, o.maxV),
        s = o.interpolate_a(e, i, o.minV, o.maxV),
        u = o.interpolate_b(e, i, o.minV, o.maxV),
        l = o.interpolate_a(i, r, o.minV, o.maxV),
        c = o.interpolate_b(i, r, o.minV, o.maxV),
        h = o.interpolate(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.br = {
          path: [
            [a, 0],
            [0, s],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        }),
        (t.edges.lt = {
          path: [
            [0, u],
            [l, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        }),
        (t.edges.tr = {
          path: [
            [c, 1],
            [1, h],
          ],
          move: { x: 1, y: 0, enter: 'lb' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, s],
            [0, u],
            [l, 1],
            [c, 1],
            [1, h],
            [1, 0],
          ]);
    },
    octagon: function (t, e, n, r, i, o) {
      var a = o.interpolate_a(e, n, o.minV, o.maxV),
        s = o.interpolate_b(e, n, o.minV, o.maxV),
        u = o.interpolate_a(e, i, o.minV, o.maxV),
        l = o.interpolate_b(e, i, o.minV, o.maxV),
        c = o.interpolate_a(i, r, o.minV, o.maxV),
        h = o.interpolate_b(i, r, o.minV, o.maxV),
        f = o.interpolate_b(n, r, o.minV, o.maxV),
        p = o.interpolate_a(n, r, o.minV, o.maxV);
      o.polygons_full &&
        ((t.edges.bl = {
          path: [
            [a, 0],
            [0, u],
          ],
          move: { x: -1, y: 0, enter: 'rb' },
        }),
        (t.edges.lt = {
          path: [
            [0, l],
            [c, 1],
          ],
          move: { x: 0, y: 1, enter: 'bl' },
        }),
        (t.edges.tr = {
          path: [
            [h, 1],
            [1, f],
          ],
          move: { x: 1, y: 0, enter: 'lt' },
        }),
        (t.edges.rb = {
          path: [
            [1, p],
            [s, 0],
          ],
          move: { x: 0, y: -1, enter: 'tr' },
        })),
        o.polygons &&
          t.polygons.push([
            [a, 0],
            [0, u],
            [0, l],
            [c, 1],
            [h, 1],
            [1, f],
            [1, p],
            [s, 0],
          ]);
    },
  };
  function s_(t, n, r, i) {
    var o,
      a,
      s,
      u = !1,
      l = null,
      c = null,
      h = null,
      f = null,
      p = !1,
      g = [],
      y = [],
      v = [];
    if (!t) throw new Error('data is required');
    if (null == n) throw new Error('lowerBound is required');
    if (null == r) throw new Error('bandWidth is required');
    if (i && 'object' !== e(i)) throw new Error('options must be an object');
    if (
      ((s = (function (t) {
        var e, n, r, i, o;
        for (i = new Qm(), t = t || {}, o = Object.keys(i), e = 0; e < o.length; e++)
          null != (r = t[(n = o[e])]) && (i[n] = r);
        return (i.polygons_full = !i.polygons), (i.interpolate = Zm), (i.interpolate_a = Jm), (i.interpolate_b = $m), i;
      })(i)),
      t instanceof r_)
    )
      (l = t), (c = t.root), (h = t.data), s.noQuadTree || (u = !0);
    else {
      if (!Array.isArray(t) || !Array.isArray(t[0]))
        throw new Error("input is neither array of arrays nor object retrieved from 'QuadTree()'");
      h = t;
    }
    if (Array.isArray(n)) {
      for (p = !0, s.noQuadTree || (u = !0), o = 0; o < n.length; o++)
        if (isNaN(+n[o])) throw new Error('lowerBound[' + o + '] is not a number');
      if (Array.isArray(r)) {
        if (n.length !== r.length) throw new Error('lowerBound and bandWidth have unequal lengths');
        for (o = 0; o < r.length; o++) if (isNaN(+r[o])) throw new Error('bandWidth[' + o + '] is not a number');
      } else {
        if (isNaN(+r)) throw new Error('bandWidth must be a number');
        for (g = [], o = 0; o < n.length; o++) g.push(r);
        r = g;
      }
    } else {
      if (isNaN(+n)) throw new Error('lowerBound must be a number');
      if (((n = [n]), isNaN(+r))) throw new Error('bandWidth must be a number');
      r = [r];
    }
    return (
      u && !c && ((l = new r_(h)), (c = l.root), (h = l.data)),
      s.verbose &&
        (s.polygons
          ? console.log('MarchingSquaresJS-isoBands: returning single polygons for each grid cell')
          : console.log('MarchingSquaresJS-isoBands: returning polygon paths for entire data grid'),
        p &&
          console.log(
            'MarchingSquaresJS-isoBands: multiple bands requested, returning array of band polygons instead of polygons for a single band',
          )),
      n.forEach(function (t, n) {
        if (
          ((y = []),
          (s.minV = t),
          (s.maxV = t + r[n]),
          s.verbose && console.log('MarchingSquaresJS-isoBands: computing isobands for [' + t + ':' + (t + r[n]) + ']'),
          s.polygons)
        )
          if (u)
            c.cellsInBand(s.minV, s.maxV, !0).forEach(function (t) {
              y = y.concat(Km(l_(h, t.x, t.y, s), t.x, t.y, s));
            });
          else
            for (a = 0; a < h.length - 1; ++a)
              for (o = 0; o < h[0].length - 1; ++o) y = y.concat(Km(l_(h, o, a, s), o, a, s));
        else {
          for (f = [], o = 0; o < h[0].length - 1; ++o) f[o] = [];
          if (u)
            c.cellsInBand(s.minV, s.maxV, !1).forEach(function (t) {
              f[t.x][t.y] = l_(h, t.x, t.y, s);
            });
          else for (o = 0; o < h[0].length - 1; ++o) for (a = 0; a < h.length - 1; ++a) f[o][a] = l_(h, o, a, s);
          y = (function (t, n, r) {
            var i,
              o,
              a,
              s,
              u,
              l,
              c,
              h,
              f,
              p,
              g,
              y,
              v,
              d,
              m,
              _,
              b = [],
              x = t.length - 1,
              E = t[0].length - 1,
              w = [
                ['rt', 'rb'],
                ['br', 'bl'],
                ['lb', 'lt'],
                ['tl', 'tr'],
              ],
              k = [0, -1, 0, 1],
              S = [-1, 0, 1, 0],
              I = ['bl', 'lb', 'lt', 'tl', 'tr', 'rt', 'rb', 'br'],
              P = { bl: 1, br: 1, lb: 2, lt: 2, tl: 3, tr: 3, rt: 0, rb: 0 };
            return (
              (function (t, e, n) {
                var r, i, o, a, s;
                for (r = !0, i = t[0].length, o = t.length, s = 0; s < o; s++)
                  if (t[s][0] < e || t[s][0] > n || t[s][i - 1] < e || t[s][i - 1] > n) {
                    r = !1;
                    break;
                  }
                if (
                  (r && (t[o - 1][0] < e || t[o - 1][0] > n || t[o - 1][i - 1] < e || t[o - 1][i - 1] > n) && (r = !1),
                  r)
                )
                  for (a = 0; a < i - 1; a++)
                    if (t[0][a] < e || t[0][a] > n || t[o - 1][a] < e || t[o - 1][a] > n) {
                      r = !1;
                      break;
                    }
                return r;
              })(t, r.minV, r.maxV) &&
                (r.linearRing
                  ? b.push([
                      [0, 0],
                      [0, x],
                      [E, x],
                      [E, 0],
                      [0, 0],
                    ])
                  : b.push([
                      [0, 0],
                      [0, x],
                      [E, x],
                      [E, 0],
                    ])),
              n.forEach(function (t, N) {
                t.forEach(function (t, M) {
                  for (i = null, a = 0; a < 8; a++)
                    if (((i = I[a]), 'object' === e(t.edges[i]))) {
                      for (
                        o = [],
                          s = t.edges[i],
                          c = i,
                          h = N,
                          f = M,
                          p = !1,
                          g = [N + s.path[0][0], M + s.path[0][1]],
                          o.push(g);
                        !p && 'object' === e((y = n[h][f]).edges[c]);

                      )
                        if (
                          ((s = y.edges[c]),
                          delete y.edges[c],
                          ((m = s.path[1])[0] += h),
                          (m[1] += f),
                          o.push(m),
                          (c = s.move.enter),
                          (h += s.move.x),
                          (f += s.move.y),
                          void 0 === n[h] || void 0 === n[h][f])
                        ) {
                          if (((v = 0), (d = 0), h === E)) h--, (v = 0);
                          else if (h < 0) h++, (v = 2);
                          else if (f === x) f--, (v = 3);
                          else {
                            if (!(f < 0)) throw new Error('Left the grid somewhere in the interior!');
                            f++, (v = 1);
                          }
                          if (h === N && f === M && v === P[i]) {
                            (p = !0), (c = i);
                            break;
                          }
                          for (;;) {
                            if (((_ = !1), d > 4))
                              throw new Error('Direction change counter overflow! This should never happen!');
                            if (void 0 !== n[h] && void 0 !== n[h][f])
                              for (y = n[h][f], u = 0; u < w[v].length; u++)
                                if (((l = w[v][u]), 'object' === e(y.edges[l]))) {
                                  (s = y.edges[l]), o.push(t_(h, f, v, s.path)), (c = l), (_ = !0);
                                  break;
                                }
                            if (_) break;
                            if (
                              (o.push(e_(h, f, v)),
                              (f += S[v]),
                              (void 0 !== n[(h += k[v])] && void 0 !== n[h][f]) ||
                                (((0 === v && f < 0) ||
                                  (1 === v && h < 0) ||
                                  (2 === v && f === x) ||
                                  (3 === v && h === E)) &&
                                  ((h -= k[v]), (f -= S[v]), (v = (v + 1) % 4), d++)),
                              h === N && f === M && v === P[i])
                            ) {
                              (p = !0), (c = i);
                              break;
                            }
                          }
                        }
                      !r.linearRing || (o[o.length - 1][0] === g[0] && o[o.length - 1][1] === g[1]) || o.push(g),
                        b.push(o);
                    }
                });
              }),
              b
            );
          })(h, f, s);
        }
        p ? v.push(y) : (v = y), 'function' == typeof s.successCallback && s.successCallback(v, t, r[n]);
      }),
      v
    );
  }
  function u_(t, e, n, r, i, o) {
    var a = (r + n + e + t) / 4;
    return a > o ? 2 : a < i ? 0 : 1;
  }
  function l_(t, e, n, r) {
    var i,
      o,
      a = 0,
      s = t[n + 1][e],
      u = t[n + 1][e + 1],
      l = t[n][e + 1],
      c = t[n][e],
      h = r.minV,
      f = r.maxV;
    if (!(isNaN(c) || isNaN(l) || isNaN(u) || isNaN(s))) {
      switch (
        ((a |= s < h ? 0 : s > f ? 128 : 64),
        (a |= u < h ? 0 : u > f ? 32 : 16),
        (a |= l < h ? 0 : l > f ? 8 : 4),
        (o = 0),
        (i = {
          cval: (a = +(a |= c < h ? 0 : c > f ? 2 : 1)),
          polygons: [],
          edges: {},
          x0: c,
          x1: l,
          x2: u,
          x3: s,
          x: e,
          y: n,
        }),
        a)
      ) {
        case 85:
          a_.square(i, c, l, u, s, r);
        case 0:
        case 170:
          break;
        case 169:
          a_.triangle_bl(i, c, l, u, s, r);
          break;
        case 166:
          a_.triangle_br(i, c, l, u, s, r);
          break;
        case 154:
          a_.triangle_tr(i, c, l, u, s, r);
          break;
        case 106:
          a_.triangle_tl(i, c, l, u, s, r);
          break;
        case 1:
          a_.triangle_bl(i, c, l, u, s, r);
          break;
        case 4:
          a_.triangle_br(i, c, l, u, s, r);
          break;
        case 16:
          a_.triangle_tr(i, c, l, u, s, r);
          break;
        case 64:
          a_.triangle_tl(i, c, l, u, s, r);
          break;
        case 168:
          a_.tetragon_bl(i, c, l, u, s, r);
          break;
        case 162:
          a_.tetragon_br(i, c, l, u, s, r);
          break;
        case 138:
          a_.tetragon_tr(i, c, l, u, s, r);
          break;
        case 42:
          a_.tetragon_tl(i, c, l, u, s, r);
          break;
        case 2:
          a_.tetragon_bl(i, c, l, u, s, r);
          break;
        case 8:
          a_.tetragon_br(i, c, l, u, s, r);
          break;
        case 32:
          a_.tetragon_tr(i, c, l, u, s, r);
          break;
        case 128:
          a_.tetragon_tl(i, c, l, u, s, r);
          break;
        case 5:
          a_.tetragon_b(i, c, l, u, s, r);
          break;
        case 20:
          a_.tetragon_r(i, c, l, u, s, r);
          break;
        case 80:
          a_.tetragon_t(i, c, l, u, s, r);
          break;
        case 65:
          a_.tetragon_l(i, c, l, u, s, r);
          break;
        case 165:
          a_.tetragon_b(i, c, l, u, s, r);
          break;
        case 150:
          a_.tetragon_r(i, c, l, u, s, r);
          break;
        case 90:
          a_.tetragon_t(i, c, l, u, s, r);
          break;
        case 105:
          a_.tetragon_l(i, c, l, u, s, r);
          break;
        case 160:
          a_.tetragon_lr(i, c, l, u, s, r);
          break;
        case 130:
          a_.tetragon_tb(i, c, l, u, s, r);
          break;
        case 10:
          a_.tetragon_lr(i, c, l, u, s, r);
          break;
        case 40:
          a_.tetragon_tb(i, c, l, u, s, r);
          break;
        case 101:
          a_.pentagon_tr(i, c, l, u, s, r);
          break;
        case 149:
          a_.pentagon_tl(i, c, l, u, s, r);
          break;
        case 86:
          a_.pentagon_bl(i, c, l, u, s, r);
          break;
        case 89:
          a_.pentagon_br(i, c, l, u, s, r);
          break;
        case 69:
          a_.pentagon_tr(i, c, l, u, s, r);
          break;
        case 21:
          a_.pentagon_tl(i, c, l, u, s, r);
          break;
        case 84:
          a_.pentagon_bl(i, c, l, u, s, r);
          break;
        case 81:
          a_.pentagon_br(i, c, l, u, s, r);
          break;
        case 96:
          a_.pentagon_tr_rl(i, c, l, u, s, r);
          break;
        case 24:
          a_.pentagon_rb_bt(i, c, l, u, s, r);
          break;
        case 6:
          a_.pentagon_bl_lr(i, c, l, u, s, r);
          break;
        case 129:
          a_.pentagon_lt_tb(i, c, l, u, s, r);
          break;
        case 74:
          a_.pentagon_tr_rl(i, c, l, u, s, r);
          break;
        case 146:
          a_.pentagon_rb_bt(i, c, l, u, s, r);
          break;
        case 164:
          a_.pentagon_bl_lr(i, c, l, u, s, r);
          break;
        case 41:
          a_.pentagon_lt_tb(i, c, l, u, s, r);
          break;
        case 66:
          a_.pentagon_bl_tb(i, c, l, u, s, r);
          break;
        case 144:
          a_.pentagon_lt_rl(i, c, l, u, s, r);
          break;
        case 36:
          a_.pentagon_tr_bt(i, c, l, u, s, r);
          break;
        case 9:
          a_.pentagon_rb_lr(i, c, l, u, s, r);
          break;
        case 104:
          a_.pentagon_bl_tb(i, c, l, u, s, r);
          break;
        case 26:
          a_.pentagon_lt_rl(i, c, l, u, s, r);
          break;
        case 134:
          a_.pentagon_tr_bt(i, c, l, u, s, r);
          break;
        case 161:
          a_.pentagon_rb_lr(i, c, l, u, s, r);
          break;
        case 37:
          a_.hexagon_lt_tr(i, c, l, u, s, r);
          break;
        case 148:
          a_.hexagon_bl_lt(i, c, l, u, s, r);
          break;
        case 82:
          a_.hexagon_bl_rb(i, c, l, u, s, r);
          break;
        case 73:
          a_.hexagon_tr_rb(i, c, l, u, s, r);
          break;
        case 133:
          a_.hexagon_lt_tr(i, c, l, u, s, r);
          break;
        case 22:
          a_.hexagon_bl_lt(i, c, l, u, s, r);
          break;
        case 88:
          a_.hexagon_bl_rb(i, c, l, u, s, r);
          break;
        case 97:
          a_.hexagon_tr_rb(i, c, l, u, s, r);
          break;
        case 145:
        case 25:
          a_.hexagon_lt_rb(i, c, l, u, s, r);
          break;
        case 70:
        case 100:
          a_.hexagon_bl_tr(i, c, l, u, s, r);
          break;
        case 17:
          0 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_bl(i, c, l, u, s, r), a_.triangle_tr(i, c, l, u, s, r))
            : a_.hexagon_lt_rb(i, c, l, u, s, r);
          break;
        case 68:
          0 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_tl(i, c, l, u, s, r), a_.triangle_br(i, c, l, u, s, r))
            : a_.hexagon_bl_tr(i, c, l, u, s, r);
          break;
        case 153:
          2 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_bl(i, c, l, u, s, r), a_.triangle_tr(i, c, l, u, s, r))
            : a_.hexagon_lt_rb(i, c, l, u, s, r);
          break;
        case 102:
          2 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_tl(i, c, l, u, s, r), a_.triangle_br(i, c, l, u, s, r))
            : a_.hexagon_bl_tr(i, c, l, u, s, r);
          break;
        case 152:
          2 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_tr(i, c, l, u, s, r), a_.tetragon_bl(i, c, l, u, s, r))
            : a_.heptagon_tr(i, c, l, u, s, r);
          break;
        case 137:
          2 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_bl(i, c, l, u, s, r), a_.tetragon_tr(i, c, l, u, s, r))
            : a_.heptagon_bl(i, c, l, u, s, r);
          break;
        case 98:
          2 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_tl(i, c, l, u, s, r), a_.tetragon_br(i, c, l, u, s, r))
            : a_.heptagon_tl(i, c, l, u, s, r);
          break;
        case 38:
          2 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_br(i, c, l, u, s, r), a_.tetragon_tl(i, c, l, u, s, r))
            : a_.heptagon_br(i, c, l, u, s, r);
          break;
        case 18:
          0 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_tr(i, c, l, u, s, r), a_.tetragon_bl(i, c, l, u, s, r))
            : a_.heptagon_tr(i, c, l, u, s, r);
          break;
        case 33:
          0 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_bl(i, c, l, u, s, r), a_.tetragon_tr(i, c, l, u, s, r))
            : a_.heptagon_bl(i, c, l, u, s, r);
          break;
        case 72:
          0 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_tl(i, c, l, u, s, r), a_.tetragon_br(i, c, l, u, s, r))
            : a_.heptagon_tl(i, c, l, u, s, r);
          break;
        case 132:
          0 === (o = u_(c, l, u, s, h, f))
            ? (a_.triangle_br(i, c, l, u, s, r), a_.tetragon_tl(i, c, l, u, s, r))
            : a_.heptagon_br(i, c, l, u, s, r);
          break;
        case 136:
          0 === (o = u_(c, l, u, s, h, f))
            ? (a_.tetragon_tl(i, c, l, u, s, r), a_.tetragon_br(i, c, l, u, s, r))
            : 1 === o
            ? a_.octagon(i, c, l, u, s, r)
            : (a_.tetragon_bl(i, c, l, u, s, r), a_.tetragon_tr(i, c, l, u, s, r));
          break;
        case 34:
          0 === (o = u_(c, l, u, s, h, f))
            ? (a_.tetragon_bl(i, c, l, u, s, r), a_.tetragon_tr(i, c, l, u, s, r))
            : 1 === o
            ? a_.octagon(i, c, l, u, s, r)
            : (a_.tetragon_tl(i, c, l, u, s, r), a_.tetragon_br(i, c, l, u, s, r));
      }
      return i;
    }
  }
  var c_ = Object.defineProperty,
    h_ = Object.getOwnPropertySymbols,
    f_ = Object.prototype.hasOwnProperty,
    p_ = Object.prototype.propertyIsEnumerable,
    g_ = function (t, e, n) {
      return e in t ? c_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n);
    },
    y_ = function (t, e) {
      for (var n in e || (e = {})) f_.call(e, n) && g_(t, n, e[n]);
      if (h_) {
        var r,
          i = c(h_(e));
        try {
          for (i.s(); !(r = i.n()).done; ) {
            n = r.value;
            p_.call(e, n) && g_(t, n, e[n]);
          }
        } catch (t) {
          i.e(t);
        } finally {
          i.f();
        }
      }
      return t;
    },
    v_ = function (t, e) {
      return c_(t, 'name', { value: e, configurable: !0 });
    };
  function d_(t, e) {
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.zProperty || 'elevation',
      r = e.flip,
      i = e.flags;
    ll(t, 'Point', 'input must contain Points');
    for (var o = m_(t, r), a = [], s = 0; s < o.length; s++) {
      for (var u = o[s], l = [], c = 0; c < u.length; c++) {
        var h = u[c];
        h.properties[n] ? l.push(h.properties[n]) : l.push(0), !0 === i && (h.properties.matrixPosition = [s, c]);
      }
      a.push(l);
    }
    return a;
  }
  function m_(t, e) {
    var n = {};
    Tl(t, function (t) {
      var e = ol(t)[1];
      n[e] || (n[e] = []), n[e].push(t);
    });
    var r = Object.keys(n).map(function (t) {
      return n[t].sort(function (t, e) {
        return ol(t)[0] - ol(e)[0];
      });
    });
    return r.sort(function (t, n) {
      return e ? ol(t[0])[1] - ol(n[0])[1] : ol(n[0])[1] - ol(t[0])[1];
    });
  }
  function __(t, e, n) {
    if (!Qu((n = n || {}))) throw new Error('options is invalid');
    var r = n.zProperty || 'elevation',
      i = n.commonProperties || {},
      o = n.breaksProperties || [];
    if ((ll(t, 'Point', 'Input must contain Points'), !e)) throw new Error('breaks is required');
    if (!Array.isArray(e)) throw new Error('breaks is not an Array');
    if (!Qu(i)) throw new Error('commonProperties is not an Object');
    if (!Array.isArray(o)) throw new Error('breaksProperties is not an Array');
    var a = d_(t, { zProperty: r, flip: !0 }),
      s = b_(a, e, r),
      u = (s = x_(s, a, t)).map(function (t, e) {
        if (o[e] && !Qu(o[e])) throw new Error('Each mappedProperty is required to be an Object');
        var n = y_(y_({}, i), o[e]);
        return (n[r] = t[r]), qu(t.groupedRings, n);
      });
    return ju(u);
  }
  function b_(t, e, n) {
    for (var r = [], i = 1; i < e.length; i++) {
      var a = +e[i - 1],
        s = +e[i],
        u = w_(E_(s_(t, a, s - a)));
      r.push(o({ groupedRings: u }, n, a + '-' + s));
    }
    return r;
  }
  function x_(t, e, n) {
    var r = rc(n),
      i = r[2] - r[0],
      o = r[3] - r[1],
      a = r[0],
      s = r[1],
      u = e[0].length - 1,
      l = e.length - 1,
      c = i / u,
      h = o / l;
    return t.map(function (t) {
      return (
        (t.groupedRings = t.groupedRings.map(function (t) {
          return t.map(function (t) {
            return t.map(function (t) {
              return [t[0] * c + a, t[1] * h + s];
            });
          });
        })),
        t
      );
    });
  }
  function E_(t) {
    var e = t.map(function (t) {
      return { ring: t, area: Jl(Cu([t])) };
    });
    return (
      e.sort(function (t, e) {
        return e.area - t.area;
      }),
      e.map(function (t) {
        return t.ring;
      })
    );
  }
  function w_(t) {
    for (
      var e = t.map(function (t) {
          return { lrCoordinates: t, grouped: !1 };
        }),
        n = [];
      !S_(e);

    )
      for (var r = 0; r < e.length; r++)
        if (!e[r].grouped) {
          var i = [];
          i.push(e[r].lrCoordinates), (e[r].grouped = !0);
          for (var o = Cu([e[r].lrCoordinates]), a = r + 1; a < e.length; a++) {
            if (!e[a].grouped) k_(Cu([e[a].lrCoordinates]), o) && (i.push(e[a].lrCoordinates), (e[a].grouped = !0));
          }
          n.push(i);
        }
    return n;
  }
  function k_(t, e) {
    for (var n = _m(t), r = 0; r < n.features.length; r++) if (!Nc(n.features[r], e)) return !1;
    return !0;
  }
  function S_(t) {
    for (var e = 0; e < t.length; e++) if (!1 === t[e].grouped) return !1;
    return !0;
  }
  v_(d_, 'gridToMatrix'),
    v_(m_, 'sortPointsByLatLng'),
    v_(__, 'isobands'),
    v_(b_, 'createContourLines'),
    v_(x_, 'rescaleContours'),
    v_(E_, 'orderByArea'),
    v_(w_, 'groupNestedRings'),
    v_(k_, 'isInside'),
    v_(S_, 'allGrouped');
  var I_ = Object.defineProperty,
    P_ = Object.getOwnPropertySymbols,
    N_ = Object.prototype.hasOwnProperty,
    M_ = Object.prototype.propertyIsEnumerable,
    O_ = function (t, e, n) {
      return e in t ? I_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n);
    },
    L_ = function (t, e) {
      for (var n in e || (e = {})) N_.call(e, n) && O_(t, n, e[n]);
      if (P_) {
        var r,
          i = c(P_(e));
        try {
          for (i.s(); !(r = i.n()).done; ) {
            n = r.value;
            M_.call(e, n) && O_(t, n, e[n]);
          }
        } catch (t) {
          i.e(t);
        } finally {
          i.f();
        }
      }
      return t;
    },
    R_ = function (t, e) {
      return I_(t, 'name', { value: e, configurable: !0 });
    };
  function C_(t, e) {
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.zProperty || 'elevation',
      r = e.flip,
      i = e.flags;
    ll(t, 'Point', 'input must contain Points');
    for (var o = T_(t, r), a = [], s = 0; s < o.length; s++) {
      for (var u = o[s], l = [], c = 0; c < u.length; c++) {
        var h = u[c];
        h.properties[n] ? l.push(h.properties[n]) : l.push(0), !0 === i && (h.properties.matrixPosition = [s, c]);
      }
      a.push(l);
    }
    return a;
  }
  function T_(t, e) {
    var n = {};
    Tl(t, function (t) {
      var e = ol(t)[1];
      n[e] || (n[e] = []), n[e].push(t);
    });
    var r = Object.keys(n).map(function (t) {
      return n[t].sort(function (t, e) {
        return ol(t)[0] - ol(e)[0];
      });
    });
    return r.sort(function (t, n) {
      return e ? ol(t[0])[1] - ol(n[0])[1] : ol(n[0])[1] - ol(t[0])[1];
    });
  }
  function A_(t, e, n) {
    if (!Qu((n = n || {}))) throw new Error('options is invalid');
    var r = n.zProperty || 'elevation',
      i = n.commonProperties || {},
      o = n.breaksProperties || [];
    if ((ll(t, 'Point', 'Input must contain Points'), !e)) throw new Error('breaks is required');
    if (!Array.isArray(e)) throw new Error('breaks must be an Array');
    if (!Qu(i)) throw new Error('commonProperties must be an Object');
    if (!Array.isArray(o)) throw new Error('breaksProperties must be an Array');
    var a = C_(t, { zProperty: r, flip: !0 });
    return ju(j_(D_(a, e, r, i, o), a, t));
  }
  function D_(t, e, n, r, i) {
    for (var o = [], a = 0; a < e.length; a++) {
      var s = +e[a],
        u = L_(L_({}, r), i[a]);
      u[n] = s;
      var l = Fu(i_(t, s, { linearRing: !1, noFrame: !0 }), u);
      o.push(l);
    }
    return o;
  }
  function j_(t, e, n) {
    var r = rc(n),
      i = r[2] - r[0],
      o = r[3] - r[1],
      a = r[0],
      s = r[1],
      u = e[0].length - 1,
      l = e.length - 1,
      c = i / u,
      h = o / l,
      f = R_(function (t) {
        (t[0] = t[0] * c + a), (t[1] = t[1] * h + s);
      }, 'resize');
    return (
      t.forEach(function (t) {
        Ol(t, f);
      }),
      t
    );
  }
  R_(C_, 'gridToMatrix'),
    R_(T_, 'sortPointsByLatLng'),
    R_(A_, 'isolines'),
    R_(D_, 'createIsoLines'),
    R_(j_, 'rescaleIsolines');
  var F_ = Object.defineProperty,
    B_ = oh;
  function q_(t) {
    var e = { type: 'FeatureCollection', features: [] };
    if ('Feature' === t.type && ('Point' === t.geometry.type || 'MultiPoint' === t.geometry.type))
      throw new Error('Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry');
    for (var n = B_(t, !1), r = 0; r < n.length; ++r) {
      var i = n[r];
      e.features.push(Lu([i[0], i[1]]));
    }
    return e;
  }
  !(function (t, e) {
    F_(t, 'name', { value: e, configurable: !0 });
  })(q_, 'kinks');
  var V_ = Object.defineProperty;
  function G_(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return Gl(
      t,
      function (t, n) {
        var r = n.geometry.coordinates;
        return t + _l(r[0], r[1], e);
      },
      0,
    );
  }
  !(function (t, e) {
    V_(t, 'name', { value: e, configurable: !0 });
  })(G_, 'length');
  var Y_ = Object.defineProperty,
    z_ = function (t, e) {
      return Y_(t, 'name', { value: e, configurable: !0 });
    };
  function U_(t, e, n, r) {
    var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {},
      o = i.steps || 64,
      a = X_(n),
      s = X_(r),
      u = Array.isArray(t) || 'Feature' !== t.type ? {} : t.properties;
    if (a === s) return Au(My(t, e, i).geometry.coordinates[0], u);
    for (var l = a, c = a < s ? s : s + 360, h = l, f = [], p = 0, g = (c - l) / o; h <= c; )
      f.push(dl(t, e, h, i).geometry.coordinates), (h = l + ++p * g);
    return Au(f, u);
  }
  function X_(t) {
    var e = t % 360;
    return e < 0 && (e += 360), e;
  }
  z_(U_, 'lineArc'), z_(X_, 'convertAngleTo360');
  var W_ = Object.defineProperty;
  function H_(t, e, n, r) {
    if (!Qu((r = r || {}))) throw new Error('options is invalid');
    var i,
      o = [];
    if ('Feature' === t.type) i = t.geometry.coordinates;
    else {
      if ('LineString' !== t.type) throw new Error('input must be a LineString Feature or Geometry');
      i = t.coordinates;
    }
    for (var a, s, u, l = i.length, c = 0, h = 0; h < i.length && !(e >= c && h === i.length - 1); h++) {
      if (c > e && 0 === o.length) {
        if (!(a = e - c)) return o.push(i[h]), Au(o);
        (s = yl(i[h], i[h - 1]) - 180), (u = dl(i[h], a, s, r)), o.push(u.geometry.coordinates);
      }
      if (c >= n)
        return (a = n - c)
          ? ((s = yl(i[h], i[h - 1]) - 180), (u = dl(i[h], a, s, r)), o.push(u.geometry.coordinates), Au(o))
          : (o.push(i[h]), Au(o));
      if ((c >= e && o.push(i[h]), h === i.length - 1)) return Au(o);
      c += _l(i[h], i[h + 1], r);
    }
    if (c < e && i.length === l) throw new Error('Start position is beyond line');
    var f = i[i.length - 1];
    return Au([f, f]);
  }
  !(function (t, e) {
    W_(t, 'name', { value: e, configurable: !0 });
  })(H_, 'lineSliceAlong');
  var Z_ = Object.defineProperty,
    J_ = function (t, e) {
      return Z_(t, 'name', { value: e, configurable: !0 });
    };
  function $_(t, e, n) {
    if (!Qu((n = n || {}))) throw new Error('options is invalid');
    var r = n.units,
      i = n.reverse;
    if (!t) throw new Error('geojson is required');
    if (e <= 0) throw new Error('segmentLength must be greater than 0');
    var o = [];
    return (
      Bl(t, function (t) {
        i && (t.geometry.coordinates = t.geometry.coordinates.reverse()),
          Q_(t, e, r, function (t) {
            o.push(t);
          });
      }),
      ju(o)
    );
  }
  function Q_(t, e, n, r) {
    var i = G_(t, { units: n });
    if (i <= e) return r(t);
    var o = i / e;
    Number.isInteger(o) || (o = Math.floor(o) + 1);
    for (var a = 0; a < o; a++) {
      r(H_(t, e * a, e * (a + 1), { units: n }), a);
    }
  }
  J_($_, 'lineChunk'), J_(Q_, 'sliceLineSegments');
  var K_ = Object.defineProperty,
    tb = function (t, e) {
      return K_(t, 'name', { value: e, configurable: !0 });
    };
  function eb(t) {
    var e = t[0],
      n = t[1];
    return [n[0] - e[0], n[1] - e[1]];
  }
  function nb(t, e) {
    return t[0] * e[1] - e[0] * t[1];
  }
  function rb(t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  }
  function ib(t, e) {
    return [t[0] - e[0], t[1] - e[1]];
  }
  function ob(t, e) {
    return [t * e[0], t * e[1]];
  }
  function ab(t, e) {
    var n = t[0],
      r = eb(t),
      i = e[0],
      o = eb(e),
      a = nb(r, o);
    return rb(n, ob(nb(ib(i, n), o) / a, r));
  }
  function sb(t, e) {
    return 0 === nb(eb(t), eb(e));
  }
  function ub(t, e) {
    return !sb(t, e) && ab(t, e);
  }
  function lb(t, e, n) {
    if (!Qu((n = n || {}))) throw new Error('options is invalid');
    var r = n.units;
    if (!t) throw new Error('geojson is required');
    if (null == e || isNaN(e)) throw new Error('distance is required');
    var i = hl(t),
      o = t.properties;
    switch (i) {
      case 'LineString':
        return cb(t, e, r);
      case 'MultiLineString':
        var a = [];
        return (
          Bl(t, function (t) {
            a.push(cb(t, e, r).geometry.coordinates);
          }),
          Fu(a, o)
        );
      default:
        throw new Error('geometry ' + i + ' is not supported');
    }
  }
  function cb(t, e, n) {
    var r = [],
      i = Uu(e, n),
      o = ol(t),
      a = [];
    return (
      o.forEach(function (t, e) {
        if (e !== o.length - 1) {
          var n = hb(t, o[e + 1], i);
          if ((r.push(n), e > 0)) {
            var s = r[e - 1],
              u = ub(n, s);
            !1 !== u && ((s[1] = u), (n[0] = u)), a.push(s[0]), e === o.length - 2 && (a.push(n[0]), a.push(n[1]));
          }
          2 === o.length && (a.push(n[0]), a.push(n[1]));
        }
      }),
      Au(a, t.properties)
    );
  }
  function hb(t, e, n) {
    var r = Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])),
      i = t[0] + (n * (e[1] - t[1])) / r,
      o = e[0] + (n * (e[1] - t[1])) / r;
    return [
      [i, t[1] + (n * (t[0] - e[0])) / r],
      [o, e[1] + (n * (t[0] - e[0])) / r],
    ];
  }
  tb(eb, 'ab'),
    tb(nb, 'crossProduct'),
    tb(rb, 'add'),
    tb(ib, 'sub'),
    tb(ob, 'scalarMult'),
    tb(ab, 'intersectSegments'),
    tb(sb, 'isParallel'),
    tb(ub, 'intersection'),
    tb(lb, 'lineOffset'),
    tb(cb, 'lineOffsetFeature'),
    tb(hb, 'processSegment');
  var fb = Object.defineProperty;
  function pb(t, e, n) {
    var r = ol(n);
    if ('LineString' !== hl(n)) throw new Error('line must be a LineString');
    for (
      var i,
        o = Sf(n, t),
        a = Sf(n, e),
        s = [(i = o.properties.index <= a.properties.index ? [o, a] : [a, o])[0].geometry.coordinates],
        u = i[0].properties.index + 1;
      u < i[1].properties.index + 1;
      u++
    )
      s.push(r[u]);
    return s.push(i[1].geometry.coordinates), Au(s, n.properties);
  }
  !(function (t, e) {
    fb(t, 'name', { value: e, configurable: !0 });
  })(pb, 'lineSlice');
  var gb = Object.defineProperty;
  function yb(t) {
    var e = t[0],
      n = t[1],
      r = t[2],
      i = t[3];
    if (_l(t.slice(0, 2), [r, n]) >= _l(t.slice(0, 2), [e, i])) {
      var o = (n + i) / 2;
      return [e, o - (r - e) / 2, r, o + (r - e) / 2];
    }
    var a = (e + r) / 2;
    return [a - (i - n) / 2, n, a + (i - n) / 2, i];
  }
  !(function (t, e) {
    gb(t, 'name', { value: e, configurable: !0 });
  })(yb, 'square');
  var vb = Object.defineProperty,
    db = function (t, e) {
      return vb(t, 'name', { value: e, configurable: !0 });
    };
  function mb(t, e) {
    if (!Qu((e = null != e ? e : {}))) throw new Error('options is invalid');
    var n = e.precision,
      r = e.coordinates,
      i = e.mutate;
    if (((n = null == n || isNaN(n) ? 6 : n), (r = null == r || isNaN(r) ? 3 : r), !t))
      throw new Error('<geojson> is required');
    if ('number' != typeof n) throw new Error('<precision> must be a number');
    if ('number' != typeof r) throw new Error('<coordinates> must be a number');
    (!1 !== i && void 0 !== i) || (t = JSON.parse(JSON.stringify(t)));
    var o = Math.pow(10, n);
    return (
      Ol(t, function (t) {
        _b(t, o, r);
      }),
      t
    );
  }
  function _b(t, e, n) {
    t.length > n && t.splice(n, t.length);
    for (var r = 0; r < t.length; r++) t[r] = Math.round(t[r] * e) / e;
    return t;
  }
  db(mb, 'truncate'), db(_b, 'truncateCoords');
  var bb = Object.defineProperty,
    xb = function (t, e) {
      return bb(t, 'name', { value: e, configurable: !0 });
    };
  function Eb(t, e) {
    if (!t) throw new Error('line is required');
    if (!e) throw new Error('splitter is required');
    var n = hl(t),
      r = hl(e);
    if ('LineString' !== n) throw new Error('line must be LineString');
    if ('FeatureCollection' === r) throw new Error('splitter cannot be a FeatureCollection');
    if ('GeometryCollection' === r) throw new Error('splitter cannot be a GeometryCollection');
    var i = mb(e, { precision: 7 });
    switch (r) {
      case 'Point':
        return kb(t, i);
      case 'MultiPoint':
        return wb(t, i);
      case 'LineString':
      case 'MultiLineString':
      case 'Polygon':
      case 'MultiPolygon':
        return wb(t, uh(t, i, { ignoreSelfIntersections: !0 }));
    }
  }
  function wb(t, e) {
    var n = [],
      r = lf();
    return (
      Bl(e, function (e) {
        if (
          (n.forEach(function (t, e) {
            t.id = e;
          }),
          n.length)
        ) {
          var i = r.search(e);
          if (i.features.length) {
            var o = Sb(e, i);
            (n = n.filter(function (t) {
              return t.id !== o.id;
            })),
              r.remove(o),
              Tl(kb(o, e), function (t) {
                n.push(t), r.insert(t);
              });
          }
        } else
          (n = kb(t, e).features).forEach(function (t) {
            t.bbox || (t.bbox = yb(rc(t)));
          }),
            r.load(ju(n));
      }),
      ju(n)
    );
  }
  function kb(t, e) {
    var n = [],
      r = ol(t)[0],
      i = ol(t)[t.geometry.coordinates.length - 1];
    if (Ib(r, il(e)) || Ib(i, il(e))) return ju([t]);
    var o = lf(),
      a = ff(t);
    o.load(a);
    var s = o.search(e);
    if (!s.features.length) return ju([t]);
    var u = Sb(e, s),
      l = Al(
        a,
        function (t, r, i) {
          var o = ol(r)[1],
            a = il(e);
          return i === u.id ? (t.push(a), n.push(Au(t)), Ib(a, o) ? [a] : [a, o]) : (t.push(o), t);
        },
        [r],
      );
    return l.length > 1 && n.push(Au(l)), ju(n);
  }
  function Sb(t, e) {
    if (!e.features.length) throw new Error('lines must contain features');
    if (1 === e.features.length) return e.features[0];
    var n,
      r = 1 / 0;
    return (
      Tl(e, function (e) {
        var i = Sf(e, t).properties.dist;
        i < r && ((n = e), (r = i));
      }),
      n
    );
  }
  function Ib(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  xb(Eb, 'lineSplit'),
    xb(wb, 'splitLineWithPoints'),
    xb(kb, 'splitLineWithPoint'),
    xb(Sb, 'findClosestFeature'),
    xb(Ib, 'pointsEquals');
  var Pb = Object.defineProperty,
    Nb = function (t, e) {
      return Pb(t, 'name', { value: e, configurable: !0 });
    };
  function Mb(t) {
    var e,
      n,
      r,
      i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      o = i.properties,
      a = null == (e = i.autoComplete) || e,
      s = null == (n = i.orderCoords) || n;
    if (((null != (r = i.mutate) && r) || (t = Ry(t)), 'FeatureCollection' === t.type)) {
      var u = [];
      return (
        t.features.forEach(function (t) {
          u.push(ol(Ob(t, {}, a, s)));
        }),
        qu(u, o)
      );
    }
    return Ob(t, o, a, s);
  }
  function Ob(t, e, n, r) {
    e = e || ('Feature' === t.type ? t.properties : {});
    var i = cl(t),
      o = i.coordinates,
      a = i.type;
    if (!o.length) throw new Error('line must contain coordinates');
    switch (a) {
      case 'LineString':
        return n && (o = Lb(o)), Cu([o], e);
      case 'MultiLineString':
        var s = [],
          u = 0;
        return (
          o.forEach(function (t) {
            if ((n && (t = Lb(t)), r)) {
              var e = Rb(rc(Au(t)));
              e > u ? (s.unshift(t), (u = e)) : s.push(t);
            } else s.push(t);
          }),
          Cu(s, e)
        );
      default:
        throw new Error('geometry type ' + a + ' is not supported');
    }
  }
  function Lb(t) {
    var e = t[0],
      n = e[0],
      r = e[1],
      i = t[t.length - 1],
      o = i[0],
      a = i[1];
    return (n === o && r === a) || t.push(e), t;
  }
  function Rb(t) {
    var e = t[0],
      n = t[1],
      r = t[2],
      i = t[3];
    return Math.abs(e - r) * Math.abs(n - i);
  }
  Nb(Mb, 'lineToPolygon'), Nb(Ob, 'lineStringToPolygon'), Nb(Lb, 'autoCompleteCoords'), Nb(Rb, 'calculateArea');
  var Cb = Object.defineProperty,
    Tb = function (t, e) {
      return Cb(t, 'name', { value: e, configurable: !0 });
    };
  function Ab(t, e) {
    var n = Fb(e);
    return (
      ('FeatureCollection' === t.type ? Db(t) : jb(Ud.union(t.geometry.coordinates))).geometry.coordinates.forEach(
        function (t) {
          n.geometry.coordinates.push(t[0]);
        },
      ),
      n
    );
  }
  function Db(t) {
    var e =
      2 === t.features.length
        ? Ud.union(t.features[0].geometry.coordinates, t.features[1].geometry.coordinates)
        : Ud.union.apply(
            Ud,
            t.features.map(function (t) {
              return t.geometry.coordinates;
            }),
          );
    return jb(e);
  }
  function jb(t) {
    return qu(t);
  }
  function Fb(t) {
    return Cu(
      (t && t.geometry.coordinates) || [
        [
          [180, 90],
          [-180, 90],
          [-180, -90],
          [180, -90],
          [180, 90],
        ],
      ],
    );
  }
  Tb(Ab, 'mask'), Tb(Db, 'unionFc'), Tb(jb, 'createGeomFromPolygonClippingOutput'), Tb(Fb, 'createMask');
  var Bb = Object.defineProperty;
  function qb(t, e) {
    return dl(t, _l(t, e) / 2, yl(t, e));
  }
  !(function (t, e) {
    Bb(t, 'name', { value: e, configurable: !0 });
  })(qb, 'midpoint');
  var Vb = Object.defineProperty,
    Gb = function (t, e) {
      return Vb(t, 'name', { value: e, configurable: !0 });
    };
  function Yb(t, e) {
    var n,
      r,
      i = e.inputField,
      o = e.threshold || 1e5,
      a = e.p || 2,
      s = null != (n = e.binary) && n,
      u = em(t, {
        alpha: e.alpha || -1,
        binary: s,
        p: a,
        standardization: null == (r = e.standardization) || r,
        threshold: o,
      }),
      l = [];
    Tl(t, function (t) {
      var e = t.properties || {};
      l.push(e[i]);
    });
    for (var c = zb(l), h = Ub(l), f = 0, p = 0, g = 0, y = 0, v = u.length, d = 0; d < v; d++) {
      for (var m = 0, _ = 0; _ < v; _++)
        (f += u[d][_] * (l[d] - c) * (l[_] - c)),
          (p += u[d][_]),
          (g += Math.pow(u[d][_] + u[_][d], 2)),
          (m += u[d][_] + u[_][d]);
      y += Math.pow(m, 2);
    }
    var b = f / p / h,
      x = -1 / (v - 1),
      E = (v * v * (g *= 0.5) - v * y + p * p * 3) / ((v - 1) * (v + 1) * (p * p)) - x * x,
      w = Math.sqrt(E);
    return { expectedMoranIndex: x, moranIndex: b, stdNorm: w, zNorm: (b - x) / w };
  }
  function zb(t) {
    var e,
      n = 0,
      r = c(t);
    try {
      for (r.s(); !(e = r.n()).done; ) {
        n += e.value;
      }
    } catch (t) {
      r.e(t);
    } finally {
      r.f();
    }
    return n / t.length;
  }
  function Ub(t) {
    var e,
      n = zb(t),
      r = 0,
      i = c(t);
    try {
      for (i.s(); !(e = i.n()).done; ) {
        var o = e.value;
        r += Math.pow(o - n, 2);
      }
    } catch (t) {
      i.e(t);
    } finally {
      i.f();
    }
    return r / t.length;
  }
  Gb(Yb, 'moranIndex'), Gb(zb, 'mean'), Gb(Ub, 'variance');
  var Xb = Object.defineProperty,
    Wb = Object.defineProperties,
    Hb = Object.getOwnPropertyDescriptors,
    Zb = Object.getOwnPropertySymbols,
    Jb = Object.prototype.hasOwnProperty,
    $b = Object.prototype.propertyIsEnumerable,
    Qb = function (t, e, n) {
      return e in t ? Xb(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n);
    },
    Kb = function (t, e) {
      for (var n in e || (e = {})) Jb.call(e, n) && Qb(t, n, e[n]);
      if (Zb) {
        var r,
          i = c(Zb(e));
        try {
          for (i.s(); !(r = i.n()).done; ) {
            n = r.value;
            $b.call(e, n) && Qb(t, n, e[n]);
          }
        } catch (t) {
          i.e(t);
        } finally {
          i.f();
        }
      }
      return t;
    },
    tx = function (t, e) {
      return Wb(t, Hb(e));
    };
  function ex(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (!t) throw new Error('targetPoint is required');
    if (!e) throw new Error('points is required');
    var r = 1 / 0,
      i = 0;
    Tl(e, function (e, o) {
      var a = _l(t, e, n);
      a < r && ((i = o), (r = a));
    });
    var o = Ry(e.features[i]);
    return tx(Kb({}, o), { properties: tx(Kb({}, o.properties), { featureIndex: i, distanceToPoint: r }) });
  }
  !(function (t, e) {
    Xb(t, 'name', { value: e, configurable: !0 });
  })(ex, 'nearestPoint');
  var nx = Object.defineProperty;
  function rx(t, e) {
    var n = (e = e || {}).studyArea || pc(rc(t)),
      r = e.properties || {},
      i = e.units || 'kilometers',
      o = [];
    Tl(t, function (t) {
      o.push(Ug(t));
    });
    var a = o.length,
      s =
        o
          .map(function (t, e) {
            return _l(
              t,
              ex(
                t,
                ju(
                  o.filter(function (t, n) {
                    return n !== e;
                  }),
                ),
              ).geometry.coordinates,
              { units: i },
            );
          })
          .reduce(function (t, e) {
            return t + e;
          }, 0) / a,
      u = a / Ju(Jl(n), 'meters', i),
      l = 1 / (2 * Math.sqrt(u)),
      c = 0.26136 / Math.sqrt(a * u);
    return (
      (r.nearestNeighborAnalysis = {
        units: i,
        arealUnits: i + '²',
        observedMeanDistance: s,
        expectedMeanDistance: l,
        nearestNeighborIndex: s / l,
        numberOfPoints: a,
        zScore: (s - l) / c,
      }),
      (n.properties = r),
      n
    );
  }
  !(function (t, e) {
    nx(t, 'name', { value: e, configurable: !0 });
  })(rx, 'nearestNeighborAnalysis');
  var ix = Object.defineProperty,
    ox = function (t, e) {
      return ix(t, 'name', { value: e, configurable: !0 });
    };
  function ax(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if ((n.method || (n.method = 'geodesic'), n.units || (n.units = 'kilometers'), !t))
      throw new Error('pt is required');
    if ((Array.isArray(t) ? (t = Lu(t)) : 'Point' === t.type ? (t = Mu(t)) : ul(t, 'Point', 'point'), !e))
      throw new Error('line is required');
    Array.isArray(e) ? (e = Au(e)) : 'LineString' === e.type ? (e = Mu(e)) : ul(e, 'LineString', 'line');
    var r = 1 / 0,
      i = t.geometry.coordinates;
    return (
      Vl(e, function (t) {
        var e = t.geometry.coordinates[0],
          o = t.geometry.coordinates[1],
          a = sx(i, e, o, n);
        a < r && (r = a);
      }),
      Zu(r, 'degrees', n.units)
    );
  }
  function sx(t, e, n, r) {
    var i = [n[0] - e[0], n[1] - e[1]],
      o = ux([t[0] - e[0], t[1] - e[1]], i);
    if (o <= 0) return lx(t, e, { method: r.method, units: 'degrees' });
    var a = ux(i, i);
    if (a <= o) return lx(t, n, { method: r.method, units: 'degrees' });
    var s = o / a;
    return lx(t, [e[0] + s * i[0], e[1] + s * i[1]], { method: r.method, units: 'degrees' });
  }
  function ux(t, e) {
    return t[0] * e[0] + t[1] * e[1];
  }
  function lx(t, e, n) {
    return 'planar' === n.method ? um(t, e, n) : _l(t, e, n);
  }
  ox(ax, 'pointToLineDistance'), ox(sx, 'distanceToSegment'), ox(ux, 'dot'), ox(lx, 'calcDistance');
  var cx = Object.defineProperty,
    hx = Object.getOwnPropertySymbols,
    fx = Object.prototype.hasOwnProperty,
    px = Object.prototype.propertyIsEnumerable,
    gx = function (t, e, n) {
      return e in t ? cx(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : (t[e] = n);
    },
    yx = function (t, e) {
      for (var n in e || (e = {})) fx.call(e, n) && gx(t, n, e[n]);
      if (hx) {
        var r,
          i = c(hx(e));
        try {
          for (i.s(); !(r = i.n()).done; ) {
            n = r.value;
            px.call(e, n) && gx(t, n, e[n]);
          }
        } catch (t) {
          i.e(t);
        } finally {
          i.f();
        }
      }
      return t;
    },
    vx = function (t, e) {
      return cx(t, 'name', { value: e, configurable: !0 });
    };
  function dx(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      r = n.units,
      i = n.properties || {},
      o = mx(t);
    if (!o.features.length) throw new Error('points must contain features');
    if (!e) throw new Error('line is required');
    if ('LineString' !== hl(e)) throw new Error('line must be a LineString');
    var a = 1 / 0,
      s = null;
    return (
      Tl(o, function (t) {
        var n = ax(t, e, { units: r });
        n < a && ((a = n), (s = t));
      }),
      s && (s.properties = yx(yx(yx({}, { dist: a }), s.properties), i)),
      s
    );
  }
  function mx(t) {
    var e = [];
    switch (t.geometry ? t.geometry.type : t.type) {
      case 'GeometryCollection':
        return (
          jl(t, function (t) {
            'Point' === t.type && e.push({ type: 'Feature', properties: {}, geometry: t });
          }),
          { type: 'FeatureCollection', features: e }
        );
      case 'FeatureCollection':
        return (
          (t.features = t.features.filter(function (t) {
            return 'Point' === t.geometry.type;
          })),
          t
        );
      default:
        throw new Error('points must be a Point Collection');
    }
  }
  vx(dx, 'nearestPointToLine'), vx(mx, 'normalize');
  var _x = Object.defineProperty;
  function bx(t, e) {
    var n = il(t),
      r = cl(e).coordinates[0];
    if (r.length < 4) throw new Error('OuterRing of a Polygon must have 4 or more Positions.');
    var i = e.properties || {},
      o = i.a,
      a = i.b,
      s = i.c,
      u = n[0],
      l = n[1],
      c = r[0][0],
      h = r[0][1],
      f = void 0 !== o ? o : r[0][2],
      p = r[1][0],
      g = r[1][1],
      y = void 0 !== a ? a : r[1][2],
      v = r[2][0],
      d = r[2][1],
      m = void 0 !== s ? s : r[2][2];
    return (
      (m * (u - c) * (l - g) +
        f * (u - p) * (l - d) +
        y * (u - v) * (l - h) -
        y * (u - c) * (l - d) -
        m * (u - p) * (l - h) -
        f * (u - v) * (l - g)) /
      ((u - c) * (l - g) +
        (u - p) * (l - d) +
        (u - v) * (l - h) -
        (u - c) * (l - d) -
        (u - p) * (l - h) -
        (u - v) * (l - g))
    );
  }
  !(function (t, e) {
    _x(t, 'name', { value: e, configurable: !0 });
  })(bx, 'planepoint');
  var xx = Object.defineProperty,
    Ex = function (t, e) {
      return xx(t, 'name', { value: e, configurable: !0 });
    };
  function wx(t) {
    for (var e = kx(t), n = up(e), r = !1, i = 0; !r && i < e.features.length; ) {
      var o = e.features[i].geometry,
        a = !1;
      if ('Point' === o.type)
        n.geometry.coordinates[0] === o.coordinates[0] && n.geometry.coordinates[1] === o.coordinates[1] && (r = !0);
      else if ('MultiPoint' === o.type)
        for (var s = !1, u = 0; !s && u < o.coordinates.length; )
          n.geometry.coordinates[0] === o.coordinates[u][0] &&
            n.geometry.coordinates[1] === o.coordinates[u][1] &&
            ((r = !0), (s = !0)),
            u++;
      else if ('LineString' === o.type)
        for (var l = 0; !a && l < o.coordinates.length - 1; )
          Sx(
            n.geometry.coordinates[0],
            n.geometry.coordinates[1],
            o.coordinates[l][0],
            o.coordinates[l][1],
            o.coordinates[l + 1][0],
            o.coordinates[l + 1][1],
          ) && ((a = !0), (r = !0)),
            l++;
      else if ('MultiLineString' === o.type)
        for (var c = 0; c < o.coordinates.length; ) {
          a = !1;
          for (var h = 0, f = o.coordinates[c]; !a && h < f.length - 1; )
            Sx(n.geometry.coordinates[0], n.geometry.coordinates[1], f[h][0], f[h][1], f[h + 1][0], f[h + 1][1]) &&
              ((a = !0), (r = !0)),
              h++;
          c++;
        }
      else ('Polygon' !== o.type && 'MultiPolygon' !== o.type) || (Nc(n, o) && (r = !0));
      i++;
    }
    if (r) return n;
    for (var p = ju([]), g = 0; g < e.features.length; g++) p.features = p.features.concat(_m(e.features[g]).features);
    return Lu(ex(n, p).geometry.coordinates);
  }
  function kx(t) {
    return 'FeatureCollection' !== t.type ? ('Feature' !== t.type ? ju([Mu(t)]) : ju([t])) : t;
  }
  function Sx(t, e, n, r, i, o) {
    return (
      Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)) ===
      Math.sqrt((t - n) * (t - n) + (e - r) * (e - r)) + Math.sqrt((i - t) * (i - t) + (o - e) * (o - e))
    );
  }
  Ex(wx, 'pointOnFeature'), Ex(kx, 'normalize'), Ex(Sx, 'pointOnSegment');
  var Ix = Object.defineProperty;
  function Px(t, e) {
    var n = [];
    return (
      Tl(t, function (t) {
        var r = !1;
        if ('Point' === t.geometry.type)
          jl(e, function (e) {
            Nc(t, e) && (r = !0);
          }),
            r && n.push(t);
        else {
          if ('MultiPoint' !== t.geometry.type) throw new Error('Input geometry must be a Point or MultiPoint');
          var i = [];
          jl(e, function (e) {
            Ol(t, function (t) {
              Nc(t, e) && ((r = !0), i.push(t));
            });
          }),
            r && n.push(Bu(i, t.properties));
        }
      }),
      ju(n)
    );
  }
  !(function (t, e) {
    Ix(t, 'name', { value: e, configurable: !0 });
  })(Px, 'pointsWithinPolygon');
  var Nx = Object.defineProperty,
    Mx = function (t, e) {
      return Nx(t, 'name', { value: e, configurable: !0 });
    };
  function Ox(t) {
    return (t > 0) - (t < 0) || +t;
  }
  function Lx(t, e, n) {
    var r = e[0] - t[0],
      i = e[1] - t[1],
      o = n[0] - e[0];
    return Ox(r * (n[1] - e[1]) - o * i);
  }
  function Rx(t, e) {
    var n = t.geometry.coordinates[0].map(function (t) {
        return t[0];
      }),
      r = t.geometry.coordinates[0].map(function (t) {
        return t[1];
      }),
      i = e.geometry.coordinates[0].map(function (t) {
        return t[0];
      }),
      o = e.geometry.coordinates[0].map(function (t) {
        return t[1];
      });
    return (
      Math.max.apply(null, n) === Math.max.apply(null, i) &&
      Math.max.apply(null, r) === Math.max.apply(null, o) &&
      Math.min.apply(null, n) === Math.min.apply(null, i) &&
      Math.min.apply(null, r) === Math.min.apply(null, o)
    );
  }
  function Cx(t, e) {
    return e.geometry.coordinates[0].every(function (e) {
      return Nc(Lu(e), t);
    });
  }
  function Tx(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  Mx(Ox, 'mathSign'),
    Mx(Lx, 'orientationIndex'),
    Mx(Rx, 'envelopeIsEqual'),
    Mx(Cx, 'envelopeContains'),
    Mx(Tx, 'coordinatesEqual');
  var Ax = (function () {
    function t(e) {
      n(this, t),
        (this.id = t.buildId(e)),
        (this.coordinates = e),
        (this.innerEdges = []),
        (this.outerEdges = []),
        (this.outerEdgesSorted = !1);
    }
    return (
      i(
        t,
        [
          {
            key: 'removeInnerEdge',
            value: function (t) {
              this.innerEdges = this.innerEdges.filter(function (e) {
                return e.from.id !== t.from.id;
              });
            },
          },
          {
            key: 'removeOuterEdge',
            value: function (t) {
              this.outerEdges = this.outerEdges.filter(function (e) {
                return e.to.id !== t.to.id;
              });
            },
          },
          {
            key: 'addOuterEdge',
            value: function (t) {
              this.outerEdges.push(t), (this.outerEdgesSorted = !1);
            },
          },
          {
            key: 'sortOuterEdges',
            value: function () {
              var t = this;
              this.outerEdgesSorted ||
                (this.outerEdges.sort(function (e, n) {
                  var r = e.to,
                    i = n.to;
                  if (r.coordinates[0] - t.coordinates[0] >= 0 && i.coordinates[0] - t.coordinates[0] < 0) return 1;
                  if (r.coordinates[0] - t.coordinates[0] < 0 && i.coordinates[0] - t.coordinates[0] >= 0) return -1;
                  if (r.coordinates[0] - t.coordinates[0] == 0 && i.coordinates[0] - t.coordinates[0] == 0)
                    return r.coordinates[1] - t.coordinates[1] >= 0 || i.coordinates[1] - t.coordinates[1] >= 0
                      ? r.coordinates[1] - i.coordinates[1]
                      : i.coordinates[1] - r.coordinates[1];
                  var o = Lx(t.coordinates, r.coordinates, i.coordinates);
                  return o < 0
                    ? 1
                    : o > 0
                    ? -1
                    : Math.pow(r.coordinates[0] - t.coordinates[0], 2) +
                      Math.pow(r.coordinates[1] - t.coordinates[1], 2) -
                      (Math.pow(i.coordinates[0] - t.coordinates[0], 2) +
                        Math.pow(i.coordinates[1] - t.coordinates[1], 2));
                }),
                (this.outerEdgesSorted = !0));
            },
          },
          {
            key: 'getOuterEdges',
            value: function () {
              return this.sortOuterEdges(), this.outerEdges;
            },
          },
          {
            key: 'getOuterEdge',
            value: function (t) {
              return this.sortOuterEdges(), this.outerEdges[t];
            },
          },
          {
            key: 'addInnerEdge',
            value: function (t) {
              this.innerEdges.push(t);
            },
          },
        ],
        [
          {
            key: 'buildId',
            value: function (t) {
              return t.join(',');
            },
          },
        ],
      ),
      t
    );
  })();
  Mx(Ax, 'Node');
  var Dx = Ax,
    jx = (function () {
      function t(e, r) {
        n(this, t),
          (this.from = e),
          (this.to = r),
          (this.next = void 0),
          (this.label = void 0),
          (this.symetric = void 0),
          (this.ring = void 0),
          this.from.addOuterEdge(this),
          this.to.addInnerEdge(this);
      }
      return (
        i(t, [
          {
            key: 'getSymetric',
            value: function () {
              return (
                this.symetric || ((this.symetric = new t(this.to, this.from)), (this.symetric.symetric = this)),
                this.symetric
              );
            },
          },
          {
            key: 'deleteEdge',
            value: function () {
              this.from.removeOuterEdge(this), this.to.removeInnerEdge(this);
            },
          },
          {
            key: 'isEqual',
            value: function (t) {
              return this.from.id === t.from.id && this.to.id === t.to.id;
            },
          },
          {
            key: 'toString',
            value: function () {
              return 'Edge { '.concat(this.from.id, ' -> ').concat(this.to.id, ' }');
            },
          },
          {
            key: 'toLineString',
            value: function () {
              return Au([this.from.coordinates, this.to.coordinates]);
            },
          },
          {
            key: 'compareTo',
            value: function (t) {
              return Lx(t.from.coordinates, t.to.coordinates, this.to.coordinates);
            },
          },
        ]),
        t
      );
    })();
  Mx(jx, 'Edge');
  var Fx = jx,
    Bx = (function () {
      function t() {
        n(this, t), (this.edges = []), (this.polygon = void 0), (this.envelope = void 0);
      }
      return (
        i(
          t,
          [
            {
              key: 'push',
              value: function (t) {
                this.edges.push(t), (this.polygon = this.envelope = void 0);
              },
            },
            {
              key: 'get',
              value: function (t) {
                return this.edges[t];
              },
            },
            {
              key: 'length',
              get: function () {
                return this.edges.length;
              },
            },
            {
              key: 'forEach',
              value: function (t) {
                this.edges.forEach(t);
              },
            },
            {
              key: 'map',
              value: function (t) {
                return this.edges.map(t);
              },
            },
            {
              key: 'some',
              value: function (t) {
                return this.edges.some(t);
              },
            },
            {
              key: 'isValid',
              value: function () {
                return !0;
              },
            },
            {
              key: 'isHole',
              value: function () {
                var t = this,
                  e = this.edges.reduce(function (e, n, r) {
                    return n.from.coordinates[1] > t.edges[e].from.coordinates[1] && (e = r), e;
                  }, 0),
                  n = (0 === e ? this.length : e) - 1,
                  r = (e + 1) % this.length,
                  i = Lx(
                    this.edges[n].from.coordinates,
                    this.edges[e].from.coordinates,
                    this.edges[r].from.coordinates,
                  );
                return 0 === i ? this.edges[n].from.coordinates[0] > this.edges[r].from.coordinates[0] : i > 0;
              },
            },
            {
              key: 'toMultiPoint',
              value: function () {
                return Bu(
                  this.edges.map(function (t) {
                    return t.from.coordinates;
                  }),
                );
              },
            },
            {
              key: 'toPolygon',
              value: function () {
                if (this.polygon) return this.polygon;
                var t = this.edges.map(function (t) {
                  return t.from.coordinates;
                });
                return t.push(this.edges[0].from.coordinates), (this.polygon = Cu([t]));
              },
            },
            {
              key: 'getEnvelope',
              value: function () {
                return this.envelope ? this.envelope : (this.envelope = dm(this.toPolygon()));
              },
            },
            {
              key: 'inside',
              value: function (t) {
                return Nc(t, this.toPolygon());
              },
            },
          ],
          [
            {
              key: 'findEdgeRingContaining',
              value: function (t, e) {
                var n,
                  r,
                  i = t.getEnvelope();
                return (
                  e.forEach(function (e) {
                    var o = e.getEnvelope();
                    if ((r && (n = r.getEnvelope()), !Rx(o, i) && Cx(o, i))) {
                      var a,
                        s,
                        u = c(
                          t.map(function (t) {
                            return t.from.coordinates;
                          }),
                        );
                      try {
                        var l = function () {
                          var t = s.value;
                          e.some(function (e) {
                            return Tx(t, e.from.coordinates);
                          }) || (a = t);
                        };
                        for (u.s(); !(s = u.n()).done; ) l();
                      } catch (t) {
                        u.e(t);
                      } finally {
                        u.f();
                      }
                      a && e.inside(Lu(a)) && ((r && !Cx(n, o)) || (r = e));
                    }
                  }),
                  r
                );
              },
            },
          ],
        ),
        t
      );
    })();
  Mx(Bx, 'EdgeRing');
  var qx = Bx;
  function Vx(t) {
    if (!t) throw new Error('No geojson passed');
    if (
      'FeatureCollection' !== t.type &&
      'GeometryCollection' !== t.type &&
      'MultiLineString' !== t.type &&
      'LineString' !== t.type &&
      'Feature' !== t.type
    )
      throw new Error(
        "Invalid input type '".concat(
          t.type,
          "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature",
        ),
      );
  }
  Mx(Vx, 'validateGeoJson');
  var Gx = (function () {
    function t() {
      n(this, t), (this.edges = []), (this.nodes = {});
    }
    return (
      i(
        t,
        [
          {
            key: 'getNode',
            value: function (t) {
              var e = Dx.buildId(t),
                n = this.nodes[e];
              return n || (n = this.nodes[e] = new Dx(t)), n;
            },
          },
          {
            key: 'addEdge',
            value: function (t, e) {
              var n = new Fx(t, e),
                r = n.getSymetric();
              this.edges.push(n), this.edges.push(r);
            },
          },
          {
            key: 'deleteDangles',
            value: function () {
              var t = this;
              Object.keys(this.nodes)
                .map(function (e) {
                  return t.nodes[e];
                })
                .forEach(function (e) {
                  return t._removeIfDangle(e);
                });
            },
          },
          {
            key: '_removeIfDangle',
            value: function (t) {
              var e = this;
              if (t.innerEdges.length <= 1) {
                var n = t.getOuterEdges().map(function (t) {
                  return t.to;
                });
                this.removeNode(t),
                  n.forEach(function (t) {
                    return e._removeIfDangle(t);
                  });
              }
            },
          },
          {
            key: 'deleteCutEdges',
            value: function () {
              var t = this;
              this._computeNextCWEdges(),
                this._findLabeledEdgeRings(),
                this.edges.forEach(function (e) {
                  e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e));
                });
            },
          },
          {
            key: '_computeNextCWEdges',
            value: function (t) {
              var e = this;
              void 0 === t
                ? Object.keys(this.nodes).forEach(function (t) {
                    return e._computeNextCWEdges(e.nodes[t]);
                  })
                : t.getOuterEdges().forEach(function (e, n) {
                    t.getOuterEdge((0 === n ? t.getOuterEdges().length : n) - 1).symetric.next = e;
                  });
            },
          },
          {
            key: '_computeNextCCWEdges',
            value: function (t, e) {
              for (var n, r, i = t.getOuterEdges(), o = i.length - 1; o >= 0; --o) {
                var a = i[o],
                  s = a.symetric,
                  u = void 0,
                  l = void 0;
                a.label === e && (u = a),
                  s.label === e && (l = s),
                  u && l && (l && (r = l), u && (r && ((r.next = u), (r = void 0)), n || (n = u)));
              }
              r && (r.next = n);
            },
          },
          {
            key: '_findLabeledEdgeRings',
            value: function () {
              var t = [],
                e = 0;
              return (
                this.edges.forEach(function (n) {
                  if (!(n.label >= 0)) {
                    t.push(n);
                    var r = n;
                    do {
                      (r.label = e), (r = r.next);
                    } while (!n.isEqual(r));
                    e++;
                  }
                }),
                t
              );
            },
          },
          {
            key: 'getEdgeRings',
            value: function () {
              var t = this;
              this._computeNextCWEdges(),
                this.edges.forEach(function (t) {
                  t.label = void 0;
                }),
                this._findLabeledEdgeRings().forEach(function (e) {
                  t._findIntersectionNodes(e).forEach(function (n) {
                    t._computeNextCCWEdges(n, e.label);
                  });
                });
              var e = [];
              return (
                this.edges.forEach(function (n) {
                  n.ring || e.push(t._findEdgeRing(n));
                }),
                e
              );
            },
          },
          {
            key: '_findIntersectionNodes',
            value: function (t) {
              var e = [],
                n = t,
                r = function () {
                  var r = 0;
                  n.from.getOuterEdges().forEach(function (e) {
                    e.label === t.label && ++r;
                  }),
                    r > 1 && e.push(n.from),
                    (n = n.next);
                };
              do {
                r();
              } while (!t.isEqual(n));
              return e;
            },
          },
          {
            key: '_findEdgeRing',
            value: function (t) {
              var e = t,
                n = new qx();
              do {
                n.push(e), (e.ring = n), (e = e.next);
              } while (!t.isEqual(e));
              return n;
            },
          },
          {
            key: 'removeNode',
            value: function (t) {
              var e = this;
              t.getOuterEdges().forEach(function (t) {
                return e.removeEdge(t);
              }),
                t.innerEdges.forEach(function (t) {
                  return e.removeEdge(t);
                }),
                delete this.nodes[t.id];
            },
          },
          {
            key: 'removeEdge',
            value: function (t) {
              (this.edges = this.edges.filter(function (e) {
                return !e.isEqual(t);
              })),
                t.deleteEdge();
            },
          },
        ],
        [
          {
            key: 'fromGeoJson',
            value: function (e) {
              Vx(e);
              var n = new t();
              return (
                Bl(e, function (t) {
                  ul(t, 'LineString', 'Graph::fromGeoJson'),
                    Ll(t, function (t, e) {
                      if (t) {
                        var r = n.getNode(t),
                          i = n.getNode(e);
                        n.addEdge(r, i);
                      }
                      return e;
                    });
                }),
                n
              );
            },
          },
        ],
      ),
      t
    );
  })();
  Mx(Gx, 'Graph');
  var Yx = Gx;
  function zx(t) {
    var e = Yx.fromGeoJson(t);
    e.deleteDangles(), e.deleteCutEdges();
    var n = [],
      r = [];
    return (
      e
        .getEdgeRings()
        .filter(function (t) {
          return t.isValid();
        })
        .forEach(function (t) {
          t.isHole() ? n.push(t) : r.push(t);
        }),
      n.forEach(function (t) {
        qx.findEdgeRingContaining(t, r) && r.push(t);
      }),
      ju(
        r.map(function (t) {
          return t.toPolygon();
        }),
      )
    );
  }
  Mx(zx, 'polygonize');
  var Ux = Object.defineProperty,
    Xx = function (t, e) {
      return Ux(t, 'name', { value: e, configurable: !0 });
    };
  function Wx(t, e) {
    (e = e || {}).iterations = e.iterations || 1;
    var n = e.iterations,
      r = [];
    if (!t) throw new Error('inputPolys is required');
    return (
      jl(t, function (t, e, i) {
        if ('Polygon' === t.type) {
          for (var o = [[]], a = 0; a < n; a++) {
            var s = [],
              u = t;
            a > 0 && (u = Cu(o).geometry), Hx(u, s), (o = s.slice(0));
          }
          r.push(Cu(o, i));
        } else {
          if ('MultiPolygon' !== t.type) throw new Error('geometry is invalid, must be Polygon or MultiPolygon');
          for (var l = [[[]]], c = 0; c < n; c++) {
            var h = [],
              f = t;
            c > 0 && (f = qu(l).geometry), Zx(f, h), (l = h.slice(0));
          }
          r.push(qu(l, i));
        }
      }),
      ju(r)
    );
  }
  function Hx(t, e) {
    var n, r;
    Ol(
      t,
      function (t, i, o, a, s) {
        if (r !== s) e.push([]);
        else {
          var u = n[0],
            l = n[1],
            c = t[0],
            h = t[1];
          e[s].push([0.75 * u + 0.25 * c, 0.75 * l + 0.25 * h]), e[s].push([0.25 * u + 0.75 * c, 0.25 * l + 0.75 * h]);
        }
        (n = t), (r = s);
      },
      !1,
    ),
      e.forEach(function (t) {
        t.push(t[0]);
      });
  }
  function Zx(t, e) {
    var n, r, i;
    Ol(
      t,
      function (t, o, a, s, u) {
        if (r !== s) e.push([[]]);
        else if (i !== u) e[s].push([]);
        else {
          var l = n[0],
            c = n[1],
            h = t[0],
            f = t[1];
          e[s][u].push([0.75 * l + 0.25 * h, 0.75 * c + 0.25 * f]),
            e[s][u].push([0.25 * l + 0.75 * h, 0.25 * c + 0.75 * f]);
        }
        (n = t), (r = s), (i = u);
      },
      !1,
    ),
      e.forEach(function (t) {
        t.forEach(function (t) {
          t.push(t[0]);
        });
      });
  }
  Xx(Wx, 'polygonSmooth'), Xx(Hx, 'processPolygon'), Xx(Zx, 'processMultiPolygon');
  var Jx = Object.defineProperty,
    $x = function (t, e) {
      return Jx(t, 'name', { value: e, configurable: !0 });
    };
  function Qx(t, e) {
    var n,
      r = ol(t),
      i = ol(e),
      o = [],
      s = [],
      u = rc(e),
      l = 0,
      c = null;
    switch (
      (r[0] > u[0] && r[0] < u[2] && r[1] > u[1] && r[1] < u[3] && (l = (c = ex(t, _m(e))).properties.featureIndex),
      hl(e))
    ) {
      case 'Polygon':
        (o = i[0][l]),
          (s = i[0][0]),
          null !== c && c.geometry.coordinates[1] < r[1] && (s = i[0][l]),
          (n = nE(i[0][0], i[0][i[0].length - 1], r));
        var h = a(Kx(i[0], r, n, o, s), 2);
        (o = h[0]), (s = h[1]);
        break;
      case 'MultiPolygon':
        for (var f = 0, p = 0, g = 0, y = 0; y < i[0].length; y++) {
          f = y;
          for (var v = !1, d = 0; d < i[0][y].length; d++) {
            if (((p = d), g === l)) {
              v = !0;
              break;
            }
            g++;
          }
          if (v) break;
        }
        (o = i[0][f][p]),
          (s = i[0][f][p]),
          (n = nE(i[0][0][0], i[0][0][i[0][0].length - 1], r)),
          i.forEach(function (t) {
            var e = a(Kx(t[0], r, n, o, s), 2);
            (o = e[0]), (s = e[1]);
          });
    }
    return ju([Lu(o), Lu(s)]);
  }
  function Kx(t, e, n, r, i) {
    for (var o = 0; o < t.length; o++) {
      var a = t[o],
        s = t[o + 1];
      o === t.length - 1 && (s = t[0]);
      var u = nE(a, s, e);
      n <= 0 && u > 0 ? eE(e, a, r) || (r = a) : n > 0 && u <= 0 && (tE(e, a, i) || (i = a)), (n = u);
    }
    return [r, i];
  }
  function tE(t, e, n) {
    return nE(t, e, n) > 0;
  }
  function eE(t, e, n) {
    return nE(t, e, n) < 0;
  }
  function nE(t, e, n) {
    return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1]);
  }
  $x(Qx, 'polygonTangents'), $x(Kx, 'processPolygon'), $x(tE, 'isAbove'), $x(eE, 'isBelow'), $x(nE, 'isLeft');
  var rE = Object.defineProperty,
    iE = function (t, e) {
      return rE(t, 'name', { value: e, configurable: !0 });
    };
  function oE(t) {
    return sE(t, 'mercator', arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {});
  }
  function aE(t) {
    return sE(t, 'wgs84', arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {});
  }
  function sE(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      r = (n = n || {}).mutate;
    if (!t) throw new Error('geojson is required');
    return (
      Array.isArray(t) && $u(t[0])
        ? (t = 'mercator' === e ? uE(t) : lE(t))
        : (!0 !== r && (t = Ry(t)),
          Ol(t, function (t) {
            var n = 'mercator' === e ? uE(t) : lE(t);
            (t[0] = n[0]), (t[1] = n[1]);
          })),
      t
    );
  }
  function uE(t) {
    var e = Math.PI / 180,
      n = 6378137,
      r = 20037508.342789244,
      i = [
        n * (Math.abs(t[0]) <= 180 ? t[0] : t[0] - 360 * cE(t[0])) * e,
        n * Math.log(Math.tan(0.25 * Math.PI + 0.5 * t[1] * e)),
      ];
    return i[0] > r && (i[0] = r), i[0] < -r && (i[0] = -r), i[1] > r && (i[1] = r), i[1] < -r && (i[1] = -r), i;
  }
  function lE(t) {
    var e = 180 / Math.PI,
      n = 6378137;
    return [(t[0] * e) / n, (0.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / n))) * e];
  }
  function cE(t) {
    return t < 0 ? -1 : t > 0 ? 1 : 0;
  }
  iE(oE, 'toMercator'),
    iE(aE, 'toWgs84'),
    iE(sE, 'convert'),
    iE(uE, 'convertToMercator'),
    iE(lE, 'convertToWgs84'),
    iE(cE, 'sign');
  var hE = Object.freeze({ __proto__: null, toMercator: oE, toWgs84: aE }),
    fE = Object.defineProperty,
    pE = function (t, e) {
      return fE(t, 'name', { value: e, configurable: !0 });
    };
  function gE(t, e) {
    for (
      var n = (e = e || {}).studyBbox || rc(t),
        r = e.confidenceLevel || 20,
        i = t.features,
        o = i.length,
        a = Jl(pc(n)),
        s = Ym(n, Math.sqrt((a / o) * 2), { units: 'meters' }).features,
        u = {},
        l = 0;
      l < s.length;
      l++
    )
      u[l] = { box: rc(s[l]), cnt: 0 };
    var h,
      f = 0,
      p = c(i);
    try {
      for (p.s(); !(h = p.n()).done; )
        for (var g = h.value, y = 0, v = Object.keys(u); y < v.length; y++) {
          var d = v[y],
            m = u[d].box;
          if (vE(il(g), m)) {
            (u[d].cnt += 1), (f += 1);
            break;
          }
        }
    } catch (t) {
      p.e(t);
    } finally {
      p.f();
    }
    for (var _ = 0, b = 0, x = Object.keys(u); b < x.length; b++) {
      var E = u[x[b]].cnt;
      E > _ && (_ = E);
    }
    for (var w = [], k = Object.keys(u).length, S = f / k, I = 0, P = 0; P < _ + 1; P++)
      (I += (Math.exp(-S) * Math.pow(S, P)) / dE(P)), w.push(I);
    for (var N = [], M = 0, O = 0; O < _ + 1; O++) {
      for (var L = 0, R = Object.keys(u); L < R.length; L++) {
        u[R[L]].cnt === O && (M += 1);
      }
      var C = M / k;
      N.push(C);
    }
    for (var T = 0, A = 0; A < _ + 1; A++) {
      var D = Math.abs(w[A] - N[A]);
      D > T && (T = D);
    }
    var j = yE[r] / Math.sqrt(k),
      F = { criticalValue: j, isRandom: !0, maxAbsoluteDifference: T, observedDistribution: N };
    return T > j && (F.isRandom = !1), F;
  }
  pE(gE, 'quadratAnalysis');
  var yE = { 20: 1.07275, 15: 1.13795, 10: 1.22385, 5: 1.3581, 2: 1.51743, 1: 1.62762 };
  function vE(t, e) {
    return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1];
  }
  function dE(t) {
    var e = [];
    function n(t) {
      return 0 === t || 1 === t ? 1 : e[t] > 0 ? e[t] : (e[t] = n(t - 1) * t);
    }
    return pE(n, 'inner'), n(t);
  }
  pE(vE, 'inBBox'), pE(dE, 'factorial');
  var mE = Object.defineProperty,
    _E = function (t, e) {
      return mE(t, 'name', { value: e, configurable: !0 });
    };
  function bE(t) {
    return EE(t), xE(t);
  }
  function xE(t) {
    return Array.isArray(t) ? OE(t) : t && t.bbox ? OE(t.bbox) : [NE(), ME()];
  }
  function EE(t) {
    null != t && (Array.isArray(t) ? Ku(t) : null != t.bbox && Ku(t.bbox));
  }
  function wE(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    EE(e.bbox), null == t && (t = 1);
    for (var n = [], r = 0; r < t; r++) n.push(Lu(xE(e.bbox)));
    return ju(n);
  }
  function kE(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    EE(e.bbox),
      null == t && (t = 1),
      ($u(e.num_vertices) && void 0 !== e.num_vertices) || (e.num_vertices = 10),
      ($u(e.max_radial_length) && void 0 !== e.max_radial_length) || (e.max_radial_length = 10);
    for (
      var n = [],
        r = function () {
          var t = [],
            r = s(Array(e.num_vertices + 1)).map(Math.random);
          r.forEach(function (t, e, n) {
            n[e] = e > 0 ? t + n[e - 1] : t;
          }),
            r.forEach(function (n) {
              n = (2 * n * Math.PI) / r[r.length - 1];
              var i = Math.random();
              t.push([i * (e.max_radial_length || 10) * Math.sin(n), i * (e.max_radial_length || 10) * Math.cos(n)]);
            }),
            (t[t.length - 1] = t[0]),
            (t = t.map(IE(xE(e.bbox)))),
            n.push(Cu([t]));
        },
        i = 0;
      i < t;
      i++
    )
      r();
    return ju(n);
  }
  function SE(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.bbox;
    EE(n);
    var r = e.num_vertices,
      i = e.max_length,
      o = e.max_rotation;
    null == t && (t = 1),
      (!$u(r) || void 0 === r || r < 2) && (r = 10),
      ($u(i) && void 0 !== i) || (i = 1e-4),
      ($u(o) && void 0 !== o) || (o = Math.PI / 8);
    for (var a = [], s = 0; s < t; s++) {
      for (var u = [xE(n)], l = 0; l < r - 1; l++) {
        var c =
            (0 === l ? 2 * Math.random() * Math.PI : Math.tan((u[l][1] - u[l - 1][1]) / (u[l][0] - u[l - 1][0]))) +
            (Math.random() - 0.5) * o * 2,
          h = Math.random() * i;
        u.push([u[l][0] + h * Math.cos(c), u[l][1] + h * Math.sin(c)]);
      }
      a.push(Au(u));
    }
    return ju(a);
  }
  function IE(t) {
    return function (e) {
      return [e[0] + t[0], e[1] + t[1]];
    };
  }
  function PE() {
    return Math.random() - 0.5;
  }
  function NE() {
    return 360 * PE();
  }
  function ME() {
    return 180 * PE();
  }
  function OE(t) {
    return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]];
  }
  _E(bE, 'randomPosition'),
    _E(xE, 'randomPositionUnchecked'),
    _E(EE, 'checkBBox'),
    _E(wE, 'randomPoint'),
    _E(kE, 'randomPolygon'),
    _E(SE, 'randomLineString'),
    _E(IE, 'vertexToCoordinate'),
    _E(PE, 'rnd'),
    _E(NE, 'lon'),
    _E(ME, 'lat'),
    _E(OE, 'coordInBBox');
  var LE = Object.freeze({
      __proto__: null,
      randomLineString: SE,
      randomPoint: wE,
      randomPolygon: kE,
      randomPosition: bE,
    }),
    RE = Object.defineProperty,
    CE = function (t, e) {
      return RE(t, 'name', { value: e, configurable: !0 });
    };
  function TE(t) {
    var e,
      n,
      r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!Qu((r = r || {}))) throw new Error('options is invalid');
    var i = null != (e = r.mutate) && e,
      o = null != (n = r.reverse) && n;
    if (!t) throw new Error('<geojson> is required');
    if ('boolean' != typeof o) throw new Error('<reverse> must be a boolean');
    if ('boolean' != typeof i) throw new Error('<mutate> must be a boolean');
    i || 'Point' === t.type || 'MultiPoint' === t.type || (t = Ry(t));
    var a = [];
    switch (t.type) {
      case 'GeometryCollection':
        return (
          jl(t, function (t) {
            AE(t, o);
          }),
          t
        );
      case 'FeatureCollection':
        return (
          Tl(t, function (t) {
            Tl(AE(t, o), function (t) {
              a.push(t);
            });
          }),
          ju(a)
        );
    }
    return AE(t, o);
  }
  function AE(t, e) {
    switch ('Feature' === t.type ? t.geometry.type : t.type) {
      case 'GeometryCollection':
        return (
          jl(t, function (t) {
            AE(t, e);
          }),
          t
        );
      case 'LineString':
        return DE(ol(t), e), t;
      case 'Polygon':
        return jE(ol(t), e), t;
      case 'MultiLineString':
        return (
          ol(t).forEach(function (t) {
            DE(t, e);
          }),
          t
        );
      case 'MultiPolygon':
        return (
          ol(t).forEach(function (t) {
            jE(t, e);
          }),
          t
        );
      case 'Point':
      case 'MultiPoint':
        return t;
    }
  }
  function DE(t, e) {
    Ec(t) === e && t.reverse();
  }
  function jE(t, e) {
    Ec(t[0]) !== e && t[0].reverse();
    for (var n = 1; n < t.length; n++) Ec(t[n]) === e && t[n].reverse();
  }
  CE(TE, 'rewind'), CE(AE, 'rewindFeature'), CE(DE, 'rewindLineString'), CE(jE, 'rewindPolygon');
  var FE = Object.defineProperty,
    BE = function (t, e) {
      return FE(t, 'name', { value: e, configurable: !0 });
    };
  function qE(t, e) {
    if (!t) throw new Error('fc is required');
    if (null == e) throw new Error('num is required');
    if ('number' != typeof e) throw new Error('num must be a number');
    return ju(VE(t.features, e));
  }
  function VE(t, e) {
    for (var n, r, i = t.slice(0), o = t.length, a = o - e; o-- > a; )
      (n = i[(r = Math.floor((o + 1) * Math.random()))]), (i[r] = i[o]), (i[o] = n);
    return i.slice(a);
  }
  BE(qE, 'sample'), BE(VE, 'getRandomSubarray');
  var GE = Object.defineProperty,
    YE = function (t, e) {
      return GE(t, 'name', { value: e, configurable: !0 });
    };
  function zE(t, n, r, i) {
    var o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
    if (!Qu((o = o || {}))) throw new Error('options is invalid');
    var a = o.properties;
    if (!t) throw new Error('center is required');
    if (null == r) throw new Error('bearing1 is required');
    if (null == i) throw new Error('bearing2 is required');
    if (!n) throw new Error('radius is required');
    if ('object' !== e(o)) throw new Error('options must be an object');
    if (UE(r) === UE(i)) return My(t, n, o);
    var s = ol(t),
      u = U_(t, n, r, i, o),
      l = [[s]];
    return (
      Ol(u, function (t) {
        l[0].push(t);
      }),
      l[0].push(s),
      Cu(l, a)
    );
  }
  function UE(t) {
    var e = t % 360;
    return e < 0 && (e += 360), e;
  }
  YE(zE, 'sector'), YE(UE, 'convertAngleTo360');
  var XE = Object.defineProperty,
    WE = function (t, e) {
      return XE(t, 'name', { value: e, configurable: !0 });
    };
  function HE(t, n, r) {
    if (!Qu((r = r || {}))) throw new Error('options is invalid');
    var i = r.origin,
      o = r.mutate;
    if (!t) throw new Error('geojson required');
    if ('number' != typeof n || n <= 0) throw new Error('invalid factor');
    var a = Array.isArray(i) || 'object' === e(i);
    return (
      !0 !== o && (t = Ry(t)),
      'FeatureCollection' !== t.type || a
        ? ZE(t, n, i)
        : (Tl(t, function (e, r) {
            t.features[r] = ZE(e, n, i);
          }),
          t)
    );
  }
  function ZE(t, e, n) {
    var r = 'Point' === hl(t);
    return (
      (n = JE(t, n)),
      1 === e ||
        r ||
        (Ol(t, function (t) {
          var r = um(n, t),
            i = kl(n, t),
            o = ol(im(n, r * e, i));
          (t[0] = o[0]), (t[1] = o[1]), 3 === t.length && (t[2] *= e);
        }),
        delete t.bbox),
      t
    );
  }
  function JE(t, n) {
    if ((null == n && (n = 'centroid'), Array.isArray(n) || 'object' === e(n))) return il(n);
    var r = t.bbox ? t.bbox : rc(t, { recalculate: !0 }),
      i = r[0],
      o = r[1],
      a = r[2],
      s = r[3];
    switch (n) {
      case 'sw':
      case 'southwest':
      case 'westsouth':
      case 'bottomleft':
        return Lu([i, o]);
      case 'se':
      case 'southeast':
      case 'eastsouth':
      case 'bottomright':
        return Lu([a, o]);
      case 'nw':
      case 'northwest':
      case 'westnorth':
      case 'topleft':
        return Lu([i, s]);
      case 'ne':
      case 'northeast':
      case 'eastnorth':
      case 'topright':
        return Lu([a, s]);
      case 'center':
        return up(t);
      case void 0:
      case null:
      case 'centroid':
        return Ug(t);
      default:
        throw new Error('invalid origin');
    }
  }
  WE(HE, 'transformScale'), WE(ZE, 'scale'), WE(JE, 'defineOrigin');
  var $E = Object.defineProperty,
    QE = function (t, e) {
      return $E(t, 'name', { value: e, configurable: !0 });
    };
  function KE(t) {
    for (var e = t, n = []; e.parent; ) n.unshift(e), (e = e.parent);
    return n;
  }
  function tw() {
    return new iw(function (t) {
      return t.f;
    });
  }
  QE(KE, 'pathTo'), QE(tw, 'getHeap');
  var ew = {
    search: function (t, e, n, r) {
      var i;
      t.cleanDirty();
      var o = (r = r || {}).heuristic || ew.heuristics.manhattan,
        a = null != (i = r.closest) && i,
        s = tw(),
        u = e;
      for (e.h = o(e, n), s.push(e); s.size() > 0; ) {
        var l = s.pop();
        if (l === n) return KE(l);
        l.closed = !0;
        for (var c = t.neighbors(l), h = 0, f = c.length; h < f; ++h) {
          var p = c[h];
          if (!p.closed && !p.isWall()) {
            var g = l.g + p.getCost(l),
              y = p.visited;
            (!y || g < p.g) &&
              ((p.visited = !0),
              (p.parent = l),
              (p.h = p.h || o(p, n)),
              (p.g = g),
              (p.f = p.g + p.h),
              t.markDirty(p),
              a && (p.h < u.h || (p.h === u.h && p.g < u.g)) && (u = p),
              y ? s.rescoreElement(p) : s.push(p));
          }
        }
      }
      return a ? KE(u) : [];
    },
    heuristics: {
      manhattan: function (t, e) {
        return Math.abs(e.x - t.x) + Math.abs(e.y - t.y);
      },
      diagonal: function (t, e) {
        var n = Math.sqrt(2),
          r = Math.abs(e.x - t.x),
          i = Math.abs(e.y - t.y);
        return 1 * (r + i) + (n - 2) * Math.min(r, i);
      },
    },
    cleanNode: function (t) {
      (t.f = 0), (t.g = 0), (t.h = 0), (t.visited = !1), (t.closed = !1), (t.parent = null);
    },
  };
  function nw(t, e) {
    (e = e || {}), (this.nodes = []), (this.diagonal = !!e.diagonal), (this.grid = []);
    for (var n = 0; n < t.length; n++) {
      this.grid[n] = [];
      for (var r = 0, i = t[n]; r < i.length; r++) {
        var o = new rw(n, r, i[r]);
        (this.grid[n][r] = o), this.nodes.push(o);
      }
    }
    this.init();
  }
  function rw(t, e, n) {
    (this.x = t), (this.y = e), (this.weight = n);
  }
  function iw(t) {
    (this.content = []), (this.scoreFunction = t);
  }
  function ow(t, e) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    if (!Qu((n = n || {}))) throw new Error('options is invalid');
    var r = n.obstacles || ju([]),
      i = n.resolution || 100;
    if (!t) throw new Error('start is required');
    if (!e) throw new Error('end is required');
    if (i && (!$u(i) || i <= 0)) throw new Error('options.resolution must be a number, greater than 0');
    var o = il(t),
      s = il(e);
    if (((t = Lu(o)), (e = Lu(s)), 'FeatureCollection' === r.type)) {
      if (0 === r.features.length) return Au([o, s]);
    } else {
      if ('Polygon' !== r.type) throw new Error('invalid obstacles');
      r = ju([Mu(cl(r))]);
    }
    var u = r;
    u.features.push(t), u.features.push(e);
    var l = a(rc(HE(pc(rc(u)), 1.15)), 4),
      c = l[0],
      h = l[1],
      f = l[2],
      p = l[3],
      g = _l([c, h], [f, h], n) / i;
    u.features.pop(), u.features.pop();
    for (
      var y,
        v,
        d = (g / _l([c, h], [f, h], n)) * (f - c),
        m = (g / _l([c, h], [c, p], n)) * (p - h),
        _ = f - c,
        b = p - h,
        x = Math.floor(_ / d),
        E = Math.floor(b / m),
        w = (_ - x * d) / 2,
        k = [],
        S = [],
        I = 1 / 0,
        P = 1 / 0,
        N = p - (b - E * m) / 2,
        M = 0;
      N >= h;

    ) {
      for (var O = [], L = [], R = c + w, C = 0; R <= f; ) {
        var T = Lu([R, N]),
          A = aw(T, r);
        O.push(A ? 0 : 1), L.push(R + '|' + N);
        var D = _l(T, t);
        !A && D < I && ((I = D), (y = { x: C, y: M }));
        var j = _l(T, e);
        !A && j < P && ((P = j), (v = { x: C, y: M })), (R += d), C++;
      }
      S.push(O), k.push(L), (N -= m), M++;
    }
    var F = new nw(S, { diagonal: !0 }),
      B = F.grid[y.y][y.x],
      q = F.grid[v.y][v.x],
      V = ew.search(F, B, q),
      G = [o];
    return (
      V.forEach(function (t) {
        var e = k[t.x][t.y].split('|');
        G.push([+e[0], +e[1]]);
      }),
      G.push(s),
      Ah(Au(G))
    );
  }
  function aw(t, e) {
    for (var n = 0; n < e.features.length; n++) if (Nc(t, e.features[n])) return !0;
    return !1;
  }
  QE(nw, 'Graph'),
    (nw.prototype.init = function () {
      this.dirtyNodes = [];
      for (var t = 0; t < this.nodes.length; t++) ew.cleanNode(this.nodes[t]);
    }),
    (nw.prototype.cleanDirty = function () {
      for (var t = 0; t < this.dirtyNodes.length; t++) ew.cleanNode(this.dirtyNodes[t]);
      this.dirtyNodes = [];
    }),
    (nw.prototype.markDirty = function (t) {
      this.dirtyNodes.push(t);
    }),
    (nw.prototype.neighbors = function (t) {
      var e = [],
        n = t.x,
        r = t.y,
        i = this.grid;
      return (
        i[n - 1] && i[n - 1][r] && e.push(i[n - 1][r]),
        i[n + 1] && i[n + 1][r] && e.push(i[n + 1][r]),
        i[n] && i[n][r - 1] && e.push(i[n][r - 1]),
        i[n] && i[n][r + 1] && e.push(i[n][r + 1]),
        this.diagonal &&
          (i[n - 1] && i[n - 1][r - 1] && e.push(i[n - 1][r - 1]),
          i[n + 1] && i[n + 1][r - 1] && e.push(i[n + 1][r - 1]),
          i[n - 1] && i[n - 1][r + 1] && e.push(i[n - 1][r + 1]),
          i[n + 1] && i[n + 1][r + 1] && e.push(i[n + 1][r + 1])),
        e
      );
    }),
    (nw.prototype.toString = function () {
      for (var t, e, n, r, i = [], o = this.grid, a = 0, s = o.length; a < s; a++) {
        for (t = [], n = 0, r = (e = o[a]).length; n < r; n++) t.push(e[n].weight);
        i.push(t.join(' '));
      }
      return i.join('\n');
    }),
    QE(rw, 'GridNode'),
    (rw.prototype.toString = function () {
      return '[' + this.x + ' ' + this.y + ']';
    }),
    (rw.prototype.getCost = function (t) {
      return t && t.x !== this.x && t.y !== this.y ? 1.41421 * this.weight : this.weight;
    }),
    (rw.prototype.isWall = function () {
      return 0 === this.weight;
    }),
    QE(iw, 'BinaryHeap'),
    (iw.prototype = {
      push: function (t) {
        this.content.push(t), this.sinkDown(this.content.length - 1);
      },
      pop: function () {
        var t = this.content[0],
          e = this.content.pop();
        return this.content.length > 0 && ((this.content[0] = e), this.bubbleUp(0)), t;
      },
      remove: function (t) {
        var e = this.content.indexOf(t),
          n = this.content.pop();
        e !== this.content.length - 1 &&
          ((this.content[e] = n), this.scoreFunction(n) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e));
      },
      size: function () {
        return this.content.length;
      },
      rescoreElement: function (t) {
        this.sinkDown(this.content.indexOf(t));
      },
      sinkDown: function (t) {
        for (var e = this.content[t]; t > 0; ) {
          var n = ((t + 1) >> 1) - 1,
            r = this.content[n];
          if (!(this.scoreFunction(e) < this.scoreFunction(r))) break;
          (this.content[n] = e), (this.content[t] = r), (t = n);
        }
      },
      bubbleUp: function (t) {
        for (var e = this.content.length, n = this.content[t], r = this.scoreFunction(n); ; ) {
          var i,
            o = (t + 1) << 1,
            a = o - 1,
            s = null;
          if (a < e) {
            var u = this.content[a];
            (i = this.scoreFunction(u)) < r && (s = a);
          }
          if (o < e) {
            var l = this.content[o];
            this.scoreFunction(l) < (null === s ? r : i) && (s = o);
          }
          if (null === s) break;
          (this.content[t] = this.content[s]), (this.content[s] = n), (t = s);
        }
      },
    }),
    QE(ow, 'shortestPath'),
    QE(aw, 'isInside');
  var sw = Object.defineProperty,
    uw = function (t, e) {
      return sw(t, 'name', { value: e, configurable: !0 });
    };
  function lw(t, e) {
    var n = t[0] - e[0],
      r = t[1] - e[1];
    return n * n + r * r;
  }
  function cw(t, e, n) {
    var r = e[0],
      i = e[1],
      o = n[0] - r,
      a = n[1] - i;
    if (0 !== o || 0 !== a) {
      var s = ((t[0] - r) * o + (t[1] - i) * a) / (o * o + a * a);
      s > 1 ? ((r = n[0]), (i = n[1])) : s > 0 && ((r += o * s), (i += a * s));
    }
    return (o = t[0] - r) * o + (a = t[1] - i) * a;
  }
  function hw(t, e) {
    for (var n, r = t[0], i = [r], o = 1, a = t.length; o < a; o++) lw((n = t[o]), r) > e && (i.push(n), (r = n));
    return r !== n && i.push(n), i;
  }
  function fw(t, e, n, r, i) {
    for (var o, a = r, s = e + 1; s < n; s++) {
      var u = cw(t[s], t[e], t[n]);
      u > a && ((o = s), (a = u));
    }
    a > r && (o - e > 1 && fw(t, e, o, r, i), i.push(t[o]), n - o > 1 && fw(t, o, n, r, i));
  }
  function pw(t, e) {
    var n = t.length - 1,
      r = [t[0]];
    return fw(t, 0, n, e, r), r.push(t[n]), r;
  }
  function gw(t, e, n) {
    if (t.length <= 2) return t;
    var r = void 0 !== e ? e * e : 1;
    return (t = pw((t = n ? t : hw(t, r)), r));
  }
  function yw(t) {
    var e,
      n,
      r,
      i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!Qu((i = null != i ? i : {}))) throw new Error('options is invalid');
    var o = null != (e = i.tolerance) ? e : 1,
      a = null != (n = i.highQuality) && n,
      s = null != (r = i.mutate) && r;
    if (!t) throw new Error('geojson is required');
    if (o && o < 0) throw new Error('invalid tolerance');
    return (
      !0 !== s && (t = Ry(t)),
      jl(t, function (t) {
        vw(t, o, a);
      }),
      t
    );
  }
  function vw(t, e, n) {
    var r = t.type;
    if ('Point' === r || 'MultiPoint' === r) return t;
    if ((Ah(t, { mutate: !0 }), 'GeometryCollection' !== r))
      switch (r) {
        case 'LineString':
          t.coordinates = gw(t.coordinates, e, n);
          break;
        case 'MultiLineString':
          t.coordinates = t.coordinates.map(function (t) {
            return gw(t, e, n);
          });
          break;
        case 'Polygon':
          t.coordinates = dw(t.coordinates, e, n);
          break;
        case 'MultiPolygon':
          t.coordinates = t.coordinates.map(function (t) {
            return dw(t, e, n);
          });
      }
    return t;
  }
  function dw(t, e, n) {
    return t.map(function (t) {
      if (t.length < 4) throw new Error('invalid polygon');
      for (var r = e, i = gw(t, r, n); !mw(i); ) i = gw(t, (r -= 0.01 * r), n);
      return (i[i.length - 1][0] === i[0][0] && i[i.length - 1][1] === i[0][1]) || i.push(i[0]), i;
    });
  }
  function mw(t) {
    return !(t.length < 3) && !(3 === t.length && t[2][0] === t[0][0] && t[2][1] === t[0][1]);
  }
  uw(lw, 'getSqDist'),
    uw(cw, 'getSqSegDist'),
    uw(hw, 'simplifyRadialDist'),
    uw(fw, 'simplifyDPStep'),
    uw(pw, 'simplifyDouglasPeucker'),
    uw(gw, 'simplify'),
    uw(yw, 'simplify'),
    uw(vw, 'simplifyGeom'),
    uw(dw, 'simplifyPolygon'),
    uw(mw, 'checkValidity');
  var _w = Object.defineProperty,
    bw = function (t, e) {
      return _w(t, 'name', { value: e, configurable: !0 });
    };
  function xw(t, e) {
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.steps || 64,
      r = e.weight,
      i = e.properties || {};
    if (!$u(n)) throw new Error('steps must be a number');
    if (!Qu(i)) throw new Error('properties must be a number');
    var o = Dl(t).length,
      a = Yg(t, { weight: r }),
      s = 0,
      u = 0,
      l = 0;
    Tl(t, function (t) {
      var e = t.properties[r] || 1,
        n = Ew(ol(t), ol(a));
      (s += Math.pow(n.x, 2) * e), (u += Math.pow(n.y, 2) * e), (l += n.x * n.y * e);
    });
    var c = s - u,
      h = Math.sqrt(Math.pow(c, 2) + 4 * Math.pow(l, 2)),
      f = 2 * l,
      p = Math.atan((c + h) / f),
      g = (180 * p) / Math.PI,
      y = 0,
      v = 0,
      d = 0;
    Tl(t, function (t) {
      var e = t.properties[r] || 1,
        n = Ew(ol(t), ol(a));
      (y += Math.pow(n.x * Math.cos(p) - n.y * Math.sin(p), 2) * e),
        (v += Math.pow(n.x * Math.sin(p) + n.y * Math.cos(p), 2) * e),
        (d += e);
    });
    var m = Math.sqrt((2 * y) / d),
      _ = Math.sqrt((2 * v) / d),
      b = gm(a, m, _, { units: 'degrees', angle: g, steps: n, properties: i }),
      x = Px(t, ju([b])),
      E = {
        meanCenterCoordinates: ol(a),
        semiMajorAxis: m,
        semiMinorAxis: _,
        numberOfFeatures: o,
        angle: g,
        percentageWithinEllipse: (100 * Dl(x).length) / o,
      };
    return (b.properties.standardDeviationalEllipse = E), b;
  }
  function Ew(t, e) {
    return { x: t[0] - e[0], y: t[1] - e[1] };
  }
  bw(xw, 'standardDeviationalEllipse'), bw(Ew, 'getDeviations');
  var ww = Object.defineProperty;
  function kw(t, e, n, r) {
    return (
      (t = Ry(t)),
      (e = Ry(e)),
      Tl(t, function (t) {
        t.properties || (t.properties = {}),
          Tl(e, function (e) {
            t.properties &&
              e.properties &&
              void 0 === t.properties[r] &&
              Nc(t, e) &&
              (t.properties[r] = e.properties[n]);
          });
      }),
      t
    );
  }
  !(function (t, e) {
    ww(t, 'name', { value: e, configurable: !0 });
  })(kw, 'tag');
  var Sw = { exports: {} };
  function Iw(t, e, n) {
    n = n || 2;
    var r,
      i,
      o,
      a,
      s,
      u,
      l,
      c = e && e.length,
      h = c ? e[0] * n : t.length,
      f = Pw(t, 0, h, n, !0),
      p = [];
    if (!f || f.next === f.prev) return p;
    if (
      (c &&
        (f = (function (t, e, n, r) {
          var i,
            o,
            a,
            s = [];
          for (i = 0, o = e.length; i < o; i++)
            (a = Pw(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === a.next && (a.steiner = !0),
              s.push(Fw(a));
          for (s.sort(Tw), i = 0; i < s.length; i++) n = Aw(s[i], n);
          return n;
        })(t, e, f, n)),
      t.length > 80 * n)
    ) {
      (r = o = t[0]), (i = a = t[1]);
      for (var g = n; g < h; g += n)
        (s = t[g]) < r && (r = s), (u = t[g + 1]) < i && (i = u), s > o && (o = s), u > a && (a = u);
      l = 0 !== (l = Math.max(o - r, a - i)) ? 32767 / l : 0;
    }
    return Mw(f, p, n, r, i, l, 0), p;
  }
  function Pw(t, e, n, r, i) {
    var o, a;
    if (i === $w(t, e, n, r) > 0) for (o = e; o < n; o += r) a = Hw(o, t[o], t[o + 1], a);
    else for (o = n - r; o >= e; o -= r) a = Hw(o, t[o], t[o + 1], a);
    return a && Gw(a, a.next) && (Zw(a), (a = a.next)), a;
  }
  function Nw(t, e) {
    if (!t) return t;
    e || (e = t);
    var n,
      r = t;
    do {
      if (((n = !1), r.steiner || (!Gw(r, r.next) && 0 !== Vw(r.prev, r, r.next)))) r = r.next;
      else {
        if ((Zw(r), (r = e = r.prev) === r.next)) break;
        n = !0;
      }
    } while (n || r !== e);
    return e;
  }
  function Mw(t, e, n, r, i, o, a) {
    if (t) {
      !a &&
        o &&
        (function (t, e, n, r) {
          var i = t;
          do {
            0 === i.z && (i.z = jw(i.x, i.y, e, n, r)), (i.prevZ = i.prev), (i.nextZ = i.next), (i = i.next);
          } while (i !== t);
          (i.prevZ.nextZ = null),
            (i.prevZ = null),
            (function (t) {
              var e,
                n,
                r,
                i,
                o,
                a,
                s,
                u,
                l = 1;
              do {
                for (n = t, t = null, o = null, a = 0; n; ) {
                  for (a++, r = n, s = 0, e = 0; e < l && (s++, (r = r.nextZ)); e++);
                  for (u = l; s > 0 || (u > 0 && r); )
                    0 !== s && (0 === u || !r || n.z <= r.z)
                      ? ((i = n), (n = n.nextZ), s--)
                      : ((i = r), (r = r.nextZ), u--),
                      o ? (o.nextZ = i) : (t = i),
                      (i.prevZ = o),
                      (o = i);
                  n = r;
                }
                (o.nextZ = null), (l *= 2);
              } while (a > 1);
            })(i);
        })(t, r, i, o);
      for (var s, u, l = t; t.prev !== t.next; )
        if (((s = t.prev), (u = t.next), o ? Lw(t, r, i, o) : Ow(t)))
          e.push((s.i / n) | 0), e.push((t.i / n) | 0), e.push((u.i / n) | 0), Zw(t), (t = u.next), (l = u.next);
        else if ((t = u) === l) {
          a
            ? 1 === a
              ? Mw((t = Rw(Nw(t), e, n)), e, n, r, i, o, 2)
              : 2 === a && Cw(t, e, n, r, i, o)
            : Mw(Nw(t), e, n, r, i, o, 1);
          break;
        }
    }
  }
  function Ow(t) {
    var e = t.prev,
      n = t,
      r = t.next;
    if (Vw(e, n, r) >= 0) return !1;
    for (
      var i = e.x,
        o = n.x,
        a = r.x,
        s = e.y,
        u = n.y,
        l = r.y,
        c = i < o ? (i < a ? i : a) : o < a ? o : a,
        h = s < u ? (s < l ? s : l) : u < l ? u : l,
        f = i > o ? (i > a ? i : a) : o > a ? o : a,
        p = s > u ? (s > l ? s : l) : u > l ? u : l,
        g = r.next;
      g !== e;

    ) {
      if (g.x >= c && g.x <= f && g.y >= h && g.y <= p && Bw(i, s, o, u, a, l, g.x, g.y) && Vw(g.prev, g, g.next) >= 0)
        return !1;
      g = g.next;
    }
    return !0;
  }
  function Lw(t, e, n, r) {
    var i = t.prev,
      o = t,
      a = t.next;
    if (Vw(i, o, a) >= 0) return !1;
    for (
      var s = i.x,
        u = o.x,
        l = a.x,
        c = i.y,
        h = o.y,
        f = a.y,
        p = s < u ? (s < l ? s : l) : u < l ? u : l,
        g = c < h ? (c < f ? c : f) : h < f ? h : f,
        y = s > u ? (s > l ? s : l) : u > l ? u : l,
        v = c > h ? (c > f ? c : f) : h > f ? h : f,
        d = jw(p, g, e, n, r),
        m = jw(y, v, e, n, r),
        _ = t.prevZ,
        b = t.nextZ;
      _ && _.z >= d && b && b.z <= m;

    ) {
      if (
        _.x >= p &&
        _.x <= y &&
        _.y >= g &&
        _.y <= v &&
        _ !== i &&
        _ !== a &&
        Bw(s, c, u, h, l, f, _.x, _.y) &&
        Vw(_.prev, _, _.next) >= 0
      )
        return !1;
      if (
        ((_ = _.prevZ),
        b.x >= p &&
          b.x <= y &&
          b.y >= g &&
          b.y <= v &&
          b !== i &&
          b !== a &&
          Bw(s, c, u, h, l, f, b.x, b.y) &&
          Vw(b.prev, b, b.next) >= 0)
      )
        return !1;
      b = b.nextZ;
    }
    for (; _ && _.z >= d; ) {
      if (
        _.x >= p &&
        _.x <= y &&
        _.y >= g &&
        _.y <= v &&
        _ !== i &&
        _ !== a &&
        Bw(s, c, u, h, l, f, _.x, _.y) &&
        Vw(_.prev, _, _.next) >= 0
      )
        return !1;
      _ = _.prevZ;
    }
    for (; b && b.z <= m; ) {
      if (
        b.x >= p &&
        b.x <= y &&
        b.y >= g &&
        b.y <= v &&
        b !== i &&
        b !== a &&
        Bw(s, c, u, h, l, f, b.x, b.y) &&
        Vw(b.prev, b, b.next) >= 0
      )
        return !1;
      b = b.nextZ;
    }
    return !0;
  }
  function Rw(t, e, n) {
    var r = t;
    do {
      var i = r.prev,
        o = r.next.next;
      !Gw(i, o) &&
        Yw(i, r, r.next, o) &&
        Xw(i, o) &&
        Xw(o, i) &&
        (e.push((i.i / n) | 0), e.push((r.i / n) | 0), e.push((o.i / n) | 0), Zw(r), Zw(r.next), (r = t = o)),
        (r = r.next);
    } while (r !== t);
    return Nw(r);
  }
  function Cw(t, e, n, r, i, o) {
    var a = t;
    do {
      for (var s = a.next.next; s !== a.prev; ) {
        if (a.i !== s.i && qw(a, s)) {
          var u = Ww(a, s);
          return (a = Nw(a, a.next)), (u = Nw(u, u.next)), Mw(a, e, n, r, i, o, 0), void Mw(u, e, n, r, i, o, 0);
        }
        s = s.next;
      }
      a = a.next;
    } while (a !== t);
  }
  function Tw(t, e) {
    return t.x - e.x;
  }
  function Aw(t, e) {
    var n = (function (t, e) {
      var n,
        r = e,
        i = t.x,
        o = t.y,
        a = -1 / 0;
      do {
        if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
          var s = r.x + ((o - r.y) * (r.next.x - r.x)) / (r.next.y - r.y);
          if (s <= i && s > a && ((a = s), (n = r.x < r.next.x ? r : r.next), s === i)) return n;
        }
        r = r.next;
      } while (r !== e);
      if (!n) return null;
      var u,
        l = n,
        c = n.x,
        h = n.y,
        f = 1 / 0;
      r = n;
      do {
        i >= r.x &&
          r.x >= c &&
          i !== r.x &&
          Bw(o < h ? i : a, o, c, h, o < h ? a : i, o, r.x, r.y) &&
          ((u = Math.abs(o - r.y) / (i - r.x)),
          Xw(r, t) && (u < f || (u === f && (r.x > n.x || (r.x === n.x && Dw(n, r))))) && ((n = r), (f = u))),
          (r = r.next);
      } while (r !== l);
      return n;
    })(t, e);
    if (!n) return e;
    var r = Ww(n, t);
    return Nw(r, r.next), Nw(n, n.next);
  }
  function Dw(t, e) {
    return Vw(t.prev, t, e.prev) < 0 && Vw(e.next, t, t.next) < 0;
  }
  function jw(t, e, n, r, i) {
    return (
      (t =
        1431655765 &
        ((t =
          858993459 &
          ((t = 252645135 & ((t = 16711935 & ((t = ((t - n) * i) | 0) | (t << 8))) | (t << 4))) | (t << 2))) |
          (t << 1))) |
      ((e =
        1431655765 &
        ((e =
          858993459 &
          ((e = 252645135 & ((e = 16711935 & ((e = ((e - r) * i) | 0) | (e << 8))) | (e << 4))) | (e << 2))) |
          (e << 1))) <<
        1)
    );
  }
  function Fw(t) {
    var e = t,
      n = t;
    do {
      (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
    } while (e !== t);
    return n;
  }
  function Bw(t, e, n, r, i, o, a, s) {
    return (
      (i - a) * (e - s) >= (t - a) * (o - s) &&
      (t - a) * (r - s) >= (n - a) * (e - s) &&
      (n - a) * (o - s) >= (i - a) * (r - s)
    );
  }
  function qw(t, e) {
    return (
      t.next.i !== e.i &&
      t.prev.i !== e.i &&
      !(function (t, e) {
        var n = t;
        do {
          if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Yw(n, n.next, t, e)) return !0;
          n = n.next;
        } while (n !== t);
        return !1;
      })(t, e) &&
      ((Xw(t, e) &&
        Xw(e, t) &&
        (function (t, e) {
          var n = t,
            r = !1,
            i = (t.x + e.x) / 2,
            o = (t.y + e.y) / 2;
          do {
            n.y > o != n.next.y > o &&
              n.next.y !== n.y &&
              i < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
              (r = !r),
              (n = n.next);
          } while (n !== t);
          return r;
        })(t, e) &&
        (Vw(t.prev, t, e.prev) || Vw(t, e.prev, e))) ||
        (Gw(t, e) && Vw(t.prev, t, t.next) > 0 && Vw(e.prev, e, e.next) > 0))
    );
  }
  function Vw(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
  }
  function Gw(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function Yw(t, e, n, r) {
    var i = Uw(Vw(t, e, n)),
      o = Uw(Vw(t, e, r)),
      a = Uw(Vw(n, r, t)),
      s = Uw(Vw(n, r, e));
    return (
      (i !== o && a !== s) ||
      !(0 !== i || !zw(t, n, e)) ||
      !(0 !== o || !zw(t, r, e)) ||
      !(0 !== a || !zw(n, t, r)) ||
      !(0 !== s || !zw(n, e, r))
    );
  }
  function zw(t, e, n) {
    return (
      e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
    );
  }
  function Uw(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
  }
  function Xw(t, e) {
    return Vw(t.prev, t, t.next) < 0
      ? Vw(t, e, t.next) >= 0 && Vw(t, t.prev, e) >= 0
      : Vw(t, e, t.prev) < 0 || Vw(t, t.next, e) < 0;
  }
  function Ww(t, e) {
    var n = new Jw(t.i, t.x, t.y),
      r = new Jw(e.i, e.x, e.y),
      i = t.next,
      o = e.prev;
    return (
      (t.next = e), (e.prev = t), (n.next = i), (i.prev = n), (r.next = n), (n.prev = r), (o.next = r), (r.prev = o), r
    );
  }
  function Hw(t, e, n, r) {
    var i = new Jw(t, e, n);
    return r ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i)) : ((i.prev = i), (i.next = i)), i;
  }
  function Zw(t) {
    (t.next.prev = t.prev),
      (t.prev.next = t.next),
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function Jw(t, e, n) {
    (this.i = t),
      (this.x = e),
      (this.y = n),
      (this.prev = null),
      (this.next = null),
      (this.z = 0),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  function $w(t, e, n, r) {
    for (var i = 0, o = e, a = n - r; o < n; o += r) (i += (t[a] - t[o]) * (t[o + 1] + t[a + 1])), (a = o);
    return i;
  }
  (Sw.exports = Iw),
    (Sw.exports.default = Iw),
    (Iw.deviation = function (t, e, n, r) {
      var i = e && e.length,
        o = i ? e[0] * n : t.length,
        a = Math.abs($w(t, 0, o, n));
      if (i)
        for (var s = 0, u = e.length; s < u; s++) {
          var l = e[s] * n,
            c = s < u - 1 ? e[s + 1] * n : t.length;
          a -= Math.abs($w(t, l, c, n));
        }
      var h = 0;
      for (s = 0; s < r.length; s += 3) {
        var f = r[s] * n,
          p = r[s + 1] * n,
          g = r[s + 2] * n;
        h += Math.abs((t[f] - t[g]) * (t[p + 1] - t[f + 1]) - (t[f] - t[p]) * (t[g + 1] - t[f + 1]));
      }
      return 0 === a && 0 === h ? 0 : Math.abs((h - a) / a);
    }),
    (Iw.flatten = function (t) {
      for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) {
        for (var o = 0; o < t[i].length; o++) for (var a = 0; a < e; a++) n.vertices.push(t[i][o][a]);
        i > 0 && ((r += t[i - 1].length), n.holes.push(r));
      }
      return n;
    });
  var Qw = p(Sw.exports),
    Kw = Object.defineProperty,
    tk = function (t, e) {
      return Kw(t, 'name', { value: e, configurable: !0 });
    };
  function ek(t) {
    if (!t.geometry || ('Polygon' !== t.geometry.type && 'MultiPolygon' !== t.geometry.type))
      throw new Error('input must be a Polygon or MultiPolygon');
    var e = { type: 'FeatureCollection', features: [] };
    return (
      'Polygon' === t.geometry.type
        ? (e.features = nk(t.geometry.coordinates))
        : t.geometry.coordinates.forEach(function (t) {
            e.features = e.features.concat(nk(t));
          }),
      e
    );
  }
  function nk(t) {
    var e = rk(t),
      n = Qw(e.vertices, e.holes, 2),
      r = [],
      i = [];
    n.forEach(function (t, r) {
      var o = n[r];
      i.push([e.vertices[2 * o], e.vertices[2 * o + 1]]);
    });
    for (var o = 0; o < i.length; o += 3) {
      var a = i.slice(o, o + 3);
      a.push(i[o]), r.push(Cu([a]));
    }
    return r;
  }
  function rk(t) {
    for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) {
      for (var o = 0; o < t[i].length; o++) for (var a = 0; a < e; a++) n.vertices.push(t[i][o][a]);
      i > 0 && ((r += t[i - 1].length), n.holes.push(r));
    }
    return n;
  }
  tk(ek, 'tesselate'), tk(nk, 'processPolygon'), tk(rk, 'flattenCoords');
  var ik = Object.defineProperty;
  function ok(t, e, n, r) {
    if (!Qu((r = r || {}))) throw new Error('options is invalid');
    var i = r.units,
      o = r.zTranslation,
      a = r.mutate;
    if (!t) throw new Error('geojson is required');
    if (null == e || isNaN(e)) throw new Error('distance is required');
    if (o && 'number' != typeof o && isNaN(o)) throw new Error('zTranslation is not a number');
    if (((o = void 0 !== o ? o : 0), 0 === e && 0 === o)) return t;
    if (null == n || isNaN(n)) throw new Error('direction is required');
    return (
      e < 0 && ((e = -e), (n += 180)),
      (!1 !== a && void 0 !== a) || (t = Ry(t)),
      Ol(t, function (t) {
        var r = ol(im(t, e, n, { units: i }));
        (t[0] = r[0]), (t[1] = r[1]), o && 3 === t.length && (t[2] += o);
      }),
      t
    );
  }
  !(function (t, e) {
    ik(t, 'name', { value: e, configurable: !0 });
  })(ok, 'transformTranslate');
  var ak = Object.defineProperty;
  function sk(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      n = [];
    if (
      (jl(t, function (t) {
        n.push(t.coordinates);
      }),
      n.length < 2)
    )
      throw new Error('Must have at least 2 geometries');
    var r = Ud.union.apply(Ud, [n[0]].concat(s(n.slice(1))));
    return 0 === r.length ? null : 1 === r.length ? Cu(r[0], e.properties) : qu(r, e.properties);
  }
  !(function (t, e) {
    ak(t, 'name', { value: e, configurable: !0 });
  })(sk, 'union');
  var uk = Object.defineProperty,
    lk = function (t, e) {
      return uk(t, 'name', { value: e, configurable: !0 });
    };
  function ck(t, e, n) {
    if ('Polygon' !== t.geometry.type) throw new Error('The input feature must be a Polygon');
    void 0 === n && (n = 1);
    var r = t.geometry.coordinates,
      i = [],
      o = {};
    if (n) {
      for (var a = [], s = 0; s < r.length; s++) for (var u = 0; u < r[s].length - 1; u++) a.push(y(s, u));
      var l = new Wh();
      l.load(a);
    }
    for (var c = 0; c < r.length; c++)
      for (var h = 0; h < r[c].length - 1; h++) {
        if (n)
          l.search(y(c, h)).forEach(function (t) {
            var e = t.ring,
              n = t.edge;
            g(c, h, e, n);
          });
        else for (var f = 0; f < r.length; f++) for (var p = 0; p < r[f].length - 1; p++) g(c, h, f, p);
      }
    return e || (i = { type: 'Feature', geometry: { type: 'MultiPoint', coordinates: i } }), i;
    function g(t, n, a, s) {
      var u,
        l,
        c = r[t][n],
        h = r[t][n + 1],
        f = r[a][s],
        p = r[a][s + 1],
        g = hk(c, h, f, p);
      if (
        null !== g &&
        ((u = h[0] !== c[0] ? (g[0] - c[0]) / (h[0] - c[0]) : (g[1] - c[1]) / (h[1] - c[1])),
        (l = p[0] !== f[0] ? (g[0] - f[0]) / (p[0] - f[0]) : (g[1] - f[1]) / (p[1] - f[1])),
        !(u >= 1 || u <= 0 || l >= 1 || l <= 0))
      ) {
        var y = g,
          v = !o[y];
        v && (o[y] = !0), e ? i.push(e(g, t, n, c, h, u, a, s, f, p, l, v)) : i.push(g);
      }
    }
    function y(t, e) {
      var n,
        i,
        o,
        a,
        s = r[t][e],
        u = r[t][e + 1];
      return (
        s[0] < u[0] ? ((n = s[0]), (i = u[0])) : ((n = u[0]), (i = s[0])),
        s[1] < u[1] ? ((o = s[1]), (a = u[1])) : ((o = u[1]), (a = s[1])),
        { minX: n, minY: o, maxX: i, maxY: a, ring: t, edge: e }
      );
    }
  }
  function hk(t, e, n, r) {
    if (fk(t, n) || fk(t, r) || fk(e, n) || fk(r, n)) return null;
    var i = t[0],
      o = t[1],
      a = e[0],
      s = e[1],
      u = n[0],
      l = n[1],
      c = r[0],
      h = r[1],
      f = (i - a) * (l - h) - (o - s) * (u - c);
    return 0 === f
      ? null
      : [
          ((i * s - o * a) * (u - c) - (i - a) * (u * h - l * c)) / f,
          ((i * s - o * a) * (l - h) - (o - s) * (u * h - l * c)) / f,
        ];
  }
  function fk(t, e) {
    if (!t || !e) return !1;
    if (t.length !== e.length) return !1;
    for (var n = 0, r = t.length; n < r; n++)
      if (t[n] instanceof Array && e[n] instanceof Array) {
        if (!fk(t[n], e[n])) return !1;
      } else if (t[n] !== e[n]) return !1;
    return !0;
  }
  function pk(t) {
    if ('Feature' != t.type) throw new Error('The input must a geojson object of type Feature');
    if (void 0 === t.geometry || null == t.geometry)
      throw new Error('The input must a geojson object with a non-empty geometry');
    if ('Polygon' != t.geometry.type) throw new Error('The input must be a geojson Polygon');
    for (var e = t.geometry.coordinates.length, n = [], r = 0; r < e; r++) {
      var i = t.geometry.coordinates[r];
      mk(i[0], i[i.length - 1]) || i.push(i[0]);
      for (var o = 0; o < i.length - 1; o++) n.push(i[o]);
    }
    if (!bk(n))
      throw new Error(
        'The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)',
      );
    var a = n.length,
      s = ck(
        t,
        lk(function (t, e, n, r, i, o, a, s, u, l, c, h) {
          return [t, e, n, r, i, o, a, s, u, l, c, h];
        }, 'filterFn'),
      ),
      u = s.length;
    if (0 == u) {
      var l = [];
      for (r = 0; r < e; r++)
        l.push(Cu([t.geometry.coordinates[r]], { parent: -1, winding: dk(t.geometry.coordinates[r]) }));
      var c = ju(l);
      return D(), j(), c;
    }
    var h = [],
      f = [];
    for (r = 0; r < e; r++) {
      h.push([]);
      for (o = 0; o < t.geometry.coordinates[r].length - 1; o++)
        h[r].push([
          new gk(
            t.geometry.coordinates[r][_k(o + 1, t.geometry.coordinates[r].length - 1)],
            1,
            [r, o],
            [r, _k(o + 1, t.geometry.coordinates[r].length - 1)],
            void 0,
          ),
        ]),
          f.push(
            new yk(
              t.geometry.coordinates[r][o],
              [r, _k(o - 1, t.geometry.coordinates[r].length - 1)],
              [r, o],
              void 0,
              void 0,
              !1,
              !0,
            ),
          );
    }
    for (r = 0; r < u; r++)
      h[s[r][1]][s[r][2]].push(new gk(s[r][0], s[r][5], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0)),
        s[r][11] && f.push(new yk(s[r][0], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0, void 0, !0, !0));
    var p = f.length;
    for (r = 0; r < h.length; r++)
      for (o = 0; o < h[r].length; o++)
        h[r][o].sort(function (t, e) {
          return t.param < e.param ? -1 : 1;
        });
    var g = [];
    for (r = 0; r < p; r++)
      g.push({ minX: f[r].coord[0], minY: f[r].coord[1], maxX: f[r].coord[0], maxY: f[r].coord[1], index: r });
    var y = new Wh();
    y.load(g);
    for (r = 0; r < h.length; r++)
      for (o = 0; o < h[r].length; o++)
        for (var v = 0; v < h[r][o].length; v++) {
          m =
            v == h[r][o].length - 1
              ? h[r][_k(o + 1, t.geometry.coordinates[r].length - 1)][0].coord
              : h[r][o][v + 1].coord;
          var d = y.search({ minX: m[0], minY: m[1], maxX: m[0], maxY: m[1] })[0];
          h[r][o][v].nxtIsectAlongEdgeIn = d.index;
        }
    for (r = 0; r < h.length; r++)
      for (o = 0; o < h[r].length; o++)
        for (v = 0; v < h[r][o].length; v++) {
          var m = h[r][o][v].coord,
            _ = (d = y.search({ minX: m[0], minY: m[1], maxX: m[0], maxY: m[1] })[0]).index;
          _ < a
            ? (f[_].nxtIsectAlongRingAndEdge2 = h[r][o][v].nxtIsectAlongEdgeIn)
            : mk(f[_].ringAndEdge1, h[r][o][v].ringAndEdgeIn)
            ? (f[_].nxtIsectAlongRingAndEdge1 = h[r][o][v].nxtIsectAlongEdgeIn)
            : (f[_].nxtIsectAlongRingAndEdge2 = h[r][o][v].nxtIsectAlongEdgeIn);
        }
    var b = [];
    for (r = 0, o = 0; o < e; o++) {
      var x = r;
      for (v = 0; v < t.geometry.coordinates[o].length - 1; v++) f[r].coord[0] < f[x].coord[0] && (x = r), r++;
      var E = f[x].nxtIsectAlongRingAndEdge2;
      for (v = 0; v < f.length; v++)
        if (f[v].nxtIsectAlongRingAndEdge1 == x || f[v].nxtIsectAlongRingAndEdge2 == x) {
          var w = v;
          break;
        }
      var k = vk([f[w].coord, f[x].coord, f[E].coord], !0) ? 1 : -1;
      b.push({ isect: x, parent: -1, winding: k });
    }
    b.sort(function (t, e) {
      return f[t.isect].coord > f[e.isect].coord ? -1 : 1;
    });
    for (l = []; b.length > 0; ) {
      var S = b.pop(),
        I = S.isect,
        P = S.parent,
        N = S.winding,
        M = l.length,
        O = [f[I].coord],
        L = I;
      if (f[I].ringAndEdge1Walkable)
        var R = f[I].ringAndEdge1,
          C = f[I].nxtIsectAlongRingAndEdge1;
      else (R = f[I].ringAndEdge2), (C = f[I].nxtIsectAlongRingAndEdge2);
      for (; !mk(f[I].coord, f[C].coord); ) {
        O.push(f[C].coord);
        var T = void 0;
        for (r = 0; r < b.length; r++)
          if (b[r].isect == C) {
            T = r;
            break;
          }
        if ((null != T && b.splice(T, 1), mk(R, f[C].ringAndEdge1))) {
          if (((R = f[C].ringAndEdge2), (f[C].ringAndEdge2Walkable = !1), f[C].ringAndEdge1Walkable)) {
            var A = { isect: C };
            vk([f[L].coord, f[C].coord, f[f[C].nxtIsectAlongRingAndEdge2].coord], 1 == N)
              ? ((A.parent = P), (A.winding = -N))
              : ((A.parent = M), (A.winding = N)),
              b.push(A);
          }
          (L = C), (C = f[C].nxtIsectAlongRingAndEdge2);
        } else {
          if (((R = f[C].ringAndEdge1), (f[C].ringAndEdge1Walkable = !1), f[C].ringAndEdge2Walkable)) {
            A = { isect: C };
            vk([f[L].coord, f[C].coord, f[f[C].nxtIsectAlongRingAndEdge1].coord], 1 == N)
              ? ((A.parent = P), (A.winding = -N))
              : ((A.parent = M), (A.winding = N)),
              b.push(A);
          }
          (L = C), (C = f[C].nxtIsectAlongRingAndEdge1);
        }
      }
      O.push(f[C].coord), l.push(Cu([O], { index: M, parent: P, winding: N, netWinding: void 0 }));
    }
    c = ju(l);
    function D() {
      for (var t = [], e = 0; e < c.features.length; e++) -1 == c.features[e].properties.parent && t.push(e);
      if (t.length > 1)
        for (e = 0; e < t.length; e++) {
          for (var n = -1, r = 0; r < c.features.length; r++)
            t[e] != r &&
              Nc(c.features[t[e]].geometry.coordinates[0][0], c.features[r], { ignoreBoundary: !0 }) &&
              Jl(c.features[r]) < Infinity &&
              (n = r);
          c.features[t[e]].properties.parent = n;
        }
    }
    function j() {
      for (var t = 0; t < c.features.length; t++)
        if (-1 == c.features[t].properties.parent) {
          var e = c.features[t].properties.winding;
          (c.features[t].properties.netWinding = e), F(t, e);
        }
    }
    function F(t, e) {
      for (var n = 0; n < c.features.length; n++)
        if (c.features[n].properties.parent == t) {
          var r = e + c.features[n].properties.winding;
          (c.features[n].properties.netWinding = r), F(n, r);
        }
    }
    return D(), j(), lk(D, 'determineParents'), lk(j, 'setNetWinding'), lk(F, 'setNetWindingOfChildren'), c;
  }
  lk(ck, 'geojsonPolygonSelfIntersections'), lk(hk, 'intersect'), lk(fk, 'equalArrays'), lk(pk, 'simplepolygon');
  var gk = lk(function (t, e, n, r, i) {
      (this.coord = t),
        (this.param = e),
        (this.ringAndEdgeIn = n),
        (this.ringAndEdgeOut = r),
        (this.nxtIsectAlongEdgeIn = i);
    }, 'PseudoVtx'),
    yk = lk(function (t, e, n, r, i, o, a) {
      (this.coord = t),
        (this.ringAndEdge1 = e),
        (this.ringAndEdge2 = n),
        (this.nxtIsectAlongRingAndEdge1 = r),
        (this.nxtIsectAlongRingAndEdge2 = i),
        (this.ringAndEdge1Walkable = o),
        (this.ringAndEdge2Walkable = a);
    }, 'Isect');
  function vk(t, e) {
    if ((void 0 === e && (e = !0), 3 != t.length))
      throw new Error('This function requires an array of three points [x,y]');
    return (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]) >= 0 == e;
  }
  function dk(t) {
    for (var e = 0, n = 0; n < t.length - 1; n++) t[n][0] < t[e][0] && (e = n);
    if (vk([t[_k(e - 1, t.length - 1)], t[e], t[_k(e + 1, t.length - 1)]], !0)) var r = 1;
    else r = -1;
    return r;
  }
  function mk(t, e) {
    if (!t || !e) return !1;
    if (t.length != e.length) return !1;
    for (var n = 0, r = t.length; n < r; n++)
      if (t[n] instanceof Array && e[n] instanceof Array) {
        if (!mk(t[n], e[n])) return !1;
      } else if (t[n] != e[n]) return !1;
    return !0;
  }
  function _k(t, e) {
    return ((t % e) + e) % e;
  }
  function bk(t) {
    for (var e = {}, n = 1, r = 0, i = t.length; r < i; ++r) {
      if (Object.prototype.hasOwnProperty.call(e, t[r])) {
        n = 0;
        break;
      }
      e[t[r]] = 1;
    }
    return n;
  }
  function xk(t) {
    var e = [];
    return (
      Bl(t, function (t) {
        'Polygon' === t.geometry.type &&
          Tl(pk(t), function (n) {
            e.push(Cu(n.geometry.coordinates, t.properties));
          });
      }),
      ju(e)
    );
  }
  function Ek(t) {
    return function () {
      return t;
    };
  }
  function wk(t) {
    return t[0];
  }
  function kk(t) {
    return t[1];
  }
  function Sk() {
    this._ = null;
  }
  function Ik(t) {
    t.U = t.C = t.L = t.R = t.P = t.N = null;
  }
  function Pk(t, e) {
    var n = e,
      r = e.R,
      i = n.U;
    i ? (i.L === n ? (i.L = r) : (i.R = r)) : (t._ = r),
      (r.U = i),
      (n.U = r),
      (n.R = r.L),
      n.R && (n.R.U = n),
      (r.L = n);
  }
  function Nk(t, e) {
    var n = e,
      r = e.L,
      i = n.U;
    i ? (i.L === n ? (i.L = r) : (i.R = r)) : (t._ = r),
      (r.U = i),
      (n.U = r),
      (n.L = r.R),
      n.L && (n.L.U = n),
      (r.R = n);
  }
  function Mk(t) {
    for (; t.L; ) t = t.L;
    return t;
  }
  function Ok(t, e, n, r) {
    var i = [null, null],
      o = tS.push(i) - 1;
    return (
      (i.left = t),
      (i.right = e),
      n && Rk(i, t, e, n),
      r && Rk(i, e, t, r),
      Qk[t.index].halfedges.push(o),
      Qk[e.index].halfedges.push(o),
      i
    );
  }
  function Lk(t, e, n) {
    var r = [e, n];
    return (r.left = t), r;
  }
  function Rk(t, e, n, r) {
    t[0] || t[1] ? (t.left === n ? (t[1] = r) : (t[0] = r)) : ((t[0] = r), (t.left = e), (t.right = n));
  }
  function Ck(t, e, n, r, i) {
    var o,
      a = t[0],
      s = t[1],
      u = a[0],
      l = a[1],
      c = 0,
      h = 1,
      f = s[0] - u,
      p = s[1] - l;
    if (((o = e - u), f || !(o > 0))) {
      if (((o /= f), f < 0)) {
        if (o < c) return;
        o < h && (h = o);
      } else if (f > 0) {
        if (o > h) return;
        o > c && (c = o);
      }
      if (((o = r - u), f || !(o < 0))) {
        if (((o /= f), f < 0)) {
          if (o > h) return;
          o > c && (c = o);
        } else if (f > 0) {
          if (o < c) return;
          o < h && (h = o);
        }
        if (((o = n - l), p || !(o > 0))) {
          if (((o /= p), p < 0)) {
            if (o < c) return;
            o < h && (h = o);
          } else if (p > 0) {
            if (o > h) return;
            o > c && (c = o);
          }
          if (((o = i - l), p || !(o < 0))) {
            if (((o /= p), p < 0)) {
              if (o > h) return;
              o > c && (c = o);
            } else if (p > 0) {
              if (o < c) return;
              o < h && (h = o);
            }
            return (
              !(c > 0 || h < 1) ||
              (c > 0 && (t[0] = [u + c * f, l + c * p]), h < 1 && (t[1] = [u + h * f, l + h * p]), !0)
            );
          }
        }
      }
    }
  }
  function Tk(t, e, n, r, i) {
    var o = t[1];
    if (o) return !0;
    var a,
      s,
      u = t[0],
      l = t.left,
      c = t.right,
      h = l[0],
      f = l[1],
      p = c[0],
      g = c[1],
      y = (h + p) / 2,
      v = (f + g) / 2;
    if (g === f) {
      if (y < e || y >= r) return;
      if (h > p) {
        if (u) {
          if (u[1] >= i) return;
        } else u = [y, n];
        o = [y, i];
      } else {
        if (u) {
          if (u[1] < n) return;
        } else u = [y, i];
        o = [y, n];
      }
    } else if (((s = v - (a = (h - p) / (g - f)) * y), a < -1 || a > 1))
      if (h > p) {
        if (u) {
          if (u[1] >= i) return;
        } else u = [(n - s) / a, n];
        o = [(i - s) / a, i];
      } else {
        if (u) {
          if (u[1] < n) return;
        } else u = [(i - s) / a, i];
        o = [(n - s) / a, n];
      }
    else if (f < g) {
      if (u) {
        if (u[0] >= r) return;
      } else u = [e, a * e + s];
      o = [r, a * r + s];
    } else {
      if (u) {
        if (u[0] < e) return;
      } else u = [r, a * r + s];
      o = [e, a * e + s];
    }
    return (t[0] = u), (t[1] = o), !0;
  }
  function Ak(t, e) {
    var n = t.site,
      r = e.left,
      i = e.right;
    return (
      n === i && ((i = r), (r = n)),
      i
        ? Math.atan2(i[1] - r[1], i[0] - r[0])
        : (n === r ? ((r = e[1]), (i = e[0])) : ((r = e[0]), (i = e[1])), Math.atan2(r[0] - i[0], i[1] - r[1]))
    );
  }
  function Dk(t, e) {
    return e[+(e.left !== t.site)];
  }
  function jk(t, e) {
    return e[+(e.left === t.site)];
  }
  lk(vk, 'isConvex'),
    lk(dk, 'windingOfRing'),
    lk(mk, 'equalArrays'),
    lk(_k, 'modulo'),
    lk(bk, 'isUnique'),
    lk(xk, 'unkinkPolygon'),
    (Sk.prototype = {
      constructor: Sk,
      insert: function (t, e) {
        var n, r, i;
        if (t) {
          if (((e.P = t), (e.N = t.N), t.N && (t.N.P = e), (t.N = e), t.R)) {
            for (t = t.R; t.L; ) t = t.L;
            t.L = e;
          } else t.R = e;
          n = t;
        } else
          this._
            ? ((t = Mk(this._)), (e.P = null), (e.N = t), (t.P = t.L = e), (n = t))
            : ((e.P = e.N = null), (this._ = e), (n = null));
        for (e.L = e.R = null, e.U = n, e.C = !0, t = e; n && n.C; )
          n === (r = n.U).L
            ? (i = r.R) && i.C
              ? ((n.C = i.C = !1), (r.C = !0), (t = r))
              : (t === n.R && (Pk(this, n), (n = (t = n).U)), (n.C = !1), (r.C = !0), Nk(this, r))
            : (i = r.L) && i.C
            ? ((n.C = i.C = !1), (r.C = !0), (t = r))
            : (t === n.L && (Nk(this, n), (n = (t = n).U)), (n.C = !1), (r.C = !0), Pk(this, r)),
            (n = t.U);
        this._.C = !1;
      },
      remove: function (t) {
        t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), (t.N = t.P = null);
        var e,
          n,
          r,
          i = t.U,
          o = t.L,
          a = t.R;
        if (
          ((n = o ? (a ? Mk(a) : o) : a),
          i ? (i.L === t ? (i.L = n) : (i.R = n)) : (this._ = n),
          o && a
            ? ((r = n.C),
              (n.C = t.C),
              (n.L = o),
              (o.U = n),
              n !== a
                ? ((i = n.U), (n.U = t.U), (t = n.R), (i.L = t), (n.R = a), (a.U = n))
                : ((n.U = i), (i = n), (t = n.R)))
            : ((r = t.C), (t = n)),
          t && (t.U = i),
          !r)
        )
          if (t && t.C) t.C = !1;
          else {
            do {
              if (t === this._) break;
              if (t === i.L) {
                if (
                  ((e = i.R).C && ((e.C = !1), (i.C = !0), Pk(this, i), (e = i.R)), (e.L && e.L.C) || (e.R && e.R.C))
                ) {
                  (e.R && e.R.C) || ((e.L.C = !1), (e.C = !0), Nk(this, e), (e = i.R)),
                    (e.C = i.C),
                    (i.C = e.R.C = !1),
                    Pk(this, i),
                    (t = this._);
                  break;
                }
              } else if (
                ((e = i.L).C && ((e.C = !1), (i.C = !0), Nk(this, i), (e = i.L)), (e.L && e.L.C) || (e.R && e.R.C))
              ) {
                (e.L && e.L.C) || ((e.R.C = !1), (e.C = !0), Pk(this, e), (e = i.L)),
                  (e.C = i.C),
                  (i.C = e.L.C = !1),
                  Nk(this, i),
                  (t = this._);
                break;
              }
              (e.C = !0), (t = i), (i = i.U);
            } while (!t.C);
            t && (t.C = !1);
          }
      },
    });
  var Fk,
    Bk = [];
  function qk() {
    Ik(this), (this.x = this.y = this.arc = this.site = this.cy = null);
  }
  function Vk(t) {
    var e = t.P,
      n = t.N;
    if (e && n) {
      var r = e.site,
        i = t.site,
        o = n.site;
      if (r !== o) {
        var a = i[0],
          s = i[1],
          u = r[0] - a,
          l = r[1] - s,
          c = o[0] - a,
          h = o[1] - s,
          f = 2 * (u * h - l * c);
        if (!(f >= -nS)) {
          var p = u * u + l * l,
            g = c * c + h * h,
            y = (h * p - l * g) / f,
            v = (u * g - c * p) / f,
            d = Bk.pop() || new qk();
          (d.arc = t), (d.site = i), (d.x = y + a), (d.y = (d.cy = v + s) + Math.sqrt(y * y + v * v)), (t.circle = d);
          for (var m = null, _ = Kk._; _; )
            if (d.y < _.y || (d.y === _.y && d.x <= _.x)) {
              if (!_.L) {
                m = _.P;
                break;
              }
              _ = _.L;
            } else {
              if (!_.R) {
                m = _;
                break;
              }
              _ = _.R;
            }
          Kk.insert(m, d), m || (Fk = d);
        }
      }
    }
  }
  function Gk(t) {
    var e = t.circle;
    e && (e.P || (Fk = e.N), Kk.remove(e), Bk.push(e), Ik(e), (t.circle = null));
  }
  var Yk = [];
  function zk() {
    Ik(this), (this.edge = this.site = this.circle = null);
  }
  function Uk(t) {
    var e = Yk.pop() || new zk();
    return (e.site = t), e;
  }
  function Xk(t) {
    Gk(t), $k.remove(t), Yk.push(t), Ik(t);
  }
  function Wk(t) {
    var e = t.circle,
      n = e.x,
      r = e.cy,
      i = [n, r],
      o = t.P,
      a = t.N,
      s = [t];
    Xk(t);
    for (var u = o; u.circle && Math.abs(n - u.circle.x) < eS && Math.abs(r - u.circle.cy) < eS; )
      (o = u.P), s.unshift(u), Xk(u), (u = o);
    s.unshift(u), Gk(u);
    for (var l = a; l.circle && Math.abs(n - l.circle.x) < eS && Math.abs(r - l.circle.cy) < eS; )
      (a = l.N), s.push(l), Xk(l), (l = a);
    s.push(l), Gk(l);
    var c,
      h = s.length;
    for (c = 1; c < h; ++c) (l = s[c]), (u = s[c - 1]), Rk(l.edge, u.site, l.site, i);
    (u = s[0]), ((l = s[h - 1]).edge = Ok(u.site, l.site, null, i)), Vk(u), Vk(l);
  }
  function Hk(t) {
    for (var e, n, r, i, o = t[0], a = t[1], s = $k._; s; )
      if ((r = Zk(s, a) - o) > eS) s = s.L;
      else {
        if (!((i = o - Jk(s, a)) > eS)) {
          r > -eS ? ((e = s.P), (n = s)) : i > -eS ? ((e = s), (n = s.N)) : (e = n = s);
          break;
        }
        if (!s.R) {
          e = s;
          break;
        }
        s = s.R;
      }
    !(function (t) {
      Qk[t.index] = { site: t, halfedges: [] };
    })(t);
    var u = Uk(t);
    if (($k.insert(e, u), e || n)) {
      if (e === n)
        return Gk(e), (n = Uk(e.site)), $k.insert(u, n), (u.edge = n.edge = Ok(e.site, u.site)), Vk(e), void Vk(n);
      if (n) {
        Gk(e), Gk(n);
        var l = e.site,
          c = l[0],
          h = l[1],
          f = t[0] - c,
          p = t[1] - h,
          g = n.site,
          y = g[0] - c,
          v = g[1] - h,
          d = 2 * (f * v - p * y),
          m = f * f + p * p,
          _ = y * y + v * v,
          b = [(v * m - p * _) / d + c, (f * _ - y * m) / d + h];
        Rk(n.edge, l, g, b), (u.edge = Ok(l, t, null, b)), (n.edge = Ok(t, g, null, b)), Vk(e), Vk(n);
      } else u.edge = Ok(e.site, u.site);
    }
  }
  function Zk(t, e) {
    var n = t.site,
      r = n[0],
      i = n[1],
      o = i - e;
    if (!o) return r;
    var a = t.P;
    if (!a) return -1 / 0;
    var s = (n = a.site)[0],
      u = n[1],
      l = u - e;
    if (!l) return s;
    var c = s - r,
      h = 1 / o - 1 / l,
      f = c / l;
    return h ? (-f + Math.sqrt(f * f - 2 * h * ((c * c) / (-2 * l) - u + l / 2 + i - o / 2))) / h + r : (r + s) / 2;
  }
  function Jk(t, e) {
    var n = t.N;
    if (n) return Zk(n, e);
    var r = t.site;
    return r[1] === e ? r[0] : 1 / 0;
  }
  var $k,
    Qk,
    Kk,
    tS,
    eS = 1e-6,
    nS = 1e-12;
  function rS(t, e) {
    return e[1] - t[1] || e[0] - t[0];
  }
  function iS(t, e) {
    var n,
      r,
      i,
      o = t.sort(rS).pop();
    for (tS = [], Qk = new Array(t.length), $k = new Sk(), Kk = new Sk(); ; )
      if (((i = Fk), o && (!i || o[1] < i.y || (o[1] === i.y && o[0] < i.x))))
        (o[0] === n && o[1] === r) || (Hk(o), (n = o[0]), (r = o[1])), (o = t.pop());
      else {
        if (!i) break;
        Wk(i.arc);
      }
    if (
      ((function () {
        for (var t, e, n, r, i = 0, o = Qk.length; i < o; ++i)
          if ((t = Qk[i]) && (r = (e = t.halfedges).length)) {
            var a = new Array(r),
              s = new Array(r);
            for (n = 0; n < r; ++n) (a[n] = n), (s[n] = Ak(t, tS[e[n]]));
            for (
              a.sort(function (t, e) {
                return s[e] - s[t];
              }),
                n = 0;
              n < r;
              ++n
            )
              s[n] = e[a[n]];
            for (n = 0; n < r; ++n) e[n] = s[n];
          }
      })(),
      e)
    ) {
      var a = +e[0][0],
        s = +e[0][1],
        u = +e[1][0],
        l = +e[1][1];
      !(function (t, e, n, r) {
        for (var i, o = tS.length; o--; )
          (Tk((i = tS[o]), t, e, n, r) &&
            Ck(i, t, e, n, r) &&
            (Math.abs(i[0][0] - i[1][0]) > eS || Math.abs(i[0][1] - i[1][1]) > eS)) ||
            delete tS[o];
      })(a, s, u, l),
        (function (t, e, n, r) {
          var i,
            o,
            a,
            s,
            u,
            l,
            c,
            h,
            f,
            p,
            g,
            y,
            v = Qk.length,
            d = !0;
          for (i = 0; i < v; ++i)
            if ((o = Qk[i])) {
              for (a = o.site, s = (u = o.halfedges).length; s--; ) tS[u[s]] || u.splice(s, 1);
              for (s = 0, l = u.length; s < l; )
                (g = (p = jk(o, tS[u[s]]))[0]),
                  (y = p[1]),
                  (h = (c = Dk(o, tS[u[++s % l]]))[0]),
                  (f = c[1]),
                  (Math.abs(g - h) > eS || Math.abs(y - f) > eS) &&
                    (u.splice(
                      s,
                      0,
                      tS.push(
                        Lk(
                          a,
                          p,
                          Math.abs(g - t) < eS && r - y > eS
                            ? [t, Math.abs(h - t) < eS ? f : r]
                            : Math.abs(y - r) < eS && n - g > eS
                            ? [Math.abs(f - r) < eS ? h : n, r]
                            : Math.abs(g - n) < eS && y - e > eS
                            ? [n, Math.abs(h - n) < eS ? f : e]
                            : Math.abs(y - e) < eS && g - t > eS
                            ? [Math.abs(f - e) < eS ? h : t, e]
                            : null,
                        ),
                      ) - 1,
                    ),
                    ++l);
              l && (d = !1);
            }
          if (d) {
            var m,
              _,
              b,
              x = 1 / 0;
            for (i = 0, d = null; i < v; ++i)
              (o = Qk[i]) && (b = (m = (a = o.site)[0] - t) * m + (_ = a[1] - e) * _) < x && ((x = b), (d = o));
            if (d) {
              var E = [t, e],
                w = [t, r],
                k = [n, r],
                S = [n, e];
              d.halfedges.push(
                tS.push(Lk((a = d.site), E, w)) - 1,
                tS.push(Lk(a, w, k)) - 1,
                tS.push(Lk(a, k, S)) - 1,
                tS.push(Lk(a, S, E)) - 1,
              );
            }
          }
          for (i = 0; i < v; ++i) (o = Qk[i]) && (o.halfedges.length || delete Qk[i]);
        })(a, s, u, l);
    }
    (this.edges = tS), (this.cells = Qk), ($k = Kk = tS = Qk = null);
  }
  iS.prototype = {
    constructor: iS,
    polygons: function () {
      var t = this.edges;
      return this.cells.map(function (e) {
        var n = e.halfedges.map(function (n) {
          return Dk(e, t[n]);
        });
        return (n.data = e.site.data), n;
      });
    },
    triangles: function () {
      var t = [],
        e = this.edges;
      return (
        this.cells.forEach(function (n, r) {
          if ((o = (i = n.halfedges).length))
            for (
              var i, o, a, s, u, l, c = n.site, h = -1, f = e[i[o - 1]], p = f.left === c ? f.right : f.left;
              ++h < o;

            )
              (a = p),
                (p = (f = e[i[h]]).left === c ? f.right : f.left),
                a &&
                  p &&
                  r < a.index &&
                  r < p.index &&
                  ((u = a), (l = p), ((s = c)[0] - l[0]) * (u[1] - s[1]) - (s[0] - u[0]) * (l[1] - s[1]) < 0) &&
                  t.push([c.data, a.data, p.data]);
        }),
        t
      );
    },
    links: function () {
      return this.edges
        .filter(function (t) {
          return t.right;
        })
        .map(function (t) {
          return { source: t.left.data, target: t.right.data };
        });
    },
    find: function (t, e, n) {
      for (var r, i, o = this, a = o._found || 0, s = o.cells.length; !(i = o.cells[a]); ) if (++a >= s) return null;
      var u = t - i.site[0],
        l = e - i.site[1],
        c = u * u + l * l;
      do {
        (i = o.cells[(r = a)]),
          (a = null),
          i.halfedges.forEach(function (n) {
            var r = o.edges[n],
              s = r.left;
            if ((s !== i.site && s) || (s = r.right)) {
              var u = t - s[0],
                l = e - s[1],
                h = u * u + l * l;
              h < c && ((c = h), (a = s.index));
            }
          });
      } while (null !== a);
      return (o._found = r), null == n || c <= n * n ? i.site : null;
    },
  };
  var oS = Object.defineProperty,
    aS = function (t, e) {
      return oS(t, 'name', { value: e, configurable: !0 });
    };
  function sS(t) {
    return (t = t.slice()).push(t[0]), Cu([t]);
  }
  function uS(t, e) {
    if (!Qu((e = e || {}))) throw new Error('options is invalid');
    var n = e.bbox || [-180, -85, 180, 85];
    if (!t) throw new Error('points is required');
    if (!Array.isArray(n)) throw new Error('bbox is invalid');
    return (
      ll(t, 'Point', 'points'),
      ju(
        (function () {
          var t = wk,
            e = kk,
            n = null;
          function r(r) {
            return new iS(
              r.map(function (n, i) {
                var o = [Math.round(t(n, i, r) / eS) * eS, Math.round(e(n, i, r) / eS) * eS];
                return (o.index = i), (o.data = n), o;
              }),
              n,
            );
          }
          return (
            (r.polygons = function (t) {
              return r(t).polygons();
            }),
            (r.links = function (t) {
              return r(t).links();
            }),
            (r.triangles = function (t) {
              return r(t).triangles();
            }),
            (r.x = function (e) {
              return arguments.length ? ((t = 'function' == typeof e ? e : Ek(+e)), r) : t;
            }),
            (r.y = function (t) {
              return arguments.length ? ((e = 'function' == typeof t ? t : Ek(+t)), r) : e;
            }),
            (r.extent = function (t) {
              return arguments.length
                ? ((n =
                    null == t
                      ? null
                      : [
                          [+t[0][0], +t[0][1]],
                          [+t[1][0], +t[1][1]],
                        ]),
                  r)
                : n && [
                    [n[0][0], n[0][1]],
                    [n[1][0], n[1][1]],
                  ];
            }),
            (r.size = function (t) {
              return arguments.length
                ? ((n =
                    null == t
                      ? null
                      : [
                          [0, 0],
                          [+t[0], +t[1]],
                        ]),
                  r)
                : n && [n[1][0] - n[0][0], n[1][1] - n[0][1]];
            }),
            r
          );
        })()
          .x(function (t) {
            return t.geometry.coordinates[0];
          })
          .y(function (t) {
            return t.geometry.coordinates[1];
          })
          .extent([
            [n[0], n[1]],
            [n[2], n[3]],
          ])
          .polygons(t.features)
          .map(function (e, n) {
            return Object.assign(sS(e), { properties: Ty(t.features[n].properties) });
          }),
      )
    );
  }
  aS(sS, 'coordsToPolygon'),
    aS(uS, 'voronoi'),
    (t.GeojsonEquality = wu),
    (t.along = xl),
    (t.angle = Pl),
    (t.applyFilter = zy),
    (t.area = Jl),
    (t.areaFactors = Nu),
    (t.bbox = rc),
    (t.bboxClip = cc),
    (t.bboxPolygon = pc),
    (t.bearing = yl),
    (t.bearingToAzimuth = Xu),
    (t.bezierSpline = bc),
    (t.booleanClockwise = Ec),
    (t.booleanConcave = kc),
    (t.booleanContains = Dc),
    (t.booleanCrosses = dh),
    (t.booleanDisjoint = Sh),
    (t.booleanEqual = qh),
    (t.booleanIntersects = Gh),
    (t.booleanOverlap = Lf),
    (t.booleanParallel = Tf),
    (t.booleanPointInPolygon = Nc),
    (t.booleanPointOnLine = Rc),
    (t.booleanTouches = Bf),
    (t.booleanValid = zf),
    (t.booleanWithin = Jf),
    (t.buffer = Dg),
    (t.center = up),
    (t.centerMean = Yg),
    (t.centerMedian = Hg),
    (t.centerOfMass = Py),
    (t.centroid = Ug),
    (t.circle = My),
    (t.cleanCoords = Ah),
    (t.clone = Ry),
    (t.cloneProperties = Ty),
    (t.clusterEach = Vy),
    (t.clusterReduce = Gy),
    (t.clusters = Wy),
    (t.clustersDbscan = $y),
    (t.clustersKmeans = cv),
    (t.collect = pv),
    (t.collectionOf = ll),
    (t.combine = yv),
    (t.concave = td),
    (t.containsNumber = al),
    (t.convertArea = Ju),
    (t.convertLength = Zu),
    (t.convex = Sy),
    (t.coordAll = Dl),
    (t.coordEach = Ol),
    (t.coordReduce = Ll),
    (t.createBins = Yy),
    (t.degreesToRadians = Hu),
    (t.destination = dl),
    (t.difference = Wd),
    (t.dissolve = $d),
    (t.distance = _l),
    (t.distanceWeight = em),
    (t.earthRadius = Iu),
    (t.ellipse = gm),
    (t.envelope = dm),
    (t.explode = _m),
    (t.factors = Pu),
    (t.feature = Mu),
    (t.featureCollection = ju),
    (t.featureEach = Tl),
    (t.featureOf = ul),
    (t.featureReduce = Al),
    (t.filterProperties = Xy),
    (t.findPoint = Xl),
    (t.findSegment = Ul),
    (t.flatten = Zd),
    (t.flattenEach = Bl),
    (t.flattenReduce = ql),
    (t.flip = xm),
    (t.geojsonRbush = lf),
    (t.geojsonType = sl),
    (t.geomEach = jl),
    (t.geomReduce = Fl),
    (t.geometry = Ou),
    (t.geometryCollection = Vu),
    (t.getCluster = qy),
    (t.getCoord = il),
    (t.getCoords = ol),
    (t.getGeom = cl),
    (t.getType = hl),
    (t.greatCircle = Om),
    (t.helpers = el),
    (t.hexGrid = Am),
    (t.interpolate = Wm),
    (t.intersect = Rm),
    (t.invariant = fl),
    (t.isNumber = $u),
    (t.isObject = Qu),
    (t.isobands = __),
    (t.isolines = A_),
    (t.kinks = q_),
    (t.length = G_),
    (t.lengthToDegrees = Uu),
    (t.lengthToRadians = zu),
    (t.lineArc = U_),
    (t.lineChunk = $_),
    (t.lineEach = Yl),
    (t.lineIntersect = uh),
    (t.lineOffset = lb),
    (t.lineOverlap = Nf),
    (t.lineReduce = zl),
    (t.lineSegment = ff),
    (t.lineSlice = pb),
    (t.lineSliceAlong = H_),
    (t.lineSplit = Eb),
    (t.lineString = Au),
    (t.lineStrings = Du),
    (t.lineToPolygon = Mb),
    (t.mask = Ab),
    (t.meta = Wl),
    (t.midpoint = qb),
    (t.moranIndex = Yb),
    (t.multiLineString = Fu),
    (t.multiPoint = Bu),
    (t.multiPolygon = qu),
    (t.nearestNeighborAnalysis = rx),
    (t.nearestPoint = ex),
    (t.nearestPointOnLine = Sf),
    (t.nearestPointToLine = dx),
    (t.planepoint = bx),
    (t.point = Lu),
    (t.pointGrid = Bm),
    (t.pointOnFeature = wx),
    (t.pointToLineDistance = ax),
    (t.points = Ru),
    (t.pointsWithinPolygon = Px),
    (t.polygon = Cu),
    (t.polygonSmooth = Wx),
    (t.polygonTangents = Qx),
    (t.polygonToLine = hh),
    (t.polygonize = zx),
    (t.polygons = Tu),
    (t.projection = hE),
    (t.propEach = Rl),
    (t.propReduce = Cl),
    (t.propertiesContainsFilter = Uy),
    (t.quadratAnalysis = gE),
    (t.radiansToDegrees = Wu),
    (t.radiansToLength = Yu),
    (t.random = LE),
    (t.randomLineString = SE),
    (t.randomPoint = wE),
    (t.randomPolygon = kE),
    (t.randomPosition = bE),
    (t.rectangleGrid = Vm),
    (t.rewind = TE),
    (t.rhumbBearing = kl),
    (t.rhumbDestination = im),
    (t.rhumbDistance = um),
    (t.round = Gu),
    (t.sample = qE),
    (t.sector = zE),
    (t.segmentEach = Vl),
    (t.segmentReduce = Gl),
    (t.shortestPath = ow),
    (t.simplify = yw),
    (t.square = yb),
    (t.squareGrid = Ym),
    (t.standardDeviationalEllipse = xw),
    (t.tag = kw),
    (t.tesselate = ek),
    (t.tin = mv),
    (t.toMercator = oE),
    (t.toWgs84 = aE),
    (t.transformRotate = hm),
    (t.transformScale = HE),
    (t.transformTranslate = ok),
    (t.triangleGrid = Um),
    (t.truncate = mb),
    (t.union = sk),
    (t.unkinkPolygon = xk),
    (t.validateBBox = Ku),
    (t.validateId = tl),
    (t.voronoi = uS),
    Object.defineProperty(t, '__esModule', { value: !0 });
});
